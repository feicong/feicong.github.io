<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mach-O文件格式 | fEICOnG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="0x1 通用二进制格式虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。
macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐">
<meta property="og:type" content="article">
<meta property="og:title" content="Mach-O文件格式">
<meta property="og:url" content="https://feicong.github.io/2017/01/13/macho/index.html">
<meta property="og:site_name" content="fEICOnG's Blog">
<meta property="og:description" content="0x1 通用二进制格式虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。
macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/mach-o.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/mach_header.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/010_editor.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/synalyze_it.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/calc_cer.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/load_command.png">
<meta property="og:image" content="https://feicong.github.io/2017/01/13/macho/python_seg.png">
<meta property="og:updated_time" content="2017-01-13T01:37:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mach-O文件格式">
<meta name="twitter:description" content="0x1 通用二进制格式虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。
macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐">
<meta name="twitter:image" content="https://feicong.github.io/2017/01/13/macho/mach-o.png">
  
    <link rel="alternate" href="/atom.xml" title="fEICOnG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fEICOnG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RE makes life easier</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://feicong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-macho" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/macho/" class="article-date">
  <time datetime="2017-01-13T01:03:08.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mach-O文件格式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x1-通用二进制格式"><a href="#0x1-通用二进制格式" class="headerlink" title="0x1 通用二进制格式"></a>0x1 通用二进制格式</h2><p>虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。</p>
<p>macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。<br>又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同CPU架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行<code>file</code>命令可以查看它的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ file /usr/bin/python</div><div class="line">/usr/bin/python: Mach-O universal binary with 2 architectures</div><div class="line">/usr/bin/python (for architecture x86_64):	Mach-O 64-bit executable x86_64</div><div class="line">/usr/bin/python (for architecture i386):	Mach-O executable i386</div></pre></td></tr></table></figure></p>
<p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。例如提取<code>python</code>中x86_64版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>删除x86版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>或者直接瘦身为x86_64版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>通用二进制的“通用”不止针对可以直接运行的可执行程序，系统中的动态库dylib、静态库.a文件以及框架等都可以是通用二进制文件，对它们也可以同样使用<code>lipo</code>命令来进行管理。<br>下来看一下通用二进制的文件格式。安装好macOS程序开发的SDK后，或者在xnu的内核源码中，都可以在&lt;mach-o/fat.h&gt;文件中找到通用二进制文件格式的声明。从文件命名上看，将通用二进制称为胖二进制更方便一些。胖二进制头部结构<code>fat_header</code>定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define FAT_MAGIC	0xcafebabe</div><div class="line">#define FAT_CIGAM	0xbebafeca	/* NXSwapLong(FAT_MAGIC) */</div><div class="line"></div><div class="line">struct fat_header &#123;</div><div class="line">	uint32_t	magic;		/* FAT_MAGIC */</div><div class="line">	uint32_t	nfat_arch;	/* number of structs that follow */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段被定义为常量<code>FAT_MAGIC</code>，它的取值是固定的0xcafebabe，表示这是一个通用的二进制文件。<code>nfat_arch</code>字段指明了通用二进制中包含多少个Mach-O文件。<br>每个通用二进制架构信息都使用<code>fat_arch</code>结构表示，在<code>fat_header</code>结构体之后，紧接着的是一个或多个连续的<code>fat_arch</code>结构体，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct fat_arch &#123;</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier (int) */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier (int) */</div><div class="line">	uint32_t	offset;		/* file offset to this object file */</div><div class="line">	uint32_t	size;		/* size of this object file */</div><div class="line">	uint32_t	align;		/* alignment as a power of 2 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cputype</code>指定了具体的cpu类型，它的类型是<code>cpu_type_t</code>，定义位于mach/machine.h中。<code>cpu</code>的常用类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define CPU_TYPE_X86		((cpu_type_t) 7)</div><div class="line">#define CPU_TYPE_I386		CPU_TYPE_X86		</div><div class="line">#define	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC98000	((cpu_type_t) 10)</div><div class="line">#define CPU_TYPE_HPPA           ((cpu_type_t) 11)</div><div class="line">#define CPU_TYPE_ARM		((cpu_type_t) 12)</div><div class="line">#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC88000	((cpu_type_t) 13)</div><div class="line">#define CPU_TYPE_SPARC		((cpu_type_t) 14)</div><div class="line">#define CPU_TYPE_I860		((cpu_type_t) 15)</div><div class="line">#define CPU_TYPE_POWERPC		((cpu_type_t) 18)</div><div class="line">#define CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64</div></pre></td></tr></table></figure></p>
<p>macOS平台上的CPU类型一般为<code>CPU_TYPE_X86_64</code>。</p>
<p><code>cpusubtype</code>指定了cpu的子类型。它的类型是<code>cpu_subtype_t</code>。cpu子类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define CPU_SUBTYPE_MASK	0xff000000</div><div class="line">#define CPU_SUBTYPE_LIB64	0x80000000</div><div class="line">#define CPU_SUBTYPE_X86_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_64_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_ARCH1		((cpu_subtype_t)4)</div><div class="line">#define CPU_SUBTYPE_X86_64_H		((cpu_subtype_t)8)</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>cpu子类型一般<code>CPU_SUBTYPE_LIB64</code>与<code>CPU_SUBTYPE_X86_64_ALL</code>比较常见。</p>
<p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值。<code>size</code>字段指明了数据的大小。</p>
<p><code>align</code>字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。</p>
<p>可以使用<code>otool</code>工具打印本机安装的<code>python</code>程序的<code>fat_header</code>信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">otool -f -V /usr/bin/python</div><div class="line">Fat headers</div><div class="line">fat_magic FAT_MAGIC</div><div class="line">nfat_arch 2</div><div class="line">architecture i386</div><div class="line">    cputype CPU_TYPE_I386</div><div class="line">    cpusubtype CPU_SUBTYPE_I386_ALL</div><div class="line">    capabilities 0x0</div><div class="line">    offset 4096</div><div class="line">    size 29632</div><div class="line">    align 2^12 (4096)</div><div class="line">architecture x86_64</div><div class="line">    cputype CPU_TYPE_X86_64</div><div class="line">    cpusubtype CPU_SUBTYPE_X86_64_ALL</div><div class="line">    capabilities CPU_SUBTYPE_LIB64</div><div class="line">    offset 36864</div><div class="line">    size 29872</div><div class="line">    align 2^12 (4096)</div></pre></td></tr></table></figure></p>
<p>如果你是UNIX的使用者，经常使用GNU里面<code>binutils</code>提供的<code>objdump</code>查看可执行文件信息的话，在macOS上可以使用它的移植版本<code>gobjdump</code>，使用<code>HomeBrew</code>运行以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install binutils</div></pre></td></tr></table></figure></p>
<p>完装完成后，执行下面的命令也可以查看<code>python</code>程序的<code>fat_header</code>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ gobjdump -f /usr/bin/python</div><div class="line">In archive /usr/bin/python:</div><div class="line"></div><div class="line">i386:     file format mach-o-i386</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00001be0</div><div class="line"></div><div class="line">i386:x86-64:     file format mach-o-x86-64</div><div class="line">architecture: i386:x86-64, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x0000000100000e20</div></pre></td></tr></table></figure></p>
<p>在<code>fat_arch</code>结构体往下就是具体的Mach-O文件格式了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h2 id="0x2-Mach-O文件格式简介"><a href="#0x2-Mach-O文件格式简介" class="headerlink" title="0x2 Mach-O文件格式简介"></a>0x2 Mach-O文件格式简介</h2><p>Mach-O（Mach Object File Format）描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式，有助于了解苹果底层软件运行机制，更好的掌握<code>dyld</code>加载Mach-O的步骤，为自己动手开发Mach-O相关的加解密工具打下基础。</p>
<p>一个典型的Mach-O文件格式如图所示：<br><img src="/2017/01/13/macho/mach-o.png" alt="mach-o"><br>通过上图，可以看出Mach-O主要由以下三部分组成：</p>
<ul>
<li>Mach-O头部（mach header）。描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</li>
<li>加载命令（load command）。描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</li>
<li>Data。Data中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个Section，它们存放了具体的数据与代码。</li>
</ul>
<h2 id="0x3-Mach-O头部"><a href="#0x3-Mach-O头部" class="headerlink" title="0x3 Mach-O头部"></a>0x3 Mach-O头部</h2><p>与Mach-O文件格式有关的结构体，都可以直接或间接的在”mach-o/loader.h“文件中找到。<br>针对32位与64位架构的cpu，分别使用了<code>mach_header</code>与<code>mach_header_64</code>结构体来描述Mach-O头部。<br><code>mach_header</code>结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct mach_header &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样，表示Mach-O文件的魔数值，对于32位架构的程序来说，它的取值是<code>MH_MAGIC</code>，固定为0xfeedface。<br><code>cputype</code>与<code>cpusubtype</code>字段与<code>fat_header</code>结构体中的含义完全相同。<br><code>filetype</code>字段表示Mach-O的具体文件类型。它的取值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define	MH_OBJECT	0x1		/* relocatable object file */</div><div class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */</div><div class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</div><div class="line">#define	MH_CORE		0x4		/* core file */</div><div class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</div><div class="line">#define	MH_DYLIB	0x6		/* dynamically bound shared library */</div><div class="line">#define	MH_DYLINKER	0x7		/* dynamic link editor */</div><div class="line">#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */</div><div class="line">#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */</div><div class="line">					/*  linking only, no section contents */</div><div class="line">#define	MH_DSYM		0xa		/* companion file with only debug sections */</div><div class="line">#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */</div></pre></td></tr></table></figure></p>
<p>这里主要关注<code>MH_EXECUTE</code>、<code>MH_DYLIB</code>与<code>MH_DYLIB</code>这3个文件格式。</p>
<p>接下来的<code>ncmds</code>指明了Mach-O文件中加载命令（load commands）的数量。</p>
<p><code>sizeofcmds</code>字段指明了Mach-O文件加载命令（load commands）所占的总字节大小。</p>
<p><code>flags</code>字段表示文件标志，它是一个含有一组位标志的整数，指明了Mach-O文件的一些标志信息。可用的值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define	MH_NOUNDEFS	0x1</div><div class="line">#define	MH_INCRLINK	0x2</div><div class="line">#define MH_DYLDLINK	0x4</div><div class="line">#define MH_LAZY_INIT 0x40</div><div class="line">#define MH_TWOLEVEL	0x80</div><div class="line">#define MH_PIE 0x200000</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>针对64位Mach-O的<code>mach_header_64</code>结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct mach_header_64 &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">	uint32_t	reserved;	/* reserved */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>相比<code>mach_header</code>，它多出了一个<code>reserved</code>字段，目前它的取值系统保留。<code>mach_header_64</code>结构体中的字段与<code>mach_header</code>中的基本一致，除了<code>magic</code>字段的取值是<code>MH_MAGIC_64</code>，固定的值为0xfeedfacf。<br>学习Mach-o文件格式时，可以使用辅助工具查看具体的文件结构，这样效果更加直观。<br>下图是<code>MachOView</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/mach_header.png" alt="mach_header"><br>下图是<code>010 Editor</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/010_editor.png" alt="010_editor"><br>下图是<code>Synalyze It!</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/synalyze_it.png" alt="synalyze_it"><br>这三款工具对于学习Mach-O文件格式都是非常有帮助的，读者在实际分析时可以多多使用。</p>
<h2 id="0x4-加载命令"><a href="#0x4-加载命令" class="headerlink" title="0x4 加载命令"></a>0x4 加载命令</h2><p>在<code>mach_header</code>之后的是Load Command加载命令，这些加载命令在Mach-O文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">	uint32_t cmd;		/* type of load command */</div><div class="line">	uint32_t cmdsize;	/* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此结构对应的成员只有2个：<code>cmd</code>字段代表当前加载命令的类型。<code>cmdsize</code>字段代表当前加载命令的大小。<br>cmd的类型不同，所代表的加载命令的类型就不同，它的结构体也会有所不一样，对于不同类型的加载命令，它们都会在<code>load_command</code>结构体后面加上一个或多个字段来表示自己特定的结构体信息。</p>
<p>macOS系统在进化的过程中，加载命令算是比较频繁被更新的一个数据结构体，截止到macOS 10.12系统，加载命令的类型cmd的取值共有48种。它们的部分定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */</div><div class="line">#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */</div><div class="line">#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */</div><div class="line">#define	LC_THREAD	0x4	/* thread */</div><div class="line">#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */</div><div class="line">#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */</div><div class="line">#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */</div><div class="line">#define	LC_IDENT	0x8	/* object identification info (obsolete) */</div><div class="line">#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */</div><div class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</div><div class="line">#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */</div><div class="line">#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */</div><div class="line">......</div><div class="line">#define	LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</div><div class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</div><div class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</div><div class="line">#ifndef __OPEN_SOURCE__</div><div class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</div><div class="line">#endif /* __OPEN_SOURCE__ */</div><div class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</div></pre></td></tr></table></figure></p>
<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_SEGMENT</code>、<code>LC_LOAD_DYLINKER</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等。</p>
<p><code>LC_SEGMENT</code>：表示这是一个段加载命令，需要将它加载到对应的进程空间上去。段加载命令将在下一小节进行讨论。</p>
<p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用<code>dylib_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct dylib_command &#123;</div><div class="line">	uint32_t	cmd;		/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,LC_REEXPORT_DYLIB */</div><div class="line">	uint32_t	cmdsize;	/* includes pathname string */</div><div class="line">	struct dylib dylib;		/* the library identification */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当cmd类型时<code>LC_ID_DYLIB</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>与<code>LC_REEXPORT_DYLIB</code>时，统一使用<code>dylib_command</code>结构体表示。<br>它使用dylib结构体来存储要加载的动态库的具体信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct dylib &#123;</div><div class="line">    union lc_str  name;			/* library&apos;s path name */</div><div class="line">    uint32_t timestamp;			/* library&apos;s build time stamp */</div><div class="line">    uint32_t current_version;		/* library&apos;s current version number */</div><div class="line">    uint32_t compatibility_version;	/* library&apos;s compatibility vers number*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>name</code>字段是动态库的完整路径，动态链接器在加载动态库时，通用此路径来进行加载它。<br><code>timestamp</code>字段描述了动态库构建时的时间戳。<code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号。</p>
<p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数<code>main()</code>的位置。它使用<code>entry_point_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct entry_point_command &#123;</div><div class="line">    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */</div><div class="line">    uint32_t  cmdsize;	/* 24 */</div><div class="line">    uint64_t  entryoff;	/* file (__TEXT) offset of main() */</div><div class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>entryoff</code>字段中就指定了<code>main()</code>函数的文件偏移。<code>stacksize</code>指定了初始的堆栈大小。</p>
<h2 id="0x5-LC-CODE-SIGNATURE与代码签名过程分析"><a href="#0x5-LC-CODE-SIGNATURE与代码签名过程分析" class="headerlink" title="0x5 LC_CODE_SIGNATURE与代码签名过程分析"></a>0x5 LC_CODE_SIGNATURE与代码签名过程分析</h2><p><code>LC_CODE_SIGNATURE</code>：代码签名加载命令。描述了Mach-O的代码签名信息，它属于链接信息，使用<code>linkedit_data_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct linkedit_data_command &#123;</div><div class="line">    uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,</div><div class="line">                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,</div><div class="line">				   LC_DYLIB_CODE_SIGN_DRS or</div><div class="line">				   LC_LINKER_OPTIMIZATION_HINT. */</div><div class="line">    uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */</div><div class="line">    uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */</div><div class="line">    uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>dataoff</code>字段指明了相对于<code>__LINKEDIT</code>段的文件偏移位置，<code>datasize</code>字段指明了数据的大小。<br>由于<code>dataoff</code>与<code>datasize</code>分别指明了代码签名的位置与大小，那么笔者在此提个问：如何删除Mach-O中包含的代码签名信息？</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的“bsd/sys/codesign.h”文件中找到。整个代码签名部分的头部使用一个<code>CS_SuperBlob</code>结构体定义，它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_SuperBlob &#123;</div><div class="line">	uint32_t magic;					/* magic number */</div><div class="line">	uint32_t length;				/* total length of SuperBlob */</div><div class="line">	uint32_t count;					/* number of index entries following */</div><div class="line">	CS_BlobIndex index[];			/* (count) entries */</div><div class="line">	/* followed by Blobs in no particular order as indicated by offsets in index */</div><div class="line">&#125; CS_SuperBlob;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段指明了Blob的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">	CSMAGIC_REQUIREMENT = 0xfade0c00,		/* single Requirement blob */</div><div class="line">	CSMAGIC_REQUIREMENTS = 0xfade0c01,		/* Requirements vector (internal requirements) */</div><div class="line">	CSMAGIC_CODEDIRECTORY = 0xfade0c02,		/* CodeDirectory blob */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02,	/* XXX */</div><div class="line">	CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,	/* embedded entitlements */</div><div class="line">	CSMAGIC_DETACHED_SIGNATURE = 0xfade0cc1, /* multi-arch collection of embedded signatures */</div><div class="line">	CSMAGIC_BLOBWRAPPER = 0xfade0b01,	/* CMS Signature, among other things */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第一个Blob来说，它的值必定是<code>CSMAGIC_EMBEDDED_SIGNATURE</code>，表示代码签名采用的嵌入式的签名信息。<br><code>length</code>字段指明了整个SuperBlob的大小，其中包含马上的介绍的CodeDirectory、Requirement、Entitlement的大小。<br><code>count</code>字段指明了接下来会有多少个子条目。<br>从<code>index</code>开始，就是每一个字条目的索引了，它的结构是<code>CS_BlobIndex</code>，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct __BlobIndex &#123;</div><div class="line">	uint32_t type;					/* type of entry */</div><div class="line">	uint32_t offset;				/* offset of entry */</div><div class="line">&#125; CS_BlobIndex;</div></pre></td></tr></table></figure></p>
<p><code>type</code>指明了子条目的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSSLOT_CODEDIRECTORY = 0,				/* slot index for CodeDirectory */</div><div class="line">CSSLOT_INFOSLOT = 1,</div><div class="line">CSSLOT_REQUIREMENTS = 2,</div><div class="line">CSSLOT_RESOURCEDIR = 3,</div><div class="line">CSSLOT_APPLICATION = 4,</div><div class="line">CSSLOT_ENTITLEMENTS = 5,</div><div class="line">CSSLOT_SIGNATURESLOT = 0x10000,			/* CMS Signature */</div></pre></td></tr></table></figure></p>
<p><code>offset</code>字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>通常，签名后的程序，签名数据的第一个子条目指向的是一个<code>type</code>为<code>CSSLOT_CODEDIRECTORY</code>的结构，它是一个<code>CS_CodeDirectory</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct __CodeDirectory &#123;</div><div class="line">	uint32_t magic;					/* magic number (CSMAGIC_CODEDIRECTORY) */</div><div class="line">	uint32_t length;				/* total length of CodeDirectory blob */</div><div class="line">	uint32_t version;				/* compatibility version */</div><div class="line">	uint32_t flags;					/* setup and mode flags */</div><div class="line">	uint32_t hashOffset;			/* offset of hash slot element at index zero */</div><div class="line">	uint32_t identOffset;			/* offset of identifier string */</div><div class="line">	uint32_t nSpecialSlots;			/* number of special hash slots */</div><div class="line">	uint32_t nCodeSlots;			/* number of ordinary (code) hash slots */</div><div class="line">	uint32_t codeLimit;				/* limit to main image signature range */</div><div class="line">	uint8_t hashSize;				/* size of each hash in bytes */</div><div class="line">	uint8_t hashType;				/* type of hash (cdHashType* constants) */</div><div class="line">	uint8_t platform;				/* platform identifier; zero if not platform binary */</div><div class="line">	uint8_t	pageSize;				/* log2(page size in bytes); 0 =&gt; infinite */</div><div class="line">	uint32_t spare2;				/* unused (must be zero) */</div><div class="line">	/* Version 0x20100 */</div><div class="line">	uint32_t scatterOffset;				/* offset of optional scatter vector */</div><div class="line">	/* Version 0x20200 */</div><div class="line">	uint32_t teamOffset;				/* offset of optional team identifier */</div><div class="line">	/* followed by dynamic content as located by offset fields above */</div><div class="line">&#125; CS_CodeDirectory;</div></pre></td></tr></table></figure></p>
<p>该结构体数据字段较多，此处只关注与签名相关的字段。<code>hashOffset</code>指明了Hash数据的文件相对偏移，注意是相对于当前结构体<code>CS_CodeDirectory</code>，<code>hashType</code>与<code>hashSize</code>指明了代码签名时使用的算法与每一项签名数据的长度，目前macOS使用的签名算法是SHA-1，长度为20字节。<br><code>nSpecialSlots</code>与<code>nCodeSlots</code>指定的代码签名数据条目的个数，前者是针对代码签名中所有的Blob，后者针对程序文件内容。<code>codesign</code>程序在对程序进行签名时，会对SuperBlob中每个子条目进行签名，即对Blob的内容调用SHA-1算法取Hash值，<code>nSpecialSlots</code>的值就是子条目Blob的个数；同时，<code>codesign</code>会以<code>pageSize</code>字段指定的页大小为单位（通常取值是0x1000），对程序数据进行签名，每一页签名后生成一条签名数据，<code>nCodeSlots</code>的值就是签名数据的页数，即程序数据大小除以<code>pageSize</code>字段后的值。</p>
<p>在<code>CS_CodeDirectory</code>之后，就是Requirements了，它是一个<code>CS_SuperBlob</code>结构体，指明了Requirement的个数与每一个的偏移。接下来就是每一个Requirement数据了，它是一个<code>CS_GenericBlob</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_GenericBlob &#123;</div><div class="line">	uint32_t magic;				/* magic number */</div><div class="line">	uint32_t length;			/* total length of blob */</div><div class="line">	char data[];</div><div class="line">&#125; CS_GenericBlob;</div></pre></td></tr></table></figure></p>
<p>可以看到，它的前两个字段与<code>CS_SuperBlob</code>是一样的，只是后面多出一个<code>data</code>字段，用来存放Blob的数据长度。<br>在Requirement数据下面，就是Entitlement了，它同样是<code>CS_GenericBlob</code>结构。拿本机Calculator计算器程序来说，它的Entitlement的数据内容是一个xml文件，提取出来内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class="line">&lt;plist version=&quot;1.0&quot;&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.network.client&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.print&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">&lt;/dict&gt;</div><div class="line">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>
<p>最后一个Blob通常是签名使用的证书了，Certificates签名证书也是<code>CS_GenericBlob</code>结构，提取它的证书数据后保存为cer文件，使用macOS的文件预览证书内容，效果如图所示：<br><img src="/2017/01/13/macho/calc_cer.png" alt="calc_cer"></p>
<p>下面再来看看，系统是如何实施代码签名验证的！内核加载解析Mach-O加载命令的函数是<code>parse_machfile()</code>，位于内核代码”/bsd/kern/mach_loader.c“文件中，部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	uint32_t		ncmds;</div><div class="line">	struct load_command	*lcp;</div><div class="line">	struct dylinker_command	*dlp = 0;</div><div class="line">	integer_t		dlarchbits = 0;</div><div class="line">	void *			control;</div><div class="line">	load_return_t		ret = LOAD_SUCCESS;</div><div class="line">	caddr_t			addr;</div><div class="line">	void *			kl_addr;</div><div class="line">	vm_size_t		size,kl_size;</div><div class="line">	size_t			offset;</div><div class="line">	size_t			oldoffset;	/* for overflow check */</div><div class="line">	int			pass;</div><div class="line">	proc_t			p = current_proc();		/* XXXX */</div><div class="line">	int			error;</div><div class="line">	int resid=0;</div><div class="line">	size_t			mach_header_sz = sizeof(struct mach_header);</div><div class="line">	boolean_t		abi64;</div><div class="line">	boolean_t		got_code_signatures = FALSE;</div><div class="line">	int64_t			slide = 0;</div><div class="line"></div><div class="line">	if (header-&gt;magic == MH_MAGIC_64 ||</div><div class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</div><div class="line">	    	mach_header_sz = sizeof(struct mach_header_64);</div><div class="line">	&#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">	case LC_CODE_SIGNATURE:</div><div class="line">		/* CODE SIGNING */</div><div class="line">		if (pass != 1)</div><div class="line">			break;</div><div class="line">		/* pager -&gt; uip -&gt;</div><div class="line">			load signatures &amp; store in uip</div><div class="line">			set VM object &quot;signed_pages&quot;</div><div class="line">		*/</div><div class="line">		ret = load_code_signature(</div><div class="line">			(struct linkedit_data_command *) lcp,</div><div class="line">			vp,</div><div class="line">			file_offset,</div><div class="line">			macho_size,</div><div class="line">			header-&gt;cputype,</div><div class="line">			result);</div><div class="line">		if (ret != LOAD_SUCCESS) &#123;</div><div class="line">			printf(&quot;proc %d: load code signature error %d &quot;</div><div class="line">					&quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">			/*</div><div class="line">				* Allow injections to be ignored on devices w/o enforcement enabled</div><div class="line">				*/</div><div class="line">			if (!cs_enforcement(NULL))</div><div class="line">				ret = LOAD_SUCCESS; /* ignore error */</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			got_code_signatures = TRUE;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (got_code_signatures) &#123;</div><div class="line">			unsigned tainted = CS_VALIDATE_TAINTED;</div><div class="line">			boolean_t valid = FALSE;</div><div class="line">			struct cs_blob *blobs;</div><div class="line">			vm_size_t off = 0;</div><div class="line"></div><div class="line"></div><div class="line">			if (cs_debug &gt; 10)</div><div class="line">				printf(&quot;validating initial pages of %s\n&quot;, vp-&gt;v_name);</div><div class="line">			blobs = ubc_get_cs_blobs(vp);</div><div class="line"></div><div class="line">			while (off &lt; size &amp;&amp; ret == LOAD_SUCCESS) &#123;</div><div class="line">					tainted = CS_VALIDATE_TAINTED;</div><div class="line"></div><div class="line">					valid = cs_validate_page(blobs,</div><div class="line">								NULL,</div><div class="line">								file_offset + off,</div><div class="line">								addr + off,</div><div class="line">								&amp;tainted);</div><div class="line">					if (!valid || (tainted &amp; CS_VALIDATE_TAINTED)) &#123;</div><div class="line">						if (cs_debug)</div><div class="line">							printf(&quot;CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n&quot;,</div><div class="line">							vp-&gt;v_name, p-&gt;p_pid, (long long)(file_offset + off), valid, tainted, result-&gt;csflags);</div><div class="line">						if (cs_enforcement(NULL) ||</div><div class="line">						(result-&gt;csflags &amp; (CS_HARD|CS_KILL|CS_ENFORCEMENT))) &#123;</div><div class="line">							ret = LOAD_FAILURE;</div><div class="line">						&#125;</div><div class="line">						result-&gt;csflags &amp;= ~CS_VALID;</div><div class="line">					&#125;</div><div class="line">					off += PAGE_SIZE;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>整个代码签名的验证过程大致分为<code>load_code_signature()</code>与<code>cs_validate_page()</code>两步，前者负责加载代码签名，后者负责验证数据页面。<code>load_code_signature()</code>在加载代码签名时，通过调用<code>ubc_cs_blob_get()</code>来获取特定CPU的<code>cs_blob</code>指针，<code>ubc_cs_blob_get()</code>第一次调用时，返回的<code>cs_blob</code>指针为空，会调用<code>ubc_cs_blob_add()</code>来加载与验证文件中的Blob信息，以后再调用<code>ubc_cs_blob_get()</code>，就会返回内存中的<code>cs_blob</code>指针，当然不是直接返回，系统会再次判断内存中的<code>cs_blob</code>指针是否损坏或遭到篡改，具体方法是调用<code>ubc_cs_generation_check()</code>做初步的检查，之后调用<code>ubc_cs_blob_revalidate()</code>对blob做重验证。load_code_signature()`函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">static load_return_t</div><div class="line">load_code_signature(</div><div class="line">	struct linkedit_data_command	*lcp,</div><div class="line">	struct vnode			*vp,</div><div class="line">	off_t				macho_offset,</div><div class="line">	off_t				macho_size,</div><div class="line">	cpu_type_t			cputype,</div><div class="line">	load_result_t			*result)</div><div class="line">&#123;</div><div class="line">	int		ret;</div><div class="line">	kern_return_t	kr;</div><div class="line">	vm_offset_t	addr;</div><div class="line">	int		resid;</div><div class="line">	struct cs_blob	*blob;</div><div class="line">	int		error;</div><div class="line">	vm_size_t	blob_size;</div><div class="line"></div><div class="line">	addr = 0;</div><div class="line">	blob = NULL;</div><div class="line"></div><div class="line">	if (lcp-&gt;cmdsize != sizeof (struct linkedit_data_command) ||</div><div class="line">	    lcp-&gt;dataoff + lcp-&gt;datasize &gt; macho_size) &#123;</div><div class="line">		ret = LOAD_BADMACHO;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line">	if (blob != NULL) &#123;</div><div class="line">		/* we already have a blob for this vnode and cputype */</div><div class="line">		if (blob-&gt;csb_cpu_type == cputype &amp;&amp;</div><div class="line">		    blob-&gt;csb_base_offset == macho_offset &amp;&amp;</div><div class="line">		    blob-&gt;csb_mem_size == lcp-&gt;datasize) &#123;</div><div class="line">			/* it matches the blob we want here, lets verify the version */</div><div class="line">			if(0 != ubc_cs_generation_check(vp)) &#123;</div><div class="line">				if (0 != ubc_cs_blob_revalidate(vp, blob, 0)) &#123;</div><div class="line">					ret = LOAD_FAILURE; /* set error same as from ubc_cs_blob_add */</div><div class="line">					goto out;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			ret = LOAD_SUCCESS;</div><div class="line">		&#125; else &#123;</div><div class="line">			/* the blob has changed for this vnode: fail ! */</div><div class="line">			ret = LOAD_BADMACHO;</div><div class="line">		&#125;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob_size = lcp-&gt;datasize;</div><div class="line">	kr = ubc_cs_blob_allocate(&amp;addr, &amp;blob_size);</div><div class="line">	if (kr != KERN_SUCCESS) &#123;</div><div class="line">		ret = LOAD_NOSPACE;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resid = 0;</div><div class="line">	error = vn_rdwr(UIO_READ,</div><div class="line">			vp,</div><div class="line">			(caddr_t) addr,</div><div class="line">			lcp-&gt;datasize,</div><div class="line">			macho_offset + lcp-&gt;dataoff,</div><div class="line">			UIO_SYSSPACE,</div><div class="line">			0,</div><div class="line">			kauth_cred_get(),</div><div class="line">			&amp;resid,</div><div class="line">			current_proc());</div><div class="line">	if (error || resid != 0) &#123;</div><div class="line">		ret = LOAD_IOERROR;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (ubc_cs_blob_add(vp,</div><div class="line">			    cputype,</div><div class="line">			    macho_offset,</div><div class="line">			    addr,</div><div class="line">			    lcp-&gt;datasize,</div><div class="line">			    0)) &#123;</div><div class="line">		ret = LOAD_FAILURE;</div><div class="line">		goto out;</div><div class="line">	&#125; else &#123;</div><div class="line">		/* ubc_cs_blob_add() has consumed &quot;addr&quot; */</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">#if CHECK_CS_VALIDATION_BITMAP</div><div class="line">	ubc_cs_validation_bitmap_allocate( vp );</div><div class="line">#endif</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line"></div><div class="line">	ret = LOAD_SUCCESS;</div><div class="line">out:</div><div class="line">	if (ret == LOAD_SUCCESS) &#123;</div><div class="line">		result-&gt;csflags |= blob-&gt;csb_flags;</div><div class="line">		result-&gt;platform_binary = blob-&gt;csb_platform_binary;</div><div class="line">		result-&gt;cs_end_offset = blob-&gt;csb_end_offset;</div><div class="line">	&#125;</div><div class="line">	if (addr != 0) &#123;</div><div class="line">		ubc_cs_blob_deallocate(addr, blob_size);</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，上面提到的<code>cs_blob</code>指针，其实就是代码签名数据中的<code>CS_SuperBlob</code>指针类型。<br><code>ubc_cs_blob_add()</code>的代码比较长，它主要做了三个工作：一是调用<code>cs_validate_csblob()</code>验证<code>cs_blob</code>指针的合法性，<code>cs_validate_csblob()</code>会对<code>CSMAGIC_EMBEDDED_SIGNATURE</code>与<code>CSMAGIC_CODEDIRECTORY</code>做相应的验证处理，包括调用<code>cs_validate_codedirectory()</code>验证<code>CS_CodeDirectory</code>结构体的合法性，以及调用<code>cs_validate_blob()</code>来验证<code>CS_SuperBlob</code>中每一个<code>CS_GenericBlob</code>是否合法有效；二是调用<code>mac_vnode_check_signature()</code>验证Blob块的代码签名，也就是比较Blob块的SHA1哈希值是否与计算的值相同；三是加载所有的代码签名Hash信息，填充<code>cs_blobs</code>字段，为下一步的内存页签名验证做准备。<br><code>ubc_cs_blob_revalidate()</code>做着与<code>ubc_cs_blob_add()</code>几乎相同的验证检查，但前者因为已经有了一些缓存信息，因此检查时会快一些。</p>
<p><code>load_code_signature()</code>完事以后，会调用<code>ubc_get_cs_blobs()</code>获取<code>cs_blobs</code>指针，最后调用<code>cs_validate_page()</code>以逐页的形式验证文件中每一页的数据的签名。<br>以上检查做完后，<code>LC_CODE_SIGNATURE</code>就处理完了，没有错误发生就表示代码签名验证通过了。</p>
<p>讲完了代码签名，再讲讲代码加密。Mach-O程序如果使用了代码加密技术，在加载命令列表中会有一个<code>LC_ENCRYPTION_INFO</code>加载命令。它存储了Mach-O的加密信息。关于此加载命令，对于搞过iOS程序逆向的读者应该不会感到陌生。iOS系统由于安全机制的原因，会对App Store中上架的应用默认开启数据加密。<br>被加密过的App文件，部分段的数据内容是经过加密的，而记录加密数据的关键就是<code>LC_ENCRYPTION_INFO</code>加载命令。分析人员要想对加密过的App进行逆向分析，必须先经过一次解密（俗称“砸壳”）操作。<br><code>LC_ENCRYPTION_INFO</code>使用<code>encryption_info_command</code>结构体表示。定义如下（<code>LC_ENCRYPTION_INFO_64</code>使用<code>encryption_info_command_64</code>表示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct encryption_info_command &#123;</div><div class="line">   uint32_t	cmd;		/* LC_ENCRYPTION_INFO */</div><div class="line">   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command) */</div><div class="line">   uint32_t	cryptoff;	/* file offset of encrypted range */</div><div class="line">   uint32_t	cryptsize;	/* file size of encrypted range */</div><div class="line">   uint32_t	cryptid;	/* which enryption system, 0 means not-encrypted yet */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cryptoff</code>与<code>cryptsize</code>字段分别指明了加密数据的文件偏移与大小。<code>cryptid</code>指定了使用的加密系统。<br>聪明的安全研究人员，根据Mach-O在内存中被加载完后即解密完成的特点，开发了针对iOS平台App的代码解密工具<code>dumpdecrypted</code>，<br>下载地址是：<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">https://github.com/stefanesser/dumpdecrypted</a> 。通过将内存中解密后的数据写回原位置，并将<code>cryptid</code>置0来达到解密App的目的。</p>
<p>再来看看系统是如何处理<code>LC_ENCRYPTION_INFO</code>的，它的解析函数也是<code>parse_machfile()</code>，代码片断如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line">			case LC_ENCRYPTION_INFO:</div><div class="line">			case LC_ENCRYPTION_INFO_64:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				ret = set_code_unprotect(</div><div class="line">					(struct encryption_info_command *) lcp,</div><div class="line">					addr, map, slide, vp,</div><div class="line">					header-&gt;cputype, header-&gt;cpusubtype);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: set_code_unprotect() error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					/*</div><div class="line">					 * Don&apos;t let the app run if it&apos;s</div><div class="line">					 * encrypted but we failed to set up the</div><div class="line">					 * decrypter. If the keys are missing it will</div><div class="line">					 * return LOAD_DECRYPTFAIL.</div><div class="line">					 */</div><div class="line">					 if (ret == LOAD_DECRYPTFAIL) &#123;</div><div class="line">						/* failed to load due to missing FP keys */</div><div class="line">						proc_lock(p);</div><div class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</div><div class="line">						proc_unlock(p);</div><div class="line">					&#125;</div><div class="line">					 psignal(p, SIGKILL);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#endif</div><div class="line">			default:</div><div class="line">				/* Other commands are ignored by the kernel */</div><div class="line">				ret = LOAD_SUCCESS;</div><div class="line">				break;</div><div class="line"></div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>当系统内核被配置为启用代码解密，即定义了<code>CONFIG_CODE_DECRYPTION</code>之后，<code>parse_machfile()</code>函数会解析<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令。<br>最终是调用了<code>set_code_unprotect()</code>函数来对代码进行解密。该函数通过<code>encryption_info_command</code>中的<code>cryptid</code>来确定使用的加密系统，然后对代码进行内存解密。它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line"></div><div class="line">static load_return_t</div><div class="line">set_code_unprotect(</div><div class="line">		   struct encryption_info_command *eip,</div><div class="line">		   caddr_t addr, 	</div><div class="line">		   vm_map_t map,</div><div class="line">		   int64_t slide,</div><div class="line">		   struct vnode	*vp,</div><div class="line">		   cpu_type_t cputype,</div><div class="line">		   cpu_subtype_t cpusubtype)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if (eip-&gt;cmdsize &lt; sizeof(*eip)) return LOAD_BADMACHO;</div><div class="line"></div><div class="line">	switch(eip-&gt;cryptid) &#123;</div><div class="line">		case 0:</div><div class="line">			/* not encrypted, just an empty load command */</div><div class="line">			return LOAD_SUCCESS;</div><div class="line">		case 1:</div><div class="line">			cryptname=&quot;com.apple.unfree&quot;;</div><div class="line">			break;</div><div class="line">		case 0x10:</div><div class="line">			/* some random cryptid that you could manually put into</div><div class="line">			 * your binary if you want NULL */</div><div class="line">			cryptname=&quot;com.apple.null&quot;;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			return LOAD_BADMACHO;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (map == VM_MAP_NULL) return (LOAD_SUCCESS);</div><div class="line">	if (NULL == text_crypter_create) return LOAD_FAILURE;</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	/* set up decrypter first */</div><div class="line">	crypt_file_data_t crypt_data = &#123;</div><div class="line">		.filename = vpath,</div><div class="line">		.cputype = cputype,</div><div class="line">		.cpusubtype = cpusubtype&#125;;</div><div class="line">	kr=text_crypter_create(&amp;crypt_info, cryptname, (void*)&amp;crypt_data);</div><div class="line">	FREE_ZONE(vpath, MAXPATHLEN, M_NAMEI);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	offset = mach_header_sz;</div><div class="line">	uint32_t ncmds = header-&gt;ncmds;</div><div class="line">	while (ncmds--) &#123;</div><div class="line">		/*</div><div class="line">		 *	Get a pointer to the command.</div><div class="line">		 */</div><div class="line">		struct load_command *lcp = (struct load_command *)(addr + offset);</div><div class="line">		offset += lcp-&gt;cmdsize;</div><div class="line"></div><div class="line">		switch(lcp-&gt;cmd) &#123;</div><div class="line">			case LC_SEGMENT_64:</div><div class="line">				seg64 = (struct segment_command_64 *)lcp;</div><div class="line">				if ((seg64-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg64-&gt;fileoff+seg64-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg64-&gt;vmaddr + eip-&gt;cryptoff - seg64-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">			case LC_SEGMENT:</div><div class="line">				seg32 = (struct segment_command *)lcp;</div><div class="line">				if ((seg32-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg32-&gt;fileoff+seg32-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg32-&gt;vmaddr + eip-&gt;cryptoff - seg32-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* if we get here, did not find anything */</div><div class="line">	return LOAD_BADMACHO;</div><div class="line"></div><div class="line">remap_now:</div><div class="line">	/* now remap using the decrypter */</div><div class="line">	kr = vm_map_apple_protected(map, map_offset, map_offset+map_size, &amp;crypt_info);</div><div class="line">	if(kr) &#123;</div><div class="line">		printf(&quot;set_code_unprotect(): mapping failed with %x\n&quot;, kr);</div><div class="line">		crypt_info.crypt_end(crypt_info.crypt_ops);</div><div class="line">		return LOAD_PROTECT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return LOAD_SUCCESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p><code>text_crypter_create()</code>是一个全局的<code>text_crypter_create_hook_t</code>类型的指针，在内核代码“osfmk/kern/page_decrypt.c”文件中通过<code>text_crypter_create_hook_set()</code>进行设置。<br><code>text_crypter_create()</code>在填充完解密所需的信息<code>crypt_info</code>后，会再次计算需要重新解密映射到内存的地址与大小，调用<code>vm_map_apple_protected()</code>进行解密操作。</p>
<p>由于内核的代码可以直接审阅，数据加密在macOS系统上显得意义不大，在目前最新的macOS 10.12系统上，苹果没有启用代码解密功能，<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令也就没那么常见了。</p>
<p>最后，可以使用<code>otool</code>命令行工具来查看Mach-O文件的加载命令信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> otool -l /usr/bin/python</div><div class="line">/usr/bin/python:</div><div class="line">Load command 0</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 72</div><div class="line">  segname __PAGEZERO</div><div class="line">   vmaddr 0x0000000000000000</div><div class="line">   vmsize 0x0000000100000000</div><div class="line">  fileoff 0</div><div class="line"> filesize 0</div><div class="line">  maxprot 0x00000000</div><div class="line"> initprot 0x00000000</div><div class="line">   nsects 0</div><div class="line">    flags 0x0</div><div class="line">Load command 1</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">    ......</div><div class="line">Load command 15</div><div class="line">      cmd LC_DATA_IN_CODE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 17776</div><div class="line"> datasize 0</div><div class="line">Load command 16</div><div class="line">      cmd LC_CODE_SIGNATURE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 20528</div><div class="line"> datasize 9344</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>MachOView</code>查看，效果如图所示：<br><img src="/2017/01/13/macho/load_command.png" alt="load_command"></p>
<h2 id="0x6-LC-SEGMENT"><a href="#0x6-LC-SEGMENT" class="headerlink" title="0x6 LC_SEGMENT"></a>0x6 LC_SEGMENT</h2><p>段加载命令<code>LC_SEGMENT</code>，描述了32位Mach-O文件的段的信息，使用<code>segment_command</code>结构体来表示，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command &#123; /* for 32-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint32_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint32_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint32_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint32_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>segname</code>字段是一个16字节大小的空间，用来存储段的名称。<br><code>vmaddr</code>字段指明了段要加载的虚拟内存地址。<br><code>vmsize</code>字段指明了段所占的虚拟内存的大小。<br><code>fileoff</code>字段指明了段数据所在文件中偏移地址。<br><code>filesize</code>字段指明了段数据实际的大小。<br><code>maxprot</code>字段指明了页面所需要的最高内存保护。<br><code>initprot</code>字段指明了页面初始的内存保护。<br><code>nsects</code>字段指明了段所包含的节区（section）。<br><code>flags</code>字段指明了段的标志信息。</p>
<p>与<code>LC_SEGMENT</code>对应的是<code>LC_SEGMENT_64</code>，它使用<code>segment_command_64</code>结构体表示，描述了64位Mach-O文件的段的基本信息，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section_64 structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint64_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint64_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint64_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的字段含义与32位基本一致。主要讨论一下它最后4个字段。</p>
<p>一个编译后可能执行的程序分成了多个段，不同的类型的数据放入了不同的段中。如程序的代码被称作代码段，<br>放入一个名为<code>__TEXT</code>的段中，代码段的<code>maxprot</code>字段在编译时被设置成<code>VM_PROT_READ</code>（可读）、<code>VM_PROT_WRITE</code>（可写）、<code>VM_PROT_EXECUTE</code>（可执行），<code>initprot</code>字段被设置成<br><code>VM_PROT_READ</code>（可读）与<code>VM_PROT_EXECUTE</code>（可执行），这样做是合理的，一个普通的应用程序，它的代码段部分通常是不可写的，特殊需求的程序，如果要求代码段可写，必须在编译时设置它的<br><code>initprot</code>字段为<code>VM_PROT_WRITE</code>（可写）。</p>
<p><code>nsects</code>字段指定了段加载命令包含几个节区（section），一个段可以包含0个或多个节区。如<code>__PAGEZERO</code>段就不包含任何节区，该段被称为空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。<br>当一个段包含多个节区时，节区信息会以数组形式紧随着存储在段加载命令后面。节区使用结构体<code>section</code>表示（64位使用<code>section_64</code>表示），定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">	char		sectname[16];	/* name of this section */</div><div class="line">	char		segname[16];	/* segment this section goes in */</div><div class="line">	uint32_t	addr;		/* memory address of this section */</div><div class="line">	uint32_t	size;		/* size in bytes of this section */</div><div class="line">	uint32_t	offset;		/* file offset of this section */</div><div class="line">	uint32_t	align;		/* section alignment (power of 2) */</div><div class="line">	uint32_t	reloff;		/* file offset of relocation entries */</div><div class="line">	uint32_t	nreloc;		/* number of relocation entries */</div><div class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</div><div class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</div><div class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>sectname</code>字段表示节区的名称，<code>segname</code>字段表示节区所在的段名，<code>addr</code>与<code>size</code>指明了节区所在的内存地址与大小，<code>offset</code>指明了区取所在的文件偏移，<br><code>align</code>表示节区的内存对齐边界，<code>reloff</code>指明了重定位信息的文件偏移，<code>nreloc</code>表示重定位条目的数目，<code>flags</code>则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段<code>flags</code>存储了段的一些标志属性，它的取值有如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define	SG_HIGHVM	0x1</div><div class="line">#define	SG_FVMLIB	0x2</div><div class="line">#define	SG_NORELOC	0x4</div><div class="line">#define SG_PROTECTED_VERSION_1	0x8</div></pre></td></tr></table></figure></p>
<p>值得关注的是<code>SG_PROTECTED_VERSION_1</code>，当段被设置了该标志位，表示段是经过加密的！在macOS版本10.6以前，系统使用AES算法进行段的加密与解密，10.6的时候，则使用的Blowfish加密算法，著名的iOS逆向工具<code>class-dump</code>（地址：<a href="https://github.com/nygard/class-dump）" target="_blank" rel="external">https://github.com/nygard/class-dump）</a> 提供了一个静态数据段解密工具<code>deprotect</code>，有兴趣的读者可以参看它的代码来了解段解密的部分。</p>
<p>最后，使用<code>MachOView</code>工具查看系统python程序的<code>__TEXT</code>段的信息如图所示：<br><img src="/2017/01/13/macho/python_seg.png" alt="python_seg"></p>

      
    </div>
  	
		<! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   您的支持是作者最大的动力
        </span>
        <br>
      </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<! -- <img src="/images/alipay.png" alt="支付宝打赏">  -->
		<!-- 微信打赏图案 -->
		<img src="/images/wxpay.png" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>

  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/13/macho/" data-id="ciy0vgmpk0003t5vjt420gwcl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/01/14/dylib/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          dylib动态库加载过程分析
        
      </div>
    </a>
  
  
    <a href="/2017/01/12/install-software/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">macOS平台软件的下载与安装</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-macho" data-title="Mach-O文件格式" data-url="https://feicong.github.io/2017/01/13/macho/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'feicong'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS软件安全/" style="font-size: 10px;">macOS软件安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/17/dmg/">DMG文件管理</a>
          </li>
        
          <li>
            <a href="/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a>
          </li>
        
          <li>
            <a href="/2017/01/15/staticlib/">静态库的管理与文件格式分析</a>
          </li>
        
          <li>
            <a href="/2017/01/14/dylib/">dylib动态库加载过程分析</a>
          </li>
        
          <li>
            <a href="/2017/01/13/macho/">Mach-O文件格式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
      <div class="widget">
      	<ul>
        	
          	<li class='link'><a href='https://ydc1992.github.io'>Ken&#39;s Blog</a></li>
        	
      	</ul>
      </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>