<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fEICOnG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="fEICOnG's Blog">
<meta property="og:url" content="https://feicong.github.io/index.html">
<meta property="og:site_name" content="fEICOnG's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fEICOnG's Blog">
  
    <link rel="alternate" href="/atom.xml" title="fEICOnG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fEICOnG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RE makes life easier</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://feicong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-macos-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/macos-software/" class="article-date">
  <time datetime="2017-01-12T02:20:31.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/macos-software/">［置顶］macOS软件安全系列-软件内幕篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>macOS平台上的软件安全话题讨论在国内仍是软件安全领域的沼泽地带，除了在部分安全论坛上见过几篇破解分析的文章外，鲜有人问津。</p>
<p>如今，macOS平台的安全问题已经被越来越多的人关注，本系列的文章为macOS软件安全系列的一个篇章－软件内幕篇，探讨macOS系统上常见的文件格式与它们的管理方式，让各位关注软件安全领域的朋友，对macOS系统上的软件安全有直观的认识。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本系列文章为非虫（微信：feicongcn）原创，任何个人与组织未经允许，不得转载与摘抄，否则，作者保留一切追究法律责任的权利。</p>
<h3 id="macOS平台软件的下载与安装"><a href="#macOS平台软件的下载与安装" class="headerlink" title="macOS平台软件的下载与安装"></a><a href="https://feicong.github.io/2017/01/12/install-software/">macOS平台软件的下载与安装</a></h3><h3 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a><a href="https://feicong.github.io/2017/01/13/macho/">Mach-O文件格式</a></h3><h3 id="dylib动态库加载过程分析"><a href="#dylib动态库加载过程分析" class="headerlink" title="dylib动态库加载过程分析"></a><a href="https://feicong.github.io/2017/01/14/dylib/">dylib动态库加载过程分析</a></h3><h3 id="静态库的管理与文件格式分析"><a href="#静态库的管理与文件格式分析" class="headerlink" title="静态库的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/15/staticlib/">静态库的管理与文件格式分析</a></h3><h3 id="PKG安装包的管理与文件格式分析"><a href="#PKG安装包的管理与文件格式分析" class="headerlink" title="PKG安装包的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a></h3><h3 id="DMG文件管理"><a href="#DMG文件管理" class="headerlink" title="DMG文件管理"></a><a href="https://feicong.github.io/2017/01/17/dmg/">DMG文件管理</a></h3>
      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/macos-software/" data-id="ciz2fqeg4000axuvj7lh5o5c7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-legend" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/12/legend/" class="article-date">
  <time datetime="2017-02-12T05:37:22.000Z" itemprop="datePublished">2017-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/12/legend/">Android免Root环境下Hook框架Legend原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x1-应用场景"><a href="#0x1-应用场景" class="headerlink" title="0x1 应用场景"></a>0x1 应用场景</h3><p>现如今，免Root环境下的逆向分析已经成为一种潮流！</p>
<p>在2015年之前的iOS软件逆向工程领域，要想对iOS平台上的软件进行逆向工程分析，越狱iOS设备与安装Cydia是必须的！几乎绝大多数的逆向相关的动态调试工具、Hook注入框架都依赖于获取IOS设备的最高访问权限，就技术本身上而言，对当前程序进行Hook与动态调试，只需要拥有与当前程序相同的权限即可，理论上无需对设备进行Root越狱，实际上，在2015年就出现了在非越狱设备上进行插件开发的实用案例，2016年的iOS软件逆向工程界，更是一发不可收拾，各种名越狱环境下的逆向工具与逆向技巧被安全人员所发掘，在没有越狱的iOS设备上进行软件的动态调试与逆向工程已经是主流的趋势胃。这样的情况下，最直接的影响是安全研究人员不再对iOS设备越狱有着强烈的追求了，越狱需求的下降可能会直接影响到iOS设备越狱工具的发布与技术的更新迭代。</p>
<p>同样的，在Android设备的免Root环境下，进行软件动态调试与逆向工程分析的需求更加强烈。免Root环境下动态调试与逆向工程就技术本质而言是可行的，安全研究人员的智慧更是有力的证明了这一点，LBE发布免Root环境下APK双开工具平行空间就是最好的例子，它是打破逆向工程技术的原始格局的第一个大锤！随后的，各种APK多开框架、免Root环境下的Hook、免Root环境下的动态调试等技术都被研究人员公开，这是Android软件逆向工程界的福音，逆向工程人员在以后的逆向分析过程中，可能再也不需要为自己的手机能否越狱而感到苦恼，手上在吃灰淘汰的Android小米机可能就是你的逆向必备工具之一。</p>
<p>好了，说了这么多，无非是告诉大家，开发技术在更新迭代，软件的逆向工程技术也在不停的更新，各位研究软件安全的朋友们，你们跟上了时代的脚步吗？！</p>
<h3 id="0x2-Legend框架简介"><a href="#0x2-Legend框架简介" class="headerlink" title="0x2 Legend框架简介"></a>0x2 Legend框架简介</h3><p><code>Legend</code>是Lody开源的一个Android免Root环境下的一个APK Hook框架，代码放在github上：<a href="https://github.com/asLody/legend。" target="_blank" rel="external">https://github.com/asLody/legend。</a> 该框架代码设计简洁，通用性高，适合逆向工程时一些Hook场景。</p>
<p>先来看看如何使用它。框架提供了两种使用方法：基于<code>Annotation</code>注解与代码直接调用。基于<code>Annotation</code>注解的Hook技术不是第一次被发现了，在Java开发的世界里，这种技术被广泛使用，大名鼎鼎的基于AOP开发的<code>Aspectj</code>就大量使用这种技术。使用<code>Annotation</code>方式编写的Java代码有着很强的灵活与扩展性。<code>Legend</code>中<code>Annotation</code>方式的Hook这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Hook(&quot;android.app.Activity::startActivity@android.content.Intent&quot;)</div><div class="line">public static void Activity_startActivity(Activity thiz, Intent intent) &#123;</div><div class="line">  if (!ALLOW_LAUNCH_ACTIVITY) &#123;</div><div class="line">    Toast.makeText(thiz, &quot;I am sorry to turn your Activity down :)&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">  &#125; else &#123;</div><div class="line">    HookManager.getDefault().callSuper(thiz, intent);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@Hook(&quot;xxx&quot;)</code>部分指明需要Hook的类与方法以及方法的签名，此处的<code>Activity_startActivity()</code>是自己实现的替换<code>android.app.Activity::startActivity()</code>的方法，<code>HookManager.getDefault().callSuper(thiz, intent);</code>调用是调用原方法。</p>
<p>这种方式Hook的方法，需要执行一次Hook应用操作来激活所有注解Hook，方法是执行下面的方法，传入的YourClass.class是包含了注解的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HookManager.getDefault().applyHooks(YourClass.class);</div></pre></td></tr></table></figure></p>
<p>另一种代码方式进行Hook使用起来更简单，Hook操作只需要一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HookManager.getDefault().hookMethod(originMethod, hookMethod);</div></pre></td></tr></table></figure></p>
<p>这是<code>Legend</code>提供的demo展示的一个完整实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.legend.demo;</div><div class="line"></div><div class="line">import android.app.Activity;</div><div class="line">import android.app.Application;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line">import android.telephony.TelephonyManager;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">import com.lody.legend.Hook;</div><div class="line">import com.lody.legend.HookManager;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author Lody</div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line">public class App extends Application &#123;</div><div class="line"></div><div class="line">    public static boolean ENABLE_TOAST = true;</div><div class="line">    public static boolean ALLOW_LAUNCH_ACTIVITY = true;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        super.attachBaseContext(base);</div><div class="line">        HookManager.getDefault().applyHooks(App.class);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Hook(&quot;android.app.Application::onCreate&quot;)</div><div class="line">    public static void Application_onCreate(Application app) &#123;</div><div class="line">        Toast.makeText(app, &quot;Application =&gt; onCreate()&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        HookManager.getDefault().callSuper(app);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Hook(&quot;android.telephony.TelephonyManager::getSimSerialNumber&quot;)</div><div class="line">    public static String TelephonyManager_getSimSerialNumber(TelephonyManager thiz) &#123;</div><div class="line">         return &quot;110&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Hook(&quot;android.widget.Toast::show&quot;)</div><div class="line">    public static void Toast_show(Toast toast) &#123;</div><div class="line">        if (ENABLE_TOAST) &#123;</div><div class="line">            HookManager.getDefault().callSuper(toast);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Hook(&quot;android.app.Activity::startActivity@android.content.Intent&quot;)</div><div class="line">    public static void Activity_startActivity(Activity activity, Intent intent) &#123;</div><div class="line">        if (!ALLOW_LAUNCH_ACTIVITY) &#123;</div><div class="line">            Toast.makeText(activity, &quot;I am sorry to turn your Activity down :)&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;else &#123;</div><div class="line">            HookManager.getDefault().callSuper(activity, intent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="0x3-原理分析"><a href="#0x3-原理分析" class="headerlink" title="0x3 原理分析"></a>0x3 原理分析</h3><p>先来看看Hook注解的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Legend/legendCore/src/main/java/com/lody/legend/Hook.java</div><div class="line"></div><div class="line">package com.lody.legend;</div><div class="line"></div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author Lody</div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface Hook &#123;</div><div class="line">    String value() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>｀@Target(ElementType.METHOD)｀指明Hook注解用于修饰类中的<code>Method</code>，与之类似的还有<code>@Target(ElementType.FIELD)</code>用来修饰类中的<code>Field</code>。如果想让注解同时修饰类的<code>Field</code>与<code>Method</code>，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</div><div class="line">public @interface Hook&#123;&#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code>指明Hook注解以何种形式进行保留。<code>RetentionPolicy</code>是一个enum类型，声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum RetentionPolicy &#123;   </div><div class="line">   SOURCE,   </div><div class="line">   CLASS,   </div><div class="line">   RUNTIME   </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>｀SOURCE｀表明该注解类型的信息只保留在程序源码里，源码经过编译之后，注解的数据就会消失;<code>CLASS</code>表明注解类型的信息除了保留在程序源码里，同时也保留在编译好的class文件里面，但在执行的时候，并不会把这些信息加载到内存中去；<code>RUNTIME</code>是最大范围的保留，表示同时在源码与编译好的class文件中保留信息，并且在执行的时候会把这些信息加载到内存中去。</p>
<p>定义好了Hook注解，看它是如何使用的，这就是<code>HookManager.getDefault().applyHooks()</code>方法要做的工作，它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">// Legend/legendCore/src/main/java/com/lody/legend/HookManager.java</div><div class="line">public void applyHooks(Class&lt;?&gt; holdClass) &#123;</div><div class="line">    for (Method hookMethod : holdClass.getDeclaredMethods()) &#123;</div><div class="line">        Hook hook = hookMethod.getAnnotation(Hook.class);</div><div class="line">        if (hook != null) &#123;</div><div class="line">            String statement = hook.value();</div><div class="line">            String[] splitValues = statement.split(&quot;::&quot;);</div><div class="line">            if (splitValues.length == 2) &#123;</div><div class="line">                String className = splitValues[0];</div><div class="line">                String[] methodNameWithSignature = splitValues[1].split(&quot;@&quot;);</div><div class="line">                if (methodNameWithSignature.length &lt;= 2) &#123;</div><div class="line">                    String methodName = methodNameWithSignature[0];</div><div class="line">                    String signature = methodNameWithSignature.length == 2 ? methodNameWithSignature[1] : &quot;&quot;;</div><div class="line">                    String[] paramList = signature.split(&quot;#&quot;);</div><div class="line">                    if (paramList[0].equals(&quot;&quot;)) &#123;</div><div class="line">                        paramList = new String[0];</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        Class&lt;?&gt; clazz = Class.forName(className);</div><div class="line">                        boolean isResolve = false;</div><div class="line">                        for (Method method : clazz.getDeclaredMethods()) &#123;</div><div class="line">                            if (method.getName().equals(methodName)) &#123;</div><div class="line">                                Class&lt;?&gt;[] types = method.getParameterTypes();</div><div class="line">                                if (paramList.length == types.length) &#123;</div><div class="line">                                    boolean isMatch = true;</div><div class="line">                                    for (int N = 0; N &lt; types.length; N++) &#123;</div><div class="line">                                        if (!types[N].getName().equals(paramList[N])) &#123;</div><div class="line">                                            isMatch = false;</div><div class="line">                                            break;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                    if (isMatch) &#123;</div><div class="line">                                        hookMethod(method, hookMethod);</div><div class="line">                                        isResolve = true;</div><div class="line">                                        Logger.d(&quot;[+++] %s have hooked.&quot;, method.getName());</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            if (isResolve) &#123;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (!isResolve) &#123;</div><div class="line">                            Logger.e(&quot;[---] Cannot resolve Method : %s.&quot;, Arrays.toString(methodNameWithSignature));</div><div class="line">                        &#125;</div><div class="line">                    &#125; catch (Throwable e) &#123;</div><div class="line">                        Logger.e(&quot;[---] Error to Load Hook Method From : %s.&quot; , hookMethod.getName());</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;else &#123;</div><div class="line">                    Logger.e(&quot;[---] Can&apos;t split method and signature : %s.&quot;, Arrays.toString(methodNameWithSignature));</div><div class="line">                &#125;</div><div class="line">            &#125;else &#123;</div><div class="line">                Logger.e(&quot;[---] Can&apos;t understand your statement : [%s].&quot;, statement);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法遍历类的所有方法，查找匹配注解信息中指定的方法，方法是：对于需要Hook的<code>Class</code>类<code>holdClass</code>，调用它的<code>getDeclaredMethods()</code>获取所有声明的方法，依次调用每个类的方法的<code>getAnnotation()</code>获取注解信息，取到的注解信息保存在<code>String</code>类型的<code>statement</code>变量中，类与完整的方法签名以“::”进行分隔，方法签名中的方法名与参数签名使用“@”进行分隔，参数签名中每个参数之间使用“#”进行分隔，取完一个方法所有的信息后，与类中的方法进行比较，如果完全匹配说明找到了需要Hook的方法，这个时候，调用<code>hookMethod()</code>方法进行Hook操作，注意这里的<code>hookMethod()</code>方法，即<code>Legend</code>框架支持的第二种Hook方式。</p>
<p><code>hookMethod()</code>调用<code>Runtime.isArt()</code>判断当前代码执行在<code>Art</code>还是<code>Dalvik</code>模式，如果是<code>Art</code>模式，执行<code>hookMethodArt()</code>来完成Hook操作，如果是<code>Dalvik</code>模式，执行<code>hookMethodDalvik()</code>完成Hook。</p>
<p><code>Runtime.isArt()</code>的代码只有一行，即判断虚拟机版本字符串是否以字符2开头，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static boolean isArt() &#123;</div><div class="line">    return getVmVersion().startsWith(&quot;2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static String getVmVersion() &#123;</div><div class="line">    return System.getProperty(&quot;java.vm.version&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行完Hook后会返回一个<code>backupMethod</code>，这是一个原始方法的备份，最后将<code>backupMethod</code>放入以<code>methodName</code>命令的<code>backupList</code>，在<code>methodNameToBackupMethodsMap</code>备份就完事了。</p>
<p>接下来看看<code>hookMethodArt()</code>都干了啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">private static Method hookMethodArt(Method origin, Method hook) &#123;</div><div class="line">        ArtMethod artOrigin = ArtMethod.of(origin);</div><div class="line">        ArtMethod artHook = ArtMethod.of(hook);</div><div class="line">        Method backup = artOrigin.backup().getMethod();</div><div class="line">        backup.setAccessible(true);</div><div class="line">        long originPointFromQuickCompiledCode = artOrigin.getEntryPointFromQuickCompiledCode();</div><div class="line">        long originEntryPointFromJni = artOrigin.getEntryPointFromJni();</div><div class="line">        long originEntryPointFromInterpreter = artOrigin.getEntryPointFromInterpreter();</div><div class="line">        long originDeclaringClass = artOrigin.getDeclaringClass();</div><div class="line">        long originAccessFlags = artOrigin.getAccessFlags();</div><div class="line">        long originDexCacheResolvedMethods = artOrigin.getDexCacheResolvedMethods();</div><div class="line">        long originDexCacheResolvedTypes = artOrigin.getDexCacheResolvedTypes();</div><div class="line">        long originDexCodeItemOffset = artOrigin.getDexCodeItemOffset();</div><div class="line">        long originDexMethodIndex = artOrigin.getDexMethodIndex();</div><div class="line"></div><div class="line">        long hookPointFromQuickCompiledCode = artHook.getEntryPointFromQuickCompiledCode();</div><div class="line">        long hookEntryPointFromJni = artHook.getEntryPointFromJni();</div><div class="line">        long hookEntryPointFromInterpreter = artHook.getEntryPointFromInterpreter();</div><div class="line">        long hookDeclaringClass = artHook.getDeclaringClass();</div><div class="line">        long hookAccessFlags = artHook.getAccessFlags();</div><div class="line">        long hookDexCacheResolvedMethods = artHook.getDexCacheResolvedMethods();</div><div class="line">        long hookDexCacheResolvedTypes = artHook.getDexCacheResolvedTypes();</div><div class="line">        long hookDexCodeItemOffset = artHook.getDexCodeItemOffset();</div><div class="line">        long hookDexMethodIndex = artHook.getDexMethodIndex();</div><div class="line"></div><div class="line">        ByteBuffer hookInfo = ByteBuffer.allocate(ART_HOOK_INFO_SIZE);</div><div class="line">        hookInfo.putLong(originPointFromQuickCompiledCode);</div><div class="line">        hookInfo.putLong(originEntryPointFromJni);</div><div class="line">        hookInfo.putLong(originEntryPointFromInterpreter);</div><div class="line">        hookInfo.putLong(originDeclaringClass);</div><div class="line">        hookInfo.putLong(originAccessFlags);</div><div class="line">        hookInfo.putLong(originDexCacheResolvedMethods);</div><div class="line">        hookInfo.putLong(originDexCacheResolvedTypes);</div><div class="line">        hookInfo.putLong(originDexCodeItemOffset);</div><div class="line">        hookInfo.putLong(originDexMethodIndex);</div><div class="line"></div><div class="line">        hookInfo.putLong(hookPointFromQuickCompiledCode);</div><div class="line">        hookInfo.putLong(hookEntryPointFromJni);</div><div class="line">        hookInfo.putLong(hookEntryPointFromInterpreter);</div><div class="line">        hookInfo.putLong(hookDeclaringClass);</div><div class="line">        hookInfo.putLong(hookAccessFlags);</div><div class="line">        hookInfo.putLong(hookDexCacheResolvedMethods);</div><div class="line">        hookInfo.putLong(hookDexCacheResolvedTypes);</div><div class="line">        hookInfo.putLong(hookDexCodeItemOffset);</div><div class="line">        hookInfo.putLong(hookDexMethodIndex);</div><div class="line"></div><div class="line">        artOrigin.setEntryPointFromQuickCompiledCode(hookPointFromQuickCompiledCode);</div><div class="line">        artOrigin.setEntryPointFromInterpreter(hookEntryPointFromInterpreter);</div><div class="line">        artOrigin.setDeclaringClass(hookDeclaringClass);</div><div class="line">        artOrigin.setDexCacheResolvedMethods(hookDexCacheResolvedMethods);</div><div class="line">        artOrigin.setDexCacheResolvedTypes(hookDexCacheResolvedTypes);</div><div class="line">        artOrigin.setDexCodeItemOffset((int) hookDexCodeItemOffset);</div><div class="line">        artOrigin.setDexMethodIndex((int) hookDexMethodIndex);</div><div class="line"></div><div class="line">        int accessFlags = origin.getModifiers();</div><div class="line">        if (Modifier.isNative(accessFlags)) &#123;</div><div class="line">            accessFlags &amp;= ~ Modifier.NATIVE;</div><div class="line">            artOrigin.setAccessFlags(accessFlags);</div><div class="line">        &#125;</div><div class="line">        long memoryAddress = Memory.alloc(ART_HOOK_INFO_SIZE);</div><div class="line">        Memory.write(memoryAddress,hookInfo.array());</div><div class="line">        artOrigin.setEntryPointFromJni(memoryAddress);</div><div class="line"></div><div class="line">        return backup;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>原方法与替换的方法分别为<code>artOrigin</code>与<code>artHook</code>，执行<code>artOrigin</code>的<code>backup()</code>完成方法的备份操作，<code>backup()</code>内部通过反射获取<code>AbstractMethod</code>类的<code>artMethod</code>字段，然后使用当前类的<code>method</code>进行填充，实际的操作就是复制一份当前类的<code>method</code>，此处不展开它的代码。</p>
<p>接下来的代码是获取<code>artOrigin</code>与<code>artHook</code>的重要字段，然后构造<code>ByteBuffer</code>类型的<code>hookInfo</code>，最后调用以下三行代码来完成Hook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">long memoryAddress = Memory.alloc(ART_HOOK_INFO_SIZE);</div><div class="line">Memory.write(memoryAddress,hookInfo.array());</div><div class="line">artOrigin.setEntryPointFromJni(memoryAddress);</div></pre></td></tr></table></figure></p>
<p><code>ArtMethod</code>在底层的内存结构定义仅次于Android源码的“art/runtime/art_method.h”文件，不同系统版本的Android这个结构体都可能会发现变化，为了保持兼容性，<code>Legend</code>在Java层手动定义保存了它们的字段偏移信息，与“Legend/legendCore/src/main/java/com/lody/legend/art/ArtMethod.java”文件保存在同一目录，在调用<code>ArtMethod::of()</code>方法构造<code>ArtMethod</code>时，会根据不同的系统版本来构造不同的对象。</p>
<p><code>Memory.write()</code>方法底层调用的<code>LegendNative.memput()</code>，它是一个native方法，对应的实现是<code>android_memput()</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Legend/Native/jni/legend_native.cpp</div><div class="line">void android_memput(JNIEnv * env, jclass clazz, jlong dest, jbyteArray src) &#123;</div><div class="line">    jbyte *srcPnt = env-&gt;GetByteArrayElements(src, 0);</div><div class="line">    jsize length = env-&gt;GetArrayLength(src);</div><div class="line">    unsigned char * destPnt = (unsigned char *)dest;</div><div class="line">    for(int i = 0; i &lt; length; ++i) &#123;</div><div class="line">        destPnt[i] = srcPnt[i];</div><div class="line">    &#125;</div><div class="line">    env-&gt;ReleaseByteArrayElements(src, srcPnt, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，馐的内存写操作是直接使用底层指定长度的字节流覆盖的，简单与暴力，而能够这样操作的原因，是当前操作的内存是自己的内存，想怎么干就怎么干！</p>
<p><code>setEntryPointFromJni()</code>直接将原方法起始地址的指针内容，通过构造的<code>memoryAddress</code>覆盖写入！如此这般，<code>Art</code>模式下的Hook就完成了，当然，这其中很多小细节没有讲到，读者可以看行阅读它的代码。</p>
<p>接下来看看<code>Dalvik</code>下的Hook方法<code>hookMethodDalvik()</code>都干了啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// Legend/legendCore/src/main/java/com/lody/legend/HookManager.java</div><div class="line">private static Method hookMethodDalvik(Method origin, Method hook) &#123;</div><div class="line">    DalvikMethodStruct dvmOriginMethod = DalvikMethodStruct.of(origin);</div><div class="line">    DalvikMethodStruct dvmHookMethod = DalvikMethodStruct.of(hook);</div><div class="line"></div><div class="line">    byte[] originClassData = dvmOriginMethod.clazz.read();</div><div class="line">    byte[] originInsnsData = dvmOriginMethod.insns.read();</div><div class="line">    byte[] originInsSizeData = dvmOriginMethod.insSize.read();</div><div class="line">    byte[] originRegisterSizeData = dvmOriginMethod.registersSize.read();</div><div class="line">    byte[] originAccessFlags = dvmOriginMethod.accessFlags.read();</div><div class="line">    byte[] originNativeFunc = dvmOriginMethod.nativeFunc.read();</div><div class="line"></div><div class="line">    byte[] hookClassData = dvmHookMethod.clazz.read();</div><div class="line">    byte[] hookInsnsData = dvmHookMethod.insns.read();</div><div class="line">    byte[] hookInsSizeData = dvmHookMethod.insSize.read();</div><div class="line">    byte[] hookRegisterSizeData = dvmHookMethod.registersSize.read();</div><div class="line">    byte[] hookAccessFlags = dvmHookMethod.accessFlags.read();</div><div class="line">    byte[] hookNativeFunc = dvmHookMethod.nativeFunc.read();</div><div class="line"></div><div class="line">    dvmOriginMethod.clazz.write(hookClassData);</div><div class="line">    dvmOriginMethod.insns.write(hookInsnsData);</div><div class="line">    dvmOriginMethod.insSize.write(hookInsSizeData);</div><div class="line">    dvmOriginMethod.registersSize.write(hookRegisterSizeData);</div><div class="line">    dvmOriginMethod.accessFlags.write(hookAccessFlags);</div><div class="line"></div><div class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(DVM_HOOK_INFO_SIZE);</div><div class="line">    byteBuffer.put(originClassData);</div><div class="line">    byteBuffer.put(originInsnsData);</div><div class="line">    byteBuffer.put(originInsSizeData);</div><div class="line">    byteBuffer.put(originRegisterSizeData);</div><div class="line">    byteBuffer.put(originAccessFlags);</div><div class="line">    byteBuffer.put(originNativeFunc);</div><div class="line">    //May leak</div><div class="line">    long memoryAddress = Memory.alloc(DVM_HOOK_INFO_SIZE);</div><div class="line">    Memory.write(memoryAddress, byteBuffer.array());</div><div class="line">    dvmOriginMethod.nativeFunc.write(memoryAddress);</div><div class="line">    return origin;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析完<code>Art</code>模式，<code>Dalvik</code>下的就不难看懂的，<code>DalvikMethodStruct.of()</code>会返回<code>DalvikMethodStruct</code>类型结构体，它是<code>Dalvik</code>虚拟机内部<code>DalvikMethod</code>结构体的内线性布局表示。</p>
<p><code>dvmOriginMethod</code>与<code>dvmHookMethod</code>分别代表原方法与Hook替换的方法，同样的，使用底层内存的写操作，对所有需要替换的字段进行替换。</p>
<p>最后就是Hook后的方法调用原方法了，它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// Legend/legendCore/src/main/java/com/lody/legend/HookManager.java</div><div class="line">public &lt;T&gt; T callSuper(Object who, Object... args) &#123;</div><div class="line">    StackTraceElement[] traceElements = Thread.currentThread().getStackTrace();</div><div class="line">    StackTraceElement currentInvoking = traceElements[3];</div><div class="line">    String invokingClassName = currentInvoking.getClassName();</div><div class="line">    String invokingMethodName = currentInvoking.getMethodName();</div><div class="line">    Map&lt;String,List&lt;Method&gt;&gt; methodNameToBackupMethodsMap = classToBackupMethodsMapping.get(invokingClassName);</div><div class="line">    if (methodNameToBackupMethodsMap != null) &#123;</div><div class="line">        List&lt;Method&gt; methodList = methodNameToBackupMethodsMap.get(invokingMethodName);</div><div class="line">        if (methodList != null) &#123;</div><div class="line">            Method method = matchSimilarMethod(methodList, args);</div><div class="line">            if (method != null) &#123;</div><div class="line">                try &#123;</div><div class="line">                   if (Runtime.isArt()) &#123;</div><div class="line">                       return callSuperArt(method, who, args);</div><div class="line">                   &#125;else &#123;</div><div class="line">                       return callSuperDalvik(method, who, args);</div><div class="line">                   &#125;</div><div class="line">                &#125; catch (Throwable e) &#123;</div><div class="line">                    Logger.e(&quot;[---] Call super method with error : %s, detail message please see the [Logcat :system.err].&quot;, e.getMessage());</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;else &#123;</div><div class="line">                Logger.e(&quot;[---] Super method cannot found in backup map.&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码是在之前保存的<code>methodNameToBackupMethodsMap</code>中查找备份的方法，找到后对<code>Art</code>与<code>Dalvik</code>模式分别调用<code>callSuperArt()</code>与<code>callSuperDalvik()</code>，前者比较简单，只是调用方法的<code>invoke()</code>就完事，而<code>Dalvik</code>模式由于没有像<code>Art</code>那样做备份，所以多出了一个字段回替换的操作，完事也是调用的<code>invoke()</code>来执行原方法。</p>
<h3 id="0x4-一些感想"><a href="#0x4-一些感想" class="headerlink" title="0x4 一些感想"></a>0x4 一些感想</h3><p>分析完上面的代码，可以出来<code>Legend</code>尽管实现了<code>Art</code>与<code>Dalvik</code>双模式下的Hook，但在实际逆向Hook中，还是有一些不足：</p>
<ol>
<li>不能Hook字段。在很多应用场景中可能会用到，这里有一个迂回的替代的方案是：在字段较敏感的方法中对方法做Hook，然后在Hook代码中反射操作字段。</li>
<li>Hook自定义的类加载器加载的类方法。由于反射查找的类的方法列表依赖于类的查找，对于部分自定义<code>ClassLoader</code>的情况，获取<code>Class</code>本身就存在着难度，更别说Hook它的方法了。</li>
<li>兼容性。只支持4.2到6.0，当然，根据技术原理，从2.3到7.1应该都是可以做到的。</li>
<li>稳定性。与该框架技术原理类似的还有很多，比较alibaba的<code>AndFix</code>，在系统自定义修改较多的情况下，框加要的稳定性存疑，当然，逆向工程时使用的稳定性远没有做产品要求的高，一些全新思路的Hook修改方案如<code>Tinker</code>可能也是一个不错的选择，留待以后测试了！</li>
</ol>
<p>最后，讲完了它的原理，并没有讲如何在逆向工程中使用，这个交给聪明的安全研究人员作为思维发散。</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/02/12/legend/" data-id="ciz2fqefo0004xuvjj5sajip2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android软件安全/">Android软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-macho-unpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/03/macho-unpack/" class="article-date">
  <time datetime="2017-02-03T05:40:56.000Z" itemprop="datePublished">2017-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/03/macho-unpack/">Mach-O脱壳技巧一则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x1-应用场景"><a href="#0x1-应用场景" class="headerlink" title="0x1 应用场景"></a>0x1 应用场景</h3><p>此处讨论的脱壳不是class-dump这类脱壳，而是指第三方的软件压缩与加密壳，例如<code>upx</code>这类壳在iOS/macOS上的脱壳。</p>
<p>App Store上的软件是不允许这类壳程序存在的，但在iOS越狱插件开发领域与macOS第三方软件提供商发布平台，自定义加密的MachO与dylib随处可见，到目前为此，没有在网络上看到关于这类程序脱壳方法的研究与讨论，本篇与大家讨论的就是在这种情况下，如何优雅的脱壳！</p>
<h3 id="0x2-找寻脱壳点"><a href="#0x2-找寻脱壳点" class="headerlink" title="0x2 找寻脱壳点"></a>0x2 找寻脱壳点</h3><p>首先，虚拟机壳与混淆壳不在本篇讨论范围中，在iOS/macOS平台上，如果有虚拟机壳，也是很久以后的事情了，目前市在上见到最多的可能要属<code>upx</code>类的压缩型的壳，这类壳有一个明显的特点：壳初始运行完后，会将代码的控制权交回给原程序，并且内存中已经是存放好了完整的解密代码，脱壳的思路与Android平台上<code>upx</code>的脱壳一样，主要是找准脱壳时机！</p>
<p>在Android时代，脱<code>upx</code>有一个优雅的方法，就是对<code>DT_INIT</code>的处理部分下断点，当<code>linker</code>加载完so，要执行<code>DT_INIT</code>段指向的初始化函数指针时，对内存中的so进行dump来达到脱壳的目的，到了macOS平台上，就采取同样的思路来开始脱壳探索。</p>
<p>首先是编写测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;time.h&gt;</div><div class="line">#import &lt;dlfcn.h&gt;</div><div class="line">#import &lt;stdio.h&gt;</div><div class="line">#import &lt;stdlib.h&gt;</div><div class="line">#import &lt;unistd.h&gt;</div><div class="line">#import &lt;fcntl.h&gt;</div><div class="line">#import &lt;string.h&gt;</div><div class="line"></div><div class="line">// clang -x objective-c -std=gnu99 -fobjc-arc -flat_namespace -dynamiclib -o ./libunderstandpatcher.dylib understandpatcher.m</div><div class="line"></div><div class="line">static double (*orig_difftime)(time_t time1, time_t time0) = NULL;</div><div class="line"></div><div class="line">typedef double (*orig_difftime_type)(time_t time1, time_t time0);</div><div class="line"></div><div class="line">__attribute__((constructor))</div><div class="line">void init_funcs()</div><div class="line">&#123;</div><div class="line">    printf(&quot;--------init funcs.--------\n&quot;);</div><div class="line">    void * handle = dlopen(&quot;libSystem.dylib&quot;, RTLD_NOW);</div><div class="line">    orig_difftime = (orig_difftime_type) dlsym(handle, &quot;difftime&quot;);</div><div class="line">    if(!orig_difftime) &#123;</div><div class="line">        printf(&quot;get difftime() addr error&quot;);</div><div class="line">        exit(-1);</div><div class="line">    &#125;</div><div class="line">    。。。</div><div class="line"></div><div class="line">    printf(&quot;--------init done--------\n&quot;);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>这只是代码的片断，在下写的macOS平台上<code>understand</code>程序的破解补丁，执行以下代码编译生成dylib：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -std=gnu99 -fobjc-arc -flat_namespace -dynamiclib -o ./libunderstandpatcher.dylib understandpatcher.m</div></pre></td></tr></table></figure></p>
<p>完事以后使用MachOView查看生成的dylib，看看<code>init_funcs()</code>以何种形式在Mach-O中存在，如图所示：<br><img src="/2017/02/03/macho-unpack/machoview.jpeg" alt="machoview"></p>
<p>有两个地方需要注意：LC_FUNCTION_STARTS与<strong>DATA,</strong>mod_init_func。</p>
<h4 id="0x2-1-LC-FUNCTION-STARTS"><a href="#0x2-1-LC-FUNCTION-STARTS" class="headerlink" title="0x2.1 LC_FUNCTION_STARTS"></a>0x2.1 LC_FUNCTION_STARTS</h4><p>这个加载命令是一个<code>macho_linkedit_data_command</code>结构体，从名称上判断，它是一个指向了函数起始执行的指针。它的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ otool -l ./libunderstandpatcher.dylib | grep LC_FUNCTION_STARTS -A 3</div><div class="line">  cmd LC_FUNCTION_STARTS</div><div class="line">cmdsize 16</div><div class="line">dataoff 8504</div><div class="line">datasize 8</div></pre></td></tr></table></figure></p>
<p><code>dataoff</code>字段的值8504（0x2138）,在MachOView中看到，它指向Function Starts第一项的<code>__init_funcs()</code>函数。</p>
<h4 id="0x2-2-DATA-mod-init-func"><a href="#0x2-2-DATA-mod-init-func" class="headerlink" title="0x2.2 DATA,mod_init_func"></a>0x2.2 <strong>DATA,</strong>mod_init_func</h4><p><code>__DATA,__mod_init_func</code>是一个Section，它由编译器生成添加到MachO中，用来标识MachO加载完成后要执行的初始化函数。它的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ otool -s __DATA __mod_init_func ./libunderstandpatcher.dylib</div><div class="line">./libunderstandpatcher.dylib:</div><div class="line">Contents of (__DATA,__mod_init_func) section</div><div class="line">0000000000001050	00 0d 00 00 00 00 00 00</div></pre></td></tr></table></figure></p>
<p>位于文件偏移0x1050处指向的是一个个的初始化函数指针，这里只有一个，它的值是0xD00，其实就是<code>__init_funcs()</code>函数所在的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">$ otool -tv ./libunderstandpatcher.dylib</div><div class="line">./libunderstandpatcher.dylib:</div><div class="line">(__TEXT,__text) section</div><div class="line">_init_funcs:</div><div class="line">0000000000000d00	pushq	%rbp</div><div class="line">0000000000000d01	movq	%rsp, %rbp</div><div class="line">0000000000000d04	subq	$0x40, %rsp</div><div class="line">0000000000000d08	leaq	0x1e9(%rip), %rdi</div><div class="line">0000000000000d0f	movb	$0x0, %al</div><div class="line">0000000000000d11	callq	0xe82</div><div class="line">0000000000000d16	leaq	0x1f8(%rip), %rdi</div><div class="line">0000000000000d1d	movl	$0x2, %esi</div><div class="line">0000000000000d22	movl	%eax, -0x14(%rbp)</div><div class="line">0000000000000d25	callq	0xe70</div><div class="line">0000000000000d2a	leaq	0x1f4(%rip), %rsi</div><div class="line">0000000000000d31	movq	%rax, -0x8(%rbp)</div><div class="line">0000000000000d35	movq	-0x8(%rbp), %rdi</div><div class="line">0000000000000d39	callq	0xe76</div><div class="line">0000000000000d3e	movq	%rax, 0x35b(%rip)</div><div class="line">0000000000000d45	cmpq	$0x0, 0x353(%rip)</div><div class="line">0000000000000d4d	jne	0xd6e</div><div class="line">0000000000000d53	leaq	0x1d4(%rip), %rdi</div><div class="line">0000000000000d5a	movb	$0x0, %al</div><div class="line">0000000000000d5c	callq	0xe82</div><div class="line">0000000000000d61	movl	$0xffffffff, %edi</div><div class="line">0000000000000d66	movl	%eax, -0x18(%rbp)</div><div class="line">0000000000000d69	callq	0xe7c</div><div class="line">0000000000000d6e	movq	0x323(%rip), %rax</div><div class="line">0000000000000d75	movq	0x304(%rip), %rsi</div><div class="line">0000000000000d7c	movq	%rax, %rdi</div><div class="line">0000000000000d7f	callq	0xe5e</div><div class="line">0000000000000d84	movq	%rax, %rdi</div><div class="line">0000000000000d87	callq	0xe64</div><div class="line">0000000000000d8c	xorl	%ecx, %ecx</div><div class="line">0000000000000d8e	movl	%ecx, %edi</div><div class="line">0000000000000d90	movq	%rax, -0x10(%rbp)</div><div class="line">0000000000000d94	movq	-0x10(%rbp), %rax</div><div class="line">0000000000000d98	movq	%rax, -0x20(%rbp)</div><div class="line">0000000000000d9c	callq	0xe88</div><div class="line">0000000000000da1	leaq	0x2b0(%rip), %rsi</div><div class="line">0000000000000da8	movq	0x2d9(%rip), %rdi</div><div class="line">0000000000000daf	movq	-0x20(%rbp), %rdx</div><div class="line">0000000000000db3	movq	%rdi, -0x28(%rbp)</div><div class="line">0000000000000db7	movq	%rdx, %rdi</div><div class="line">0000000000000dba	movq	-0x28(%rbp), %rdx</div><div class="line">0000000000000dbe	movq	%rsi, -0x30(%rbp)</div><div class="line">0000000000000dc2	movq	%rdx, %rsi</div><div class="line">0000000000000dc5	movq	%rax, %rdx</div><div class="line">0000000000000dc8	movq	-0x30(%rbp), %rcx</div><div class="line">0000000000000dcc	callq	0xe5e</div><div class="line">0000000000000dd1	movq	-0x10(%rbp), %rax</div><div class="line">0000000000000dd5	movq	0x2b4(%rip), %rsi</div><div class="line">0000000000000ddc	movq	%rax, %rdi</div><div class="line">0000000000000ddf	callq	0xe5e</div><div class="line">0000000000000de4	leaq	0x178(%rip), %rdi</div><div class="line">0000000000000deb	movb	%al, -0x31(%rbp)</div><div class="line">0000000000000dee	movb	$0x0, %al</div><div class="line">0000000000000df0	callq	0xe82</div><div class="line">0000000000000df5	xorl	%r8d, %r8d</div><div class="line">0000000000000df8	movl	%r8d, %esi</div><div class="line">0000000000000dfb	leaq	-0x10(%rbp), %rcx</div><div class="line">0000000000000dff	movq	%rcx, %rdi</div><div class="line">0000000000000e02	movl	%eax, -0x38(%rbp)</div><div class="line">0000000000000e05	callq	0xe6a</div><div class="line">0000000000000e0a	addq	$0x40, %rsp</div><div class="line">0000000000000e0e	popq	%rbp</div><div class="line">0000000000000e0f	retq</div></pre></td></tr></table></figure></p>
<h4 id="0x2-3-dyld执行初始化函数过程"><a href="#0x2-3-dyld执行初始化函数过程" class="headerlink" title="0x2.3 dyld执行初始化函数过程"></a>0x2.3 dyld执行初始化函数过程</h4><p><code>dyld</code>如何执行初始化函数才是我们需要重点关注的。下载<code>dyld</code>源码查看，它启动运行的第一个方法<code>dyldbootstrap::start()</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[],</div><div class="line">				intptr_t slide, const struct macho_header* dyldsMachHeader,</div><div class="line">				uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">	// if kernel had to slide dyld, we need to fix up load sensitive locations</div><div class="line">	// we have to do this before using any global variables</div><div class="line">	if ( slide != 0 ) &#123;</div><div class="line">		rebaseDyld(dyldsMachHeader, slide);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// allow dyld to use mach messaging</div><div class="line">	mach_init();</div><div class="line"></div><div class="line">	// kernel sets up env pointer to be just past end of agv array</div><div class="line">	const char** envp = &amp;argv[argc+1];</div><div class="line"></div><div class="line">	// kernel sets up apple pointer to be just past end of envp array</div><div class="line">	const char** apple = envp;</div><div class="line">	while(*apple != NULL) &#123; ++apple; &#125;</div><div class="line">	++apple;</div><div class="line"></div><div class="line">	// set up random value for stack canary</div><div class="line">	__guard_setup(apple);</div><div class="line"></div><div class="line">#if DYLD_INITIALIZER_SUPPORT</div><div class="line">	// run all C++ initializers inside dyld</div><div class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</div><div class="line">#endif</div><div class="line"></div><div class="line">	// now that we are done bootstrapping dyld, call dyld&apos;s main</div><div class="line">	uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);</div><div class="line">	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在开启<code>DYLD_INITIALIZER_SUPPORT</code>的情况下，会调用<code>runDyldInitializers()</code>执行Mach-O的初始化方法，i当然，目前<code>dyld</code>是支持初始化方法执行的，<code>runDyldInitializers()</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void runDyldInitializers(const struct macho_header* mh, intptr_t slide, int argc, const char* argv[], const char* envp[], const char* apple[])</div><div class="line">&#123;</div><div class="line">	for (const Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) &#123;</div><div class="line">		(*p)(argc, argv, envp, apple);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码从<code>inits_start</code>到<code>inits_end</code>之间循环获取<code>Initializer</code>方法并执行，<code>Initializer</code>与这两个地址定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef void (*Initializer)(int argc, const char* argv[], const char* envp[], const char* apple[]);</div><div class="line"></div><div class="line">extern const Initializer  inits_start  __asm(&quot;section$start$__DATA$__mod_init_func&quot;);</div><div class="line">extern const Initializer  inits_end    __asm(&quot;section$end$__DATA$__mod_init_func&quot;);</div></pre></td></tr></table></figure></p>
<p>可以看出，<code>dyld</code>定位与执行初始化方法是通过”<strong>DATA$</strong>mod_init_func”节区完成的。</p>
<p>了解了<code>dyld</code>加载执行初始化方法的地方，接下来就是如何脱壳了！</p>
<h3 id="0x3-如何动手"><a href="#0x3-如何动手" class="headerlink" title="0x3 如何动手"></a>0x3 如何动手</h3><p>壳程序加载完成，第一件事要做的就是自己或者调用<code>dyld</code>来执行初始化方法，因此，使用任意一款调试器对<code>runDyldInitializers()</code>下断即可。</p>
<p>断点到达后对内存中的MachO进行dump就完成脱壳了，当然对于防内存dump也是有一些tricks的，逆向搞过<code>Hopper</code>主程序的人就会有感触，以后有机会与大家讨论一下！</p>
<p>最后，Mach-O的dump与ELF不太一样，更加简单与完整，这里不再赘述了！</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/02/03/macho-unpack/" data-id="ciz2fqefs0005xuvjubcap5s3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-dmg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/17/dmg/" class="article-date">
  <time datetime="2017-01-17T01:55:56.000Z" itemprop="datePublished">2017-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/17/dmg/">DMG文件管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>dmg是苹果电脑上专用的磁盘镜像（disk image）文件，类似于Windows平台上的iso镜像，dmg类似于一个压缩文档，支持压缩与加密，将程序与文档打包成dmg是一种比较流行的软件发布形式。</p>
<h3 id="0x1-构建dmg"><a href="#0x1-构建dmg" class="headerlink" title="0x1 构建dmg"></a>0x1 构建dmg</h3><p>苹果官方系统自带的磁盘管理工具<code>Disk Utility</code>可以很方便的构建dmg文件，最简单的方法是启动/Applications/Utilies/Disk Utility，点击菜单File-&gt;New Image-&gt;Image From Folder…，从文件夹创建镜像，这一步，选择上一节的app目录，如图所示：<br><img src="/2017/01/17/dmg/disk_utility.png" alt="disk_utility"><br>在Save As处输入要保存的文件名；Encryption处选择是否进行加密，none表示不加密，128-bit AES encryption是macOS版本10.3以前之前支持的128位的AES加密，258-bit AES encryption则是macOS版本10.5以后才开始支持的256位AES加密，在选择这两种中任意一种加密方式后，会弹出输入密码的对话框，提示输入的密码不是AES算法的加密key，只是一个用户自已设置的密码；设置好密码后，在Image Format处设置镜像的格式，read-only表示创建只读的镜像，compressed表示对镜像进行压缩，read/write表示镜像可读可写，DVD/CD master表示创建DVD镜像，hybrid image表示创建混合镜像。选择好选项后，点击Save铵钮，dmg就创建成功了。</p>
<p>除了使用图形界面创建dmg外，还可以使用命令行工具<code>hdiutil</code>来创建，例如为app目录下的myframeworktest.app创建一个AES128加密，密码为abc123的dmg镜像只需要执行如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hdiutil create -fs HFS+ -volname myframework  -srcfolder ../pkg_install_script/app -encryption AES-128 -stdinpass  -o myframeworktest_cmd.dmg</div><div class="line">Enter disk image passphrase: //此处输入密码123</div><div class="line">..</div><div class="line">created: /Users/macbook/code/chapter4/dmg/myframeworktest_cmd.dmg</div></pre></td></tr></table></figure></p>
<p>如果觉得从文件夹中创建的dmg不够个性化，完全可以使用<code>Disk Utility</code>创建自定义的dmg，自定义的dmg包括为dmg指定图标，背景图片，以及dmg文件的显示方式及大小。只需要打开<code>Disk Utility</code>，点击菜单File-&gt;New Image-&gt;Blank Image…，创建一个空白的镜像，在保存对话框中，设置镜像的大小、加密方式、分区格式及镜像格式，需要注意的是，此处镜像格式需要选择read/write disk image，创建成功后，打开镜像，将app目录中的文件复制进去，如果需要更换背景图片，只需要将背景图片复制到镜像中，使用<code>chflags</code>命令设置成隐藏格式，或者放放一个点“.”结尾的目录（点目录默认会隐藏显示），在镜像上右键，在弹出的菜单中选择Get Info，然后设置背景图片即可。操作完后，点击<code>Disk Utility</code>菜单的Images-&gt;Convert…，，选择操作后的dmg镜像，将该镜像压缩保存一下就可以发布了。</p>
<p>除了官网的<code>Disk Utility</code>外，也可以使用上一小节中介绍的<code>Luggage</code>工具，编译脚本后，执行“make dmg”来生成dmg文件。最后，还有一些第三方的工具也可以创建dmg镜像，比较知名的有<code>DropDMG</code>（下载地址：<a href="http://c-command.com/dropdmg" target="_blank" rel="external">http://c-command.com/dropdmg</a> ），从软件的名称上就可以判断，它支持快速的从文件拖放来创建dmg镜像，有兴趣的读者可以试试，它的使用比较简单，此处不再赘述。</p>
<h3 id="0x2-管理dmg"><a href="#0x2-管理dmg" class="headerlink" title="0x2 管理dmg"></a>0x2 管理dmg</h3><p>dmg文件格式不是开放的，要想探索它的文件格式，可以逆向<code>hidutil</code>工具处理dmg的部分代码。在使用dmg的过程中，一种典型的可能遇到的场景是将dmg转换格式后，在Windows或Linux平台上使用，针对早期版本的dmg，网上有第三方的开方人员开发了<code>dmg2img</code>工具（下载地址：<a href="https://github.com/Lekensteyn/dmg2img" target="_blank" rel="external">https://github.com/Lekensteyn/dmg2img</a> ），方便将dmg转换成可以在Linux系统上挂载的镜像，还有一个工具<code>dmg2iso</code>（下载地址：<a href="https://sourceforge.net/projects/dmg2iso" target="_blank" rel="external">https://sourceforge.net/projects/dmg2iso</a> ），可以将dmg转换成Windows平台上使用的iso镜像，实际上该工具的底层是调用的<code>hdiutil</code>。</p>
<p>使用<code>hdiutil</code>来管理dmg已经足够了，它提供了查看、创建、转换dmg等功能，例如，查看myframeworktest.dmg的信息可以执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">$ hdiutil imageinfo myframeworktest.dmg</div><div class="line">Format Description: UDIF read-only compressed (zlib)</div><div class="line">Class Name: CUDIFDiskImage</div><div class="line">Checksum Type: CRC32</div><div class="line">Size Information:</div><div class="line">	Compressed Ratio: 0.022532451628704386</div><div class="line">	Total Empty Bytes: 500224</div><div class="line">	Sector Count: 5060</div><div class="line">	Total Bytes: 2590720</div><div class="line">	CUDIFEncoding-bytes-wasted: 7963</div><div class="line">	Total Non-Empty Bytes: 2090496</div><div class="line">	CUDIFEncoding-bytes-in-use: 47410</div><div class="line">	Compressed Bytes: 47410</div><div class="line">	CUDIFEncoding-bytes-total: 55373</div><div class="line">Checksum Value: $404B6F25</div><div class="line">Segments:</div><div class="line">	......</div><div class="line">	-1:</div><div class="line">		Name: Protective Master Boot Record (MBR : 0)</div><div class="line">		Partition Number: -1</div><div class="line">		Checksum Type: CRC32</div><div class="line">		Checksum Value: $0492F534</div><div class="line">	2:</div><div class="line">		Name:  (Apple_Free : 3)</div><div class="line">		Partition Number: 2</div><div class="line">		Checksum Type: CRC32</div><div class="line">		Checksum Value: $00000000</div><div class="line">Format: UDZO</div><div class="line">Backing Store Information:</div><div class="line">	......</div><div class="line">partitions:</div><div class="line">	partition-scheme: GUID</div><div class="line">	block-size: 512</div><div class="line">	partitions:</div><div class="line">		0:</div><div class="line">			partition-name: Protective Master Boot Record</div><div class="line">			partition-start: 0</div><div class="line">			partition-synthesized: true</div><div class="line">			partition-length: 1</div><div class="line">			partition-hint: MBR</div><div class="line">		......</div><div class="line">		7:</div><div class="line">			partition-name: GPT Header</div><div class="line">			partition-start: 5059</div><div class="line">			partition-synthesized: true</div><div class="line">			partition-length: 1</div><div class="line">			partition-hint: Backup GPT Header</div><div class="line">	burnable: false</div><div class="line">udif-ordered-chunks: false</div><div class="line">Properties:</div><div class="line">	Encrypted: false</div><div class="line">	Kernel Compatible: true</div><div class="line">	Checksummed: true</div><div class="line">	Software License Agreement: false</div><div class="line">	Partitioned: false</div><div class="line">	Compressed: true</div><div class="line">Resize limits (per hdiutil resize -limits):</div><div class="line"> min 	 cur 	 max</div><div class="line">5060	5060	5060</div></pre></td></tr></table></figure></p>
<p>将myframeworktest_cmd.dmg密码abc123更改为123abc只需执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hdiutil chpass ./myframeworktest_cmd.dmg</div><div class="line">Enter password to access &quot;myframeworktest_cmd.dmg&quot;:			//abc123</div><div class="line">Enter a new password to secure &quot;myframeworktest_cmd.dmg&quot;:	//123abc</div><div class="line">Re-enter new password:		//123abc</div></pre></td></tr></table></figure></p>
<p>将myframeworktest.dmg转换成iso格式可以执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ hdiutil convert ./myframeworktest.dmg -format UDTO -o ./myframeworktest.cdr</div><div class="line">Reading Protective Master Boot Record (MBR : 0)…</div><div class="line">Reading GPT Header (Primary GPT Header : 1)…</div><div class="line">Reading GPT Partition Data (Primary GPT Table : 2)…</div><div class="line">Reading  (Apple_Free : 3)…</div><div class="line">Reading disk image (Apple_HFS : 4)…</div><div class="line">..............................................................................</div><div class="line">Reading  (Apple_Free : 5)…</div><div class="line">Reading GPT Partition Data (Backup GPT Table : 6)…</div><div class="line">..............................................................................</div><div class="line">Reading GPT Header (Backup GPT Header : 7)…</div><div class="line">..............................................................................</div><div class="line">Elapsed Time:   7.868ms</div><div class="line">Speed: 314.0Mbytes/sec</div><div class="line">Savings: 0.0%</div><div class="line">created: /Users/.../code/chapter4/dmg/myframeworktest.cdr</div><div class="line">$ mv ./myframeworktest.cdr ./myframeworktest.iso</div></pre></td></tr></table></figure></p>
<p>另外，<code>DropDMG</code>也提供了很方便的dmg管理功能。例如，在文件夹上点击右键，在弹出的菜点中，选择Services-&gt;DropDMG:Use Current Configration，<code>DropDMG</code>就会使用当前默认的配置为文件夹在当前目录创建一个dmg，或者在dmg上点击右键，选择DropDMG:Ask for Options，来对dmg做一些修改，例如设置图标、修改密码、更改格式等。</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/17/dmg/" data-id="ciz2fqef30000xuvj3xbh1kul" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pkg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/16/pkg/" class="article-date">
  <time datetime="2017-01-16T00:19:06.000Z" itemprop="datePublished">2017-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不同的操作系统都有专属于自己的软件安装包格式。如Ubuntu系统上的deb安装包，Windows系统上的msi安装包等。macOS系统使用pkg作为软件安装包格式。</p>
<p>大多数macOS上开发的程序都不需要安装程序，它们只是一个以app结尾的Bundle包，使用zip压缩一下，或者dmg制作一份镜像，是这类程序的主要发布方式。然而，一些App有一些特定的需求，比如：向系统配置面板写配置程序、安装屏幕保护程序、读写特定的目录与文件等。此时就可以制作pkg安装包程序来安装这类特殊的程序了。当然，由于这些特殊性，pkg安装程序无法通过苹果官方商店来发布。</p>
<h3 id="0x1-构建pkg"><a href="#0x1-构建pkg" class="headerlink" title="0x1 构建pkg"></a>0x1 构建pkg</h3><p>pkg安装程序能够扩展程序安装内容以及读写特定目录的特性，来源于pkg支持的脚本特性，pkg安装程序允许开发人员在程序的安装过程中，运行自己编写的Bash脚本程序。</p>
<p>苹果官方在低版本的<code>Xcode</code>工具中提供了<code>PackageMaker</code>用来制作pkg，该工具没有直接包含在<code>XCode</code>开发套件中，如果要使用它，需要到苹果的开发者官网上去下载它。下载安装好该工具后，运行PackageMaker.app就可以制作pkg了。</p>
<p>本小节制作一个pkg安装包，完成以下目标：将上一小节的myframeworktest程序安装到Applications目录下，随便将myframework.framework框架安装到~/Library/frameworks目录中。启动<code>PackageMaker</code>，点击菜单File-&gt;New，在弹出的对话框中，在Organization一栏输入机构信息，如“com.macbook”，点击OK返回程序主界面，点击File-&gt;Save，将工程保存为pkg_install.pmdoc。</p>
<p>将上一小节的myframeworktest程序放到app目录下，将app目录直接拖入<code>PackageMaker</code>的主界面，会自己加程序添加配置信息，点击Configuration可以设置一些安装时的配置信息，如图所示：<br><img src="/2017/01/16/pkg/pkgmaker.png" alt="pkgmaker"><br><code>install</code>指定要安装的程序路径，这里已经指定好了；<code>Destination</code>指定程序要安装的位置，默认为“/Applications”目录；取消勾选“Allow custom location”选项，让程序只能安装到/Applications目录下，<code>Package Identifier</code>指定安装包的标识符，macOS记录安装过的pkg就是通过它来识别的，手动卸载pkg时需要用到它；<code>Package Version</code>指定安装包的版本，版本号是识别pkg版本升级的关键，为pkg指定升级脚本时需要用到；<code>Restart Action</code>指定pkg安装完成后，是否需要执行注销、关机或重启等操作；<code>Require admin authentication</code>复选框指定安装器需要管理员权限，为pkg指定的安装脚本如果需要管理员权限的话，就需要在此勾选上。<br>配置好后，点击Contents标签，配置需要安装的内容，<code>PackageMaker</code>已经默认选择好了要安装的内容为myframeworktest.app，并且文件的读写与执行权限也自动设置好了，如图所示：<br><img src="/2017/01/16/pkg/pkgmaker_contents.png" alt="pkgmaker_contents"><br>关于文件的读写权限设罢，一个建议的设置如下表所示：</p>
<p><strong>表4.1 Contents权限设置</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Owner</th>
<th>Group</th>
<th>Permissions</th>
</tr>
</thead>
<tbody>
<tr>
<td>Applications</td>
<td>root</td>
<td>admin</td>
<td>rwxrwxr-x</td>
</tr>
<tr>
<td>System</td>
<td>root</td>
<td>admin</td>
<td>rwxrwxr-x</td>
</tr>
<tr>
<td>Library</td>
<td>root</td>
<td>admin</td>
<td>rwxrwxr-x</td>
</tr>
<tr>
<td>Extensions</td>
<td>root</td>
<td>admin</td>
<td>rwxrwxr-x</td>
</tr>
</tbody>
</table>
<p>关于拖入Contents中的程序，这里有一个技巧！macOS系统会为操作过的文件夹中生成一个隐藏的<code>.DS_Store</code>文件，如果系统开启了显示隐藏文件的选项，直接打包程序会在安装包中包含隐藏的<code>.DS_Store</code>文件，需要在拖入Contents前将它们全部删除，可以使用如下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name &quot;.DS_Store&quot; -exec rm -f &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>点击Components标签，配置组件信息。取消掉“Allow Relocation”复选框，否则即使提示安装完成，在/Applications目录下也看不到安装后的程序。如图所示：<br><img src="/2017/01/16/pkg/pkgmaker_components.png" alt="pkgmaker_components"><br>点击Scripts标签，配置运行安装器时需要执行的脚本。将编写好的脚本分别保存为preflight与postflight，然后将它们放到script目录下，执行以下命令为它们赋上可执行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod a+x ./preinstall</div><div class="line">$ chmod a+x ./postflight</div></pre></td></tr></table></figure></p>
<p>将script目录直接拖入Scripts Directory旁的文本框中，此时，Preflight与Postflight脚本会自动设置完成。如图所示：<br><img src="/2017/01/16/pkg/pkgmaker_script.png" alt="pkgmaker_script"><br>可以设置的脚本有六个，它们按照执行顺序分别是：</p>
<ul>
<li>preflight：点击安装界面上的Install按钮时运行此脚本。该脚本在程序每次安装时都会运行。</li>
<li>preinstall/preupgrade：针对单程序安装包（pkg），该脚本会在preflight脚本运行之后运行，针对多程序安装包（mpkg），该脚本会在用户按下Install铵钮后执行。preinstall与preupgrade的区别在于：preinstall只会在用户第一次安装该程序时执行，而preupgrade相反，如果之前安装过该程序，那么该脚本才会执行，preupgrade用于软件升级时使用。区分程序是否为第一次安装是通过pkg安装器Installer.app来完成的，Installer.app通过查看/private/var/db/receipts目录，查看目录中是否有以程序包名命名的pkg文件，如果存在，说明已经安装过，反之，为第一次安装。</li>
<li>postinstall/postupgrade：该脚本在程序安装完之后才运行。它们的区别与preinstall/preupgrade一样。</li>
<li>postflight：该脚本在postinstall/postupgrade脚本之后运行。<br><code>PackageMaker</code>支持Shell脚本与Perl脚本，此处编写的是Shell脚本，preinstall脚本的内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env bash</div><div class="line"></div><div class="line">echo &quot;Running myframeworktest.app preinstall script.&quot;</div><div class="line">echo &quot;Killing myframeworktest.app.&quot;</div><div class="line">killall &quot;myframeworktest&quot;</div><div class="line"></div><div class="line">echo &quot;Finding old versions of myframeworktest.&quot;</div><div class="line">mdfind -onlyin /Applications &quot;kMDItemCFBundleIdentifier==&apos;fc.myframeworktest&apos;&quot; | xargs -I % rm -rf %</div><div class="line"></div><div class="line">echo &quot;Removed old versions of myframeworktest.app, if any.&quot;</div><div class="line">echo &quot;Ran myframeworktest.app preinstall script.&quot;</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure>
<p>这段脚本首先使用killall杀掉正在运行的myframeworktest.app进程；接着使用<code>mdfind</code>在/Applications目录下查找程序标识符为”fc.myframeworktest“的程序包路径，找到后使用<code>rm -rf</code>将其删除掉。</p>
<p>再来看看postflight脚本的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env bash</div><div class="line"></div><div class="line">echo &quot;Running myframeworktest.app postinstall script.&quot;</div><div class="line">echo &quot;Installing myframework.framework.&quot;</div><div class="line"></div><div class="line">rm -rf ~/Library/Frameworks/myframework.framework</div><div class="line">mkdir ~/Library/Frameworks/myframework.framework</div><div class="line">cp -r /Applications/myframeworktest.app/Contents/Frameworks/myframework.framework/* ~/Library/Frameworks/myframework.framework</div><div class="line"></div><div class="line">chmod -R 6777 ~/Library/Frameworks/myframework.framework</div><div class="line">echo &quot;Ran myframeworktest.app postinstall script.&quot;</div><div class="line"></div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<p>该脚本运行时，myframeworktest.app程序包已经安装到了/Applications目录下，将myframework.framework拷贝到~/Library/Frameworks目录下，然后修改它的权限为任何人都可读可写可执行，最后执行完后调用”exit 0”退出脚本。</p>
<p>配置好要安装的内容与执行脚本后，点击Contents上面的图标，对pkg进行配置，点击Configuration，在Title旁的文本框中输入安装包的标题，例如”mframeworktest installer“；User Sees处选择Easy Install Only（简单安装）即可；Install Destination处勾选Volume selected by user。</p>
<p>点击Requirements标签，设置pkg运行的系统要求。点击界面左下角的加号”＋“按钮，添加两条规则：一条是System OS Version(e.g. 10.x.x)，另一条是Target OS Version(e.g. 10.x.x)，都设置成”&gt;=“10.6，如图所示：<br><img src="/2017/01/16/pkg/pkgmaker_requirements.png" alt="pkgmaker_requirements"></p>
<p>最后的Actions标签页不用去管它。配置完了后，还可以点击界面右上角的Edit interface按钮来编辑安装程序的界面。包括：Background、Introduction、Read me、License与Finish up。它们每一项都是一个页面，内容可以选择系统默认的Default，也可以直接写一段文本甙入（Embedded）进去，或者选择一个外部的rtf文档或html网页。如图所示，为一段手写的Read Me：<br><img src="/2017/01/16/pkg/pkgmaker_readme.png" alt="pkgmaker_readme"></p>
<p>以上所有操作完成后，点击<code>PackageMaker</code>左上角的Build铵钮进行构建，或者Build and Run按钮构建成功后直接运行。构建完成后会针对单程序安装包或多程序安装包生成一个pkg或mpkg文件，该文件是最终可以发布的产品，接下来只需要对其进行安装测试，没问题就可以发布了。</p>
<p>在新版本的<code>XCode</code>中，提供了命令行工具<code>productbuild</code>来打包制作pkg。本小节<code>PackageMaker</code>操作的步骤可以执行以下命令完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ productbuild --component app/myframeworktest.app /Applications --scripts script  ~/Desktop/out.pkg</div></pre></td></tr></table></figure></p>
<p>命令执行完后，就会在当前用户桌面上生成pkg文件，当然编译时可以指定<code>--sign</code>参数来为pkg签名，pkg的签名不是使用<code>codesign</code>，如果创建pkg时没有对其进行签名，或者手动修改过pkg的内容，可以使用工具<code>productsign</code>来对pkg进行签名。</p>
<p>介绍了官方的pkg创建工具后，再来看看目前市面上常用的pkg制作工具。<br>喜欢命令行编译的开发人员一定会喜欢工具<code>Luggage</code>（下载地址：“<a href="https://github.com/unixorn/luggage”），它提供了一种自定义脚本的方式来编译构建pkg文件。该工具的使用方法很简单，只需要将整个github上的文件复制到/usr/local/share/luggage就完成了安装。至于脚本如何编写，可以参考`Luggage`提供的样例，" target="_blank" rel="external">https://github.com/unixorn/luggage”），它提供了一种自定义脚本的方式来编译构建pkg文件。该工具的使用方法很简单，只需要将整个github上的文件复制到/usr/local/share/luggage就完成了安装。至于脚本如何编写，可以参考`Luggage`提供的样例，</a><br>地址为“<a href="https://github.com/unixorn/luggage-examples”，以编译样例中的fex程序为例，在命令行下执行以下命令：" target="_blank" rel="external">https://github.com/unixorn/luggage-examples”，以编译样例中的fex程序为例，在命令行下执行以下命令：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line"></div><div class="line">Usage</div><div class="line"></div><div class="line">make clean - clean up work files.</div><div class="line">make dmg   - roll a pkg, then stuff it into a dmg file.</div><div class="line">make zip   - roll a pkg, then stuff it into a zip file.</div><div class="line">make pkg   - roll a pkg.</div><div class="line">make pkgls - list the bill of materials that will be generated by the pkg.</div><div class="line"></div><div class="line">$ make pkg</div><div class="line">Password:</div><div class="line">make -f Makefile -e pack-fex</div><div class="line"></div><div class="line">Disabling bundle relocation.</div><div class="line">If you need to override permissions or ownerships, override modify_packageroot in your Makefile</div><div class="line">Creating /tmp/the_luggage/Fex-20160902/payload/Fex-20160902.pkg with /usr/bin/pkgbuild.</div><div class="line">sudo /usr/bin/pkgbuild --root /tmp/the_luggage/Fex-20160902/root \</div><div class="line">       		--component-plist /tmp/the_luggage/Fex-20160902/luggage.pkg.component.plist \</div><div class="line">       		--identifier com.huronhs.Fex \</div><div class="line">       		--filter &quot;/CVS$&quot; --filter &quot;/\.svn$&quot; --filter &quot;/\.cvsignore$&quot; --filter &quot;/\.cvspass$&quot; --filter &quot;/(\._)?\.DS_Store$&quot; --filter &quot;/\.git$&quot; --filter &quot;/\.gitignore$&quot; \</div><div class="line">       		--scripts /tmp/the_luggage/Fex-20160902/scripts \</div><div class="line">       		--version 20160902 \</div><div class="line">       		--ownership preserve --quiet \</div><div class="line">       		/tmp/the_luggage/Fex-20160902/payload/Fex-20160902.pkg</div><div class="line"></div><div class="line">$ ls</div><div class="line">Fex-20160902.pkg       	Makefile       		fex</div></pre></td></tr></table></figure></p>
<p>从输出中可以看出，除了构建pkg，<code>Luggage</code>还支持生成dmg与zip打包的程序，非常方便。</p>
<p>与<code>Luggage</code>类似的还有<code>createOSXinstallPkg</code>（下载地址：“<a href="https://github.com/munki/createOSXinstallPkg”），使用方法也很简单，有兴趣的读者可以到github页面上查看如何使用。" target="_blank" rel="external">https://github.com/munki/createOSXinstallPkg”），使用方法也很简单，有兴趣的读者可以到github页面上查看如何使用。</a></p>
<p>最后，还有一款免费强大的pkg安装包制作工具<code>Iceberg</code>（下载地址：<a href="http://s.sudre.free.fr/Software/Iceberg.html" target="_blank" rel="external">http://s.sudre.free.fr/Software/Iceberg.html</a> ），该工具可以修改安装程序界面的背景图片，此处就不去讨论它的用法了，有兴趣的读者可以去它的官网下载了试试。</p>
<h3 id="0x2-pkg的安装与卸载"><a href="#0x2-pkg的安装与卸载" class="headerlink" title="0x2 pkg的安装与卸载"></a>0x2 pkg的安装与卸载</h3><p>安装pkg很简单，只要双击pkg，或者双击mpkg，就会弹出安装向导，按照步骤不停点击Next，直到安装完成，安装过程中，可能执行一些操作可能会需要管理器权限，系统会弹出提示要求用户输入管理员密码，按照操作输入密码即可。除了双击安装外，还可以使用命令行工具<code>installer</code>进行静默安装，执行以下命令可以安装上一小节的pkg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo installer -pkg ./myframework_installer.pkg -target LocalSystem</div><div class="line">Password:</div><div class="line">installer: Package name is myframework installer</div><div class="line">installer: Upgrading at base path /</div><div class="line">installer: The upgrade was successful.</div></pre></td></tr></table></figure></p>
<p>pkg的卸载就没这么简单了！苹果公司没有提供直接卸载pkg的方法，上一小节没有制作pkg格式的卸载程序，而是编写了一个简单的脚本，只需要双击运行它就可以卸载上一节制作的pkg。脚本的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env bash</div><div class="line"></div><div class="line">if [ -d ~/Library/Frameworks/myframework.framework ]; then</div><div class="line">   /bin/rm -rf ~/Library/Frameworks/myframework.framework</div><div class="line">fi</div><div class="line"></div><div class="line">if [ -d /Application/myframework.app ]; then</div><div class="line">   /bin/rm -rf /Applications/myframeworktest.app</div><div class="line">fi</div><div class="line"></div><div class="line">echo done.</div></pre></td></tr></table></figure></p>
<p>对于没有提供卸载程序的pkg，卸载它们就只能手动或者依赖第三方的工具。例如<code>UninstallPKG</code>（下载地址：<a href="http://www.corecode.at/uninstallpkg" target="_blank" rel="external">http://www.corecode.at/uninstallpkg</a> ），这是一个收费软件，安装并运行该软件后，它会收集系统中安装的所有pkg软件，然后使用列表形式展示出来，如图所示：<br><img src="/2017/01/16/pkg/uninstallpkg.png" alt="uninstallpkg"><br>点击View Package…按钮，可以查看pkg在系统中写入了哪些文件内容，点击Uninstall Package…可以直接卸载pkg。</p>
<p><code>UninstallPKG</code>是如何做到收集与卸载系统中安装的pkg呢？其实它的原理并不难。它通过读取/private/var/db/receipts下的pkg列表，然后使用<code>lsbom</code>查看这些pkg文件的bom信息，找到bom文件中保存的文件列表，将它们列举出来，卸载的时候将它们全部删除即可。执行如下的命令列表可以查看上一小节pkg的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ cd /private/var/db/receipts</div><div class="line">$ ls | grep macbook</div><div class="line">com.macbook.myframeworkInstaller.pkg.bom</div><div class="line">com.macbook.myframeworkInstaller.pkg.plist</div><div class="line">$  lsbom -pf ./com.macbook.myframeworkInstaller.pkg.bom</div><div class="line">.</div><div class="line">./myframeworktest.app</div><div class="line">./myframeworktest.app/Contents</div><div class="line">./myframeworktest.app/Contents/Frameworks</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Resources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources/Info.plist</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature/CodeResources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/myframework</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/Current</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/myframework</div><div class="line">./myframeworktest.app/Contents/Info.plist</div><div class="line">./myframeworktest.app/Contents/MacOS</div><div class="line">./myframeworktest.app/Contents/MacOS/myframeworktest</div><div class="line">./myframeworktest.app/Contents/PkgInfo</div><div class="line">./myframeworktest.app/Contents/Resources</div><div class="line">./myframeworktest.app/Contents/Resources/Base.lproj</div><div class="line">./myframeworktest.app/Contents/Resources/Base.lproj/MainMenu.nib</div><div class="line">./myframeworktest.app/Contents/_CodeSignature</div><div class="line">./myframeworktest.app/Contents/_CodeSignature/CodeResources</div></pre></td></tr></table></figure></p>
<p>可以看出，脚本中执行的命令，在~/Library/Frameworks目录中安装的myframework.framework并没有列出来，而只有在Contents中指定的内容。上面查看bom信息使用的<code>lsbom</code>命令，其实，查看pkg中的内容还有一种更简单的方法，在双击运行pkg后，不要点击Continue按钮，而是点击菜单File-&gt;Show Files，pkg中包含的文件内容就一目了然了，如图所示：<br><img src="/2017/01/16/pkg/pkg_showfiles.png" alt="pkg_showfiles"><br>除了手动的去/private/var/db/receipts目录下读取pkg列表，还可以使用pkg管理工具<code>pkgutil</code>来查看系统中安装的pkg信息，不过只有查看功能，不能卸载。执行如下命令可以查看上一节安装的pkg信息，效果与上面一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ pkgutil --pkgs | grep -i com.macbook</div><div class="line">com.macbook.myframeworkInstaller.pkg</div><div class="line">$ pkgutil --files com.macbook.myframeworkInstaller.pkg</div><div class="line">myframeworktest.app</div><div class="line">myframeworktest.app/Contents</div><div class="line">myframeworktest.app/Contents/Frameworks</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Resources</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources/Info.plist</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature/CodeResources</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/myframework</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/Current</div><div class="line">myframeworktest.app/Contents/Frameworks/myframework.framework/myframework</div><div class="line">myframeworktest.app/Contents/Info.plist</div><div class="line">myframeworktest.app/Contents/MacOS</div><div class="line">myframeworktest.app/Contents/MacOS/myframeworktest</div><div class="line">myframeworktest.app/Contents/PkgInfo</div><div class="line">myframeworktest.app/Contents/Resources</div><div class="line">myframeworktest.app/Contents/Resources/Base.lproj</div><div class="line">myframeworktest.app/Contents/Resources/Base.lproj/MainMenu.nib</div><div class="line">myframeworktest.app/Contents/_CodeSignature</div><div class="line">myframeworktest.app/Contents/_CodeSignature/CodeResources</div></pre></td></tr></table></figure></p>
<h3 id="0x3-pkg文件格式"><a href="#0x3-pkg文件格式" class="headerlink" title="0x3 pkg文件格式"></a>0x3 pkg文件格式</h3><p>pkg分为pkg与mpkg，前者是针对单程序安装；后者是针对多程序安装，它包含一个或多个的子包（Sub Package）。pkg本身又有两种格式，一种是与Bundle一样，有着特定组织结构的目录，上一小节生成的pkg的安装包就是这种格式的，还有一种是xar格式的文件，下面分别对这两种格式的安装包进行分析。</p>
<p>首先看myframework_installer.mpkg，使用<code>tree</code>命令（系统默认没有此命令，可以使用“brew install tree”进行安装）查看它的目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ tree ./myframework_installer.mpkg/</div><div class="line">./myframework_installer.mpkg/</div><div class="line">└── Contents</div><div class="line">    ├── Packages</div><div class="line">    │   └── app.pkg</div><div class="line">    │       └── Contents</div><div class="line">    │           ├── Archive.bom</div><div class="line">    │           ├── Archive.pax.gz</div><div class="line">    │           ├── Info.plist</div><div class="line">    │           ├── PkgInfo</div><div class="line">    │           └── Resources</div><div class="line">    │               ├── en.lproj</div><div class="line">    │               │   └── Description.plist</div><div class="line">    │               ├── package_version</div><div class="line">    │               ├── postflight</div><div class="line">    │               └── preflight</div><div class="line">    ├── Resources</div><div class="line">    │   └── en.lproj</div><div class="line">    └── distribution.dist</div><div class="line"></div><div class="line">8 directories, 9 files</div></pre></td></tr></table></figure></p>
<p>对于外层的mpkg，它的Packages目录下存放的是pkg文件列表，也就是子包列表；Resources目录存放了pkg用到的资源、如本地化资源、图像、rtf文档、pdf文档等；还有一个distribution.dist文件，这是一个xml文档，包含了要安装的子包、运行时脚本等信息。对于当前的mpkg，它的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;</div><div class="line">&lt;installer-script minSpecVersion=&quot;1.000000&quot; authoringTool=&quot;com.apple.PackageMaker&quot; authoringToolVersion=&quot;3.0.6&quot; authoringToolBuild=&quot;201&quot;&gt;</div><div class="line">    &lt;title&gt;myframework installer&lt;/title&gt;</div><div class="line">    &lt;options customize=&quot;never&quot; allow-external-scripts=&quot;no&quot; rootVolumeOnly=&quot;false&quot;/&gt;</div><div class="line">    &lt;installation-check script=&quot;pm_install_check();&quot;/&gt;</div><div class="line">    &lt;volume-check script=&quot;pm_volume_check();&quot;/&gt;</div><div class="line">    &lt;script&gt;function pm_volume_check() &#123;</div><div class="line">  if(!(my.target.systemVersion &amp;amp;&amp;amp; /* &amp;gt;= */ system.compareVersions(my.target.systemVersion.ProductVersion, &apos;10.6&apos;) &amp;gt;= 0)) &#123;</div><div class="line">    my.result.title = &apos;Failure&apos;;</div><div class="line">    my.result.message = &apos;Installation cannot proceed, as not all requirements were met.&apos;;</div><div class="line">    my.result.type = &apos;Fatal&apos;;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">function pm_install_check() &#123;</div><div class="line">  if(!(/* &amp;gt;= */ system.compareVersions(system.version.ProductVersion, &apos;10.6&apos;) &amp;gt;= 0)) &#123;</div><div class="line">    my.result.title = &apos;Failure&apos;;</div><div class="line">    my.result.message = &apos;Installation cannot proceed, as not all requirements were met.&apos;;</div><div class="line">    my.result.type = &apos;Fatal&apos;;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">    &lt;choices-outline&gt;</div><div class="line">        &lt;line choice=&quot;choice0&quot;/&gt;</div><div class="line">    &lt;/choices-outline&gt;</div><div class="line">    &lt;choice id=&quot;choice0&quot; title=&quot;app&quot;&gt;</div><div class="line">        &lt;pkg-ref id=&quot;com.macbook.myframeworkInstaller.pkg&quot;/&gt;</div><div class="line">    &lt;/choice&gt;</div><div class="line">    &lt;pkg-ref id=&quot;com.macbook.myframeworkInstaller.pkg&quot; installKBytes=&quot;108&quot; version=&quot;1.0&quot; auth=&quot;Root&quot;&gt;file:./Contents/Packages/app.pkg&lt;/pkg-ref&gt;</div><div class="line">&lt;/installer-script&gt;</div></pre></td></tr></table></figure></p>
<p><code>pm_install_check()</code>与<code>pm_volume_check()</code>分别做安装时检查与卷标检查，下面的choices-outline部分指定了安装时使用的choice，也就是选择执行哪个子包，对于当前mpkg包，它只有一个pkg，choice的id为“choice0”，指向的路径是“file:./Contents/Packages/app.pkg”。</p>
<p>app.pkg是要安装的子包，是一个pkg格式的Bundle结构的目录，它包含一个Contents子目录，里面有四个文件与一个目录Resources，它们分别是：</p>
<ul>
<li>Archive.bom：bom信息。存放的要安装写入的文件列表，可以使用“lsbom -pf”命令查看，效果与上一节讲到的一样。</li>
<li><p>Archive.pax.gz：使用pax格式打包后，再使用gzip压缩的压缩包，它的内容就是要安装的内容，此处就是myframeworktest.app程序。可以执行以下命令进行解压：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ cd ./myframework_installer.mpkg/Contents/Packages/app.pkg/Contents/</div><div class="line">$ gunzip -d ./Archive.pax.gz</div><div class="line">$ pax -rvf ./Archive.pax</div><div class="line">.</div><div class="line">./myframeworktest.app</div><div class="line">./myframeworktest.app/Contents</div><div class="line">./myframeworktest.app/Contents/_CodeSignature</div><div class="line">./myframeworktest.app/Contents/_CodeSignature/CodeResources</div><div class="line">./myframeworktest.app/Contents/Frameworks</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/myframework</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Resources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/_CodeSignature/CodeResources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/myframework</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/A/Resources/Info.plist</div><div class="line">./myframeworktest.app/Contents/Frameworks/myframework.framework/Versions/Current</div><div class="line">./myframeworktest.app/Contents/Info.plist</div><div class="line">./myframeworktest.app/Contents/MacOS</div><div class="line">./myframeworktest.app/Contents/MacOS/myframeworktest</div><div class="line">./myframeworktest.app/Contents/PkgInfo</div><div class="line">./myframeworktest.app/Contents/Resources</div><div class="line">./myframeworktest.app/Contents/Resources/Base.lproj</div><div class="line">./myframeworktest.app/Contents/Resources/Base.lproj/MainMenu.nib</div></pre></td></tr></table></figure>
</li>
<li><p>Info.plist：pkg包的信息。如<code>CFBundleIdentifier</code>为pkg的标识；IFMajorVersion与IFMinorVersion分别为pkg的主版本与子版本号；IFPkgFlagInstalledSize为pkg安装后所需要占用的字节大小。</p>
</li>
<li>PkgInfo：8字节的标识。表明是一个pkg文件。</li>
</ul>
<p>Resources目录除了包含资源文件外，还包含了：</p>
<ul>
<li>package_version：它是包版本文件。也就是使用<code>PackageMaker</code>制作pkg时设置的版本号；</li>
<li>postflight/preflight：pkg要执行的脚本文件。上一节中讲过，此处是未经过加密明文存放的。</li>
</ul>
<p>另外一种是xar格式的文件，可以使用如下命令查看myframework_installer.pkg文件的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ file ./myframework_installer.pkg</div><div class="line">./myframework_installer.pkg: xar archive - version 1</div></pre></td></tr></table></figure></p>
<p>xar是压缩的可扩展归档格式，可以使用<code>xar</code>命令对其进行解压，执行如下命令解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ xar -xvf ./myframework_installer.pkg</div><div class="line">Distribution</div><div class="line">app.pkg/PackageInfo</div><div class="line">app.pkg/Bom</div><div class="line">app.pkg/Payload</div><div class="line">app.pkg/Scripts</div><div class="line">app.pkg</div><div class="line">Resources/en.lproj</div><div class="line">Resources</div></pre></td></tr></table></figure></p>
<p>Distribution与前面讨论的distribution.dist文件基本一样；Resources目录与前面的也一样；主要看app.pkg，它包含四个文件：</p>
<ul>
<li>Bom：bom信息，存放的要安装写入的文件列表。可以使用“lsbom -pf”命令查看，效果与上一节讲到的一样。</li>
<li>PackageInfo：文本文件，包含了包的信息。可以使用<code>cat</code>命令查看它的内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat app.pkg/PackageInfo</div><div class="line"></div><div class="line">&lt;pkg-info format-version=&quot;2&quot; identifier=&quot;com.macbook.myframeworkInstaller.pkg&quot; version=&quot;1.0&quot; install-location=&quot;/Applications&quot; auth=&quot;root&quot;&gt;</div><div class="line">    &lt;payload installKBytes=&quot;108&quot; numberOfFiles=&quot;25&quot;/&gt;</div><div class="line">    &lt;scripts&gt;</div><div class="line">        &lt;preinstall file=&quot;./preflight&quot;/&gt;</div><div class="line">        &lt;postinstall file=&quot;./postflight&quot;/&gt;</div><div class="line">    &lt;/scripts&gt;</div><div class="line">    &lt;bundle id=&quot;fc.myframeworktest&quot; CFBundleIdentifier=&quot;fc.myframeworktest&quot; path=&quot;./myframeworktest.app&quot; CFBundleVersion=&quot;1&quot;&gt;</div><div class="line">        &lt;bundle id=&quot;fc.myframework&quot; CFBundleIdentifier=&quot;fc.myframework&quot; path=&quot;./Contents/Frameworks/myframework.framework&quot; CFBundleVersion=&quot;1&quot;/&gt;</div><div class="line">    &lt;/bundle&gt;</div><div class="line">    &lt;bundle-version&gt;</div><div class="line">        &lt;bundle id=&quot;fc.myframeworktest&quot;/&gt;</div><div class="line">        &lt;bundle id=&quot;fc.myframework&quot;/&gt;</div><div class="line">    &lt;/bundle-version&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Payload：经过gzip压缩过的数据内容，本处为要安装的myframework.app，可以使用如下命令进行解压：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat ./Payload | cpio -i</div><div class="line">3 blocks</div></pre></td></tr></table></figure>
<p>解压成功后就会在当前目录下生成myframework.app。</p>
<ul>
<li>Scripts：经过gzip压缩过的脚本。可以使用如下命令进行解压：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd app.pkg</div><div class="line">$ cat ./Scripts | cpio -i</div><div class="line">181 blocks</div></pre></td></tr></table></figure>
<p>解压成功后就会在当前目录下生成未加密的preflight与postflight脚本。</p>
<h3 id="0x4-破解pkg"><a href="#0x4-破解pkg" class="headerlink" title="0x4 破解pkg"></a>0x4 破解pkg</h3><p>对于pkg格式有一定了解后，修改或破解pkg就不会感到多难。破解pkg无非有以下三种：</p>
<ul>
<li>资源的替换或修改：针对文件夹类型的pkg，未加密，可直接进行修改替换；针对xar类型的pkg，需要先解压xar，然后替换或修改完资源后，重新压缩xar。</li>
<li>安装脚本的替换或修改：针对文件夹类型的pkg，未加密，可直接进行修改替换；针对xar类型的pkg，需要先解压xar，然后解压Scripts，然后替换或修改完脚本后，重新压缩Scripts，最后重新压缩xar。</li>
<li>安装内容的替换或修改：针对文件夹类型的pkg，未加密，但需要先对Archive.pax.gz进行解包，修改完后，需要重新打包回去；针对xar类型的pkg，需要先解压xar，然后解压Payload，替换或修改完数据后，重新压缩Payload，最后重新压缩xar。</li>
</ul>
<p>以上步骤是操作思路，实际分析过程中，使用工具来做一些辅助工作是可以大大提高效率的，在拿到pkg后，首先快速浏览pkg文件，简单分析出pkg的行为与可能要做的操作。推荐一款工具：<code>Suspicious Package</code>（下载地址：<a href="http://www.mothersruin.com/software/SuspiciousPackage" target="_blank" rel="external">http://www.mothersruin.com/software/SuspiciousPackage</a> ），此工具提供了快速浏览插件，安装完成后，在要操作的pkg上按下空格，就可以快速查看pkg，检索要安装的软件内容，如图所示：<br><img src="/2017/01/16/pkg/pkg_quicklook.png" alt="pkg_quicklook"><br>还可以查看要执行的脚本的内容，如图所示：<br><img src="/2017/01/16/pkg/pkg_quicklook_script.png" alt="pkg_quicklook_script"><br>对pkg有了初步了解后，找到需要操作的地方后，下一步就是提取数据内容了，<code>Suspicious Package</code>支持数据的提取，使用<code>Suspicious Package</code>打开pkg文件后，在主界面的All Files列就可以查看所有文件，可以选中要导出的文件，直接拖出到Finder，或者点击Action-&gt;Export，都可以将文件导出，操作效果如图所示：<br><img src="/2017/01/16/pkg/pkg_export.png" alt="pkg_export">  </p>
<p>除了<code>Suspicious Package</code>外，介绍另外一款更强大的工具：<code>Pacifist</code>（下载地址：<a href="http://www.charlessoft.com" target="_blank" rel="external">http://www.charlessoft.com</a> ），这款工具支持多种文件数据的提取，其中就包括pkg，如图所示：<br><img src="/2017/01/16/pkg/pacifist.png" alt="pacifist"><br>选中要提取的文件，右键选择“Extract to Custom Location…”，或者直接拖到要保存到的文件夹中，都可以将文件提取出来。</p>
<p>提取出来的文件，分析完成，修改好了后，就要打包回去了，<code>Pacifist</code>不支持将数据打包回去，如果修改的是Payload，可以使用如下命令将app目录下的myframeworktest.app打包回去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find app/* | cpio -o &gt; ./Payload</div></pre></td></tr></table></figure></p>
<p>如果是脚本文件，也可以如法炮制，最后就是将修改好的Payload或Scripts重新打包回去，可以使用执行“<code>xar cvf</code>”命令来操作，这里推荐另一款图形化工具：<code>Flat Package Editor</code>，该工具是苹果官方提供的，与<code>PackageMaker</code>一起提供给开发人员，它可以对pkg直接进行增、删、改操作，使用<code>Flat Package Editor</code>打开要操作的pkg，将修改好的Payload或Scripts拖回去，然后，点击菜单File-&gt;Save就保存成功了！如图所示：<br><img src="/2017/01/16/pkg/flat_pkg_editor.png" alt="flat_pkg_editor"><br>操作完成后，pkg就算修改好了，接下来测试安装没问题就算破解完成了。</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/16/pkg/" data-id="ciz2fqegb000fxuvjryflhsmo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-staticlib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/15/staticlib/" class="article-date">
  <time datetime="2017-01-15T00:21:06.000Z" itemprop="datePublished">2017-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/15/staticlib/">静态库的管理与文件格式分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>静态库与动态库都属于Mach-O格式的文件，动态库使用.dylib作为文件的扩展名，静态库的扩展名则是.a；在功能上，动态库通过动态链接的方式向其它程序提供接口，而静态库则是将功能代码直接编译进目标Mach-O文件中去，多个程序使用同一个动态库并不会增加目标文件的大小，使用静态库则会将每份功能代码都拷贝到目标文件中；从运行效率上来说，动态库需要在加载后做符号绑定操作，而静态库代码直接在目标程序中运行，理论上来讲，使用静态库的运行效率比动态库要高一些。</p>
<h2 id="0x1-构建静态库"><a href="#0x1-构建静态库" class="headerlink" title="0x1 构建静态库"></a>0x1 构建静态库</h2><p><code>XCode</code>提供了创建静态库的工程模板，创建静态库的方法与创建动态库几乎一样，唯一不同的是，在项目设置时，Type选择Static。还是与创建动态库一样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//mystaticlib.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface mystaticlib : NSObject</div><div class="line">-(void) hello;</div><div class="line">@end</div><div class="line"></div><div class="line">//mystaticlib.m</div><div class="line">#import &quot;mystaticlib.h&quot;</div><div class="line"></div><div class="line">@implementation mystaticlib</div><div class="line">-(void) hello &#123;</div><div class="line">    NSLog(@&quot;hello world&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>分别保存为mystaticlib.h与mystaticlib.m。然后使用xcodebuild编译会有如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ xcodebuild</div><div class="line">=== BUILD TARGET mystaticlib OF PROJECT mystaticlib WITH THE DEFAULT CONFIGURATION (Release) ===</div><div class="line"></div><div class="line">Check dependencies</div><div class="line"></div><div class="line">Write auxiliary files</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-generated-files.hmap</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-all-target-headers.hmap</div><div class="line">......</div><div class="line">/bin/mkdir -p /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.LinkFileList</div><div class="line"></div><div class="line">CompileC build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.o mystaticlib/mystaticlib.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -fmessage-length=94 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu99 -fobjc-arc -fmodules -gmodules -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/var/folders/rd/mts0362j0n92rq0z1cnmdb580000gn/C/org.llvm.clang/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -Os -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wno-deprecated-implementations -DNS_BLOCK_ASSERTIONS=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -mmacosx-version-min=10.11 -g -Wno-sign-conversion -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-generated-files.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-own-target-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-all-target-headers.hmap -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/mystaticlib-project-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/Release/include -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/DerivedSources/x86_64 -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/DerivedSources -F/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/Release -MMD -MT dependencies -MF /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.d --serialize-diagnostics /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.dia -c /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/mystaticlib/mystaticlib.m -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.o</div><div class="line"></div><div class="line">Libtool build/Release/libmystaticlib.a normal x86_64</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib</div><div class="line">    export MACOSX_DEPLOYMENT_TARGET=10.11</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static -arch_only x86_64 -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -L/Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/Release -filelist /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/mystaticlib.build/Release/mystaticlib.build/Objects-normal/x86_64/mystaticlib.LinkFileList -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mystaticlib/build/Release/libmystaticlib.a</div><div class="line"></div><div class="line">** BUILD SUCCEEDED **</div></pre></td></tr></table></figure></p>
<p>整个编译过程分为： 检查依赖（Check dependencies）、生成辅助文件（Write auxiliary files）、编译（CompileC）、打包生成库（Libtool）等几步。最终打包生成库的环节使用的<code>libtool</code>工具，该工具除了生成静态库，也可以生成动态库，上一节生成动态库使用链接器<code>ld</code>，它底层也是通过<code>libtool</code>来生成动态库的。最后，静态库不需要签名，静态库中的代码最终会被插入到目标程序中，由目标程序来签名。</p>
<h2 id="0x2-静态库格式"><a href="#0x2-静态库格式" class="headerlink" title="0x2 静态库格式"></a>0x2 静态库格式</h2><p>上一节讲到的动态库文件，它的格式就是标准的Mach-O文件，它与Mach-O可执行文件不同的是，动态库在Mach-O头部指定文件类型为<code>MH_DYLIB</code>，可执行程序为<code>MH_EXECUTE</code>。与动态库不同的是，静态库文件不是标准的Mach-O，它的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Start</div><div class="line">Symtab Header</div><div class="line">Symbol Table</div><div class="line">String Table</div><div class="line">Object Header 0</div><div class="line">ObjName0.o</div><div class="line">......</div><div class="line">Object Header N</div><div class="line">ObjNameN.o</div></pre></td></tr></table></figure></p>
<p><code>Start</code>为静态库的开始，它是一个固定长度的签名值“!&lt;arch&gt;\n”，十六进制为“21 3C 61 72 63 68 3E 0A”。</p>
<p><code>Symtab Header</code>为符号表头，描述了符号表的信息。它使用<code>symtab_header</code>结构体表示，具体定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct symtab_header &#123;</div><div class="line">	char    	name[16];       /* 名称 */</div><div class="line">	char    	timestamp[12];  /* 库创建的时间戳 */</div><div class="line">	char        userid[6];    	/* 用户id */</div><div class="line">	char    	groupid[char];  /* 组id */</div><div class="line">    uint64_t    mode;        	/* 文件访问模式 */</div><div class="line">    uint64_t    size;    		/* 符号表占总字节大小 */</div><div class="line">    uint32_t    endheader;    	/* 头结束标志 */</div><div class="line">	char    	longname[20];   /* 符号表长名 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>Symbol Table</code>为当前静态库导出的符号表。它使用<code>symbol_table</code>结构体表示，具体定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct symbol_table &#123;</div><div class="line">	uint32_t   	size;       	/* 符号表占用的总字节数 */</div><div class="line">	symbol_info syminfo[0];  	/* 符号信息，它的个数是 size / sizeof(symbol_info) */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct symbol_info &#123;</div><div class="line">	uint32_t    symnameoff;  	/* 符号名在字符串表数据中的偏移值 */</div><div class="line">	uint32_t    objheaderoff;  	/* 符号所属的目标文件的文件头在文件中的偏移值 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>String Table</code>为字符串表，该结构体存储的字符串信息供符号表使用。使用<code>string_table</code>结构体表示，具体定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct string_table &#123;</div><div class="line">	uint32_t   	size;       	/* 字符串表占用的总字节数 */</div><div class="line">	char 		data[size];  	/* 字符串数据 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>Object Header</code>为目标文件的头，描述了接下来的目标文件的信息。使用<code>object_header</code>结构体表示，具体定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct object_header &#123;</div><div class="line">	char    	name[16];       /* 名称 */</div><div class="line">	char    	timestamp[12];  /* 目标文件创建的时间戳 */</div><div class="line">	char        userid[6];    	/* 用户id */</div><div class="line">	char    	groupid[char];  /* 组id */</div><div class="line">    uint64_t    mode;        	/* 文件访问模式 */</div><div class="line">    uint64_t    size;    		/* 符号表占总字节大小 */</div><div class="line">    uint32_t    endheader;    	/* 头结束标志 */</div><div class="line">	char    	longname[20];   /* 符号表长名 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>object_header</code>结构体的布局与<code>symtab_header</code>基本一样的。</p>
<p>ObjName.o：在<code>object_header</code>结构体下面紧接着就是具体的目标文件内容了。目标文件是以.o结尾的Mach-O格式的文件，它是由编译器生成的中间文件。目标文件在它的Mach-O头部被标识为<code>MH_OBJECT</code>类型的文件。</p>
<p>最后，可以使用<code>MachOView</code>查看本小节生成的libmystaticlib.a的结构信息，效果如图所示：<br><img src="/2017/01/15/staticlib/static_lib.png" alt="static_lib"></p>
<h2 id="0x3-管理静态库"><a href="#0x3-管理静态库" class="headerlink" title="0x3 管理静态库"></a>0x3 管理静态库</h2><p>通过上一小节的分析，我们知道，静态库是由一些头信息加一系统的.o目标文件组成的。在分析静态库中的具体目标文件时，需要先将目标文件解压出来，还好目前主流的静态分析工具都支持直接读取静态库中的目标文件。但如果想要修改静态库中目标文件的内容，就需要先将目标文件取出后，修改后再替换回去，在了解了静态库文件格式后，完全可以自己动手写工具解出静态库中的目标文件，但实现上不用这么麻烦，可以使用库管理工具<code>ar</code>来完成该工作。</p>
<p>执行如下命令就可以解出上一小节生成的静态库中的目标文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ar -x ./libmystaticlib.a</div></pre></td></tr></table></figure></p>
<p>操作成功后没有输出信息，但可以发现，当前目录中已经生成了mystaticlib.o文件。在修改完目标文件后，可以将其打包进原来的库，或者直接生成新的静态库，执行以下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ar rcs libmystaticlib_new.a *.o</div></pre></td></tr></table></figure></p>
<p>同样没有输出信息，但ar已经成功将当前目录下所有的目标文件打包进了libmystaticlib_new.a中。</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/15/staticlib/" data-id="ciz2fqege000ixuvj5wmn3xzi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-dylib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/14/dylib/" class="article-date">
  <time datetime="2017-01-14T01:42:58.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/14/dylib/">dylib动态库加载过程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Windows系统的动态库是DLL文件，Linux系统是so文件，macOS系统的动态库则使用dylib文件作为动态库。<br>dylib本质上是一个Mach-O格式的文件，它与普通的Mach-O执行文件几乎使用一样的结构，只是在文件类型上一个是<code>MH_DYLIB</code>，一个是<code>MH_EXECUTE</code>。<br>在系统的/usr/lib目录下，存放了大量供系统与应用程序调用的动态库文件，使用<code>file</code>命令查看系统动态库libobjc.dylib的信息，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ file /usr/lib/libobjc.dylib</div><div class="line">/usr/lib/libobjc.dylib: Mach-O universal binary with 3 architectures</div><div class="line">/usr/lib/libobjc.dylib (for architecture i386):	Mach-O dynamically linked shared library i386</div><div class="line">/usr/lib/libobjc.dylib (for architecture x86_64):	Mach-O 64-bit dynamically linked shared library x86_64</div><div class="line">/usr/lib/libobjc.dylib (for architecture x86_64h):	Mach-O 64-bit dynamically linked shared library x86_64</div></pre></td></tr></table></figure></p>
<p>从上面的输出信息可以看出，libobjc.dylib是一个通用的二进制文件，包含了三种cpu架构的Mach-O。另外，<br>可以使用Mach-O格式文件管理工具<code>otool</code>查看dylib的信息，如查看动态库的依赖库信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ otool -L /usr/lib/libobjc.dylib</div><div class="line">/usr/lib/libobjc.dylib:</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div><div class="line">	/usr/lib/libauto.dylib (compatibility version 1.0.0, current version 1.0.0)</div><div class="line">	/usr/lib/libc++abi.dylib (compatibility version 1.0.0, current version 125.0.0)</div><div class="line">	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 120.1.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1225.0.0)</div></pre></td></tr></table></figure></p>
<h2 id="0x1-构建动态库"><a href="#0x1-构建动态库" class="headerlink" title="0x1 构建动态库"></a>0x1 构建动态库</h2><p><code>XCode</code>环境提供了创建动态库的工程模板，创建动态库的方法比较简单，在<code>XCode</code>中选择File-&gt;New-&gt;Project，在打开的工程模选择对话框中，选择标签macOS-&gt;Framework &amp; Library，在右侧选择Library，点击Next按钮，在新页面中输入项目名称mylib，Type选择Dynamic，单击Next按钮选择项目保存的路径后，工程就创建好了。接着修改工程文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//mylib.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface mylib : NSObject</div><div class="line">-(void) hello;</div><div class="line">@end</div><div class="line"></div><div class="line">//mylib.m</div><div class="line">#import &quot;mylib.h&quot;</div><div class="line"></div><div class="line">@implementation mylib</div><div class="line">-(void) hello &#123;</div><div class="line">    NSLog(@&quot;hello world&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>保存后。觇击菜单Product-&gt;Build，或者按键般的COMMAND+B键就编译成功了。命令执行完后，就会生成mylib.dylib文件。<br>XCode创建的项目是xcodeproj文件，可以使用XCode提供的工具xcodebuild在命令行下编译，在命令行下切换到工程文件所在的目录后，执行<code>xcodebuild</code>会有如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">$ xcodebuild</div><div class="line">=== BUILD TARGET mylib OF PROJECT mylib WITH THE DEFAULT CONFIGURATION (Release) ===</div><div class="line"></div><div class="line">Check dependencies</div><div class="line"></div><div class="line">Write auxiliary files</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-own-target-headers.hmap</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-all-non-framework-target-headers.hmap</div><div class="line">......</div><div class="line">/bin/mkdir -p /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.LinkFileList</div><div class="line"></div><div class="line">CompileC build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.o mylib/mylib.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -fmessage-length=94 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu99 -fobjc-arc -fmodules -gmodules -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/var/folders/rd/mts0362j0n92rq0z1cnmdb580000gn/C/org.llvm.clang/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -Os -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wno-deprecated-implementations -DNS_BLOCK_ASSERTIONS=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -mmacosx-version-min=10.11 -g -Wno-sign-conversion -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-generated-files.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-own-target-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-all-target-headers.hmap -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-project-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/include -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/DerivedSources/x86_64 -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/DerivedSources -F/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -MMD -MT dependencies -MF /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.d --serialize-diagnostics /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.dia -c /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/mylib/mylib.m -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.o</div><div class="line"></div><div class="line">Ld build/Release/libmylib.dylib normal x86_64</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export MACOSX_DEPLOYMENT_TARGET=10.11</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -L/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -F/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -filelist /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.LinkFileList -install_name /usr/local/lib/libmylib.dylib -mmacosx-version-min=10.11 -fobjc-arc -fobjc-link-runtime -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib_dependency_info.dat -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib</div><div class="line"></div><div class="line">GenerateDSYMFile build/Release/libmylib.dylib.dSYM build/Release/libmylib.dylib</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib.dSYM</div><div class="line"></div><div class="line">CodeSign build/Release/libmylib.dylib</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate</div><div class="line"></div><div class="line">Signing Identity:     &quot;-&quot;</div><div class="line"></div><div class="line">    /usr/bin/codesign --force --sign - --timestamp=none /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib</div><div class="line"></div><div class="line">** BUILD SUCCEEDED **</div></pre></td></tr></table></figure></p>
<p>从上面的日志中可以看出，整个编译过程分为：<br>检查依赖（Check dependencies）、生成辅助文件（Write auxiliary files）、编译（CompileC）、链接（Ld）、生成调试符号（GenerateDSYMFile）、代码签名（CodeSign）等几步。<br>编译代码时，使用的编译器是<code>clang</code>，这是苹果公司开发的用来替代<code>gcc</code>的现代化编译器，该编译器目前也广泛用于安卓、Linux平台上的软件开发工作；链接时使用<code>clang</code>前端传入参数给链接器<code>ld</code>，链接完成后dylib动态库就编译成功了；生成调试符号这一步主要用于生成符号的调试信息，供调试器使用；最后一步是代码签名，在没有指定签名证书的情况下，XCode默认使用的adhoc签名。</p>
<p>编译好的动态库可以被其它程序通过头文件声明隐式的调用，也可以像Linux系统那样，使用系统函数<code>dlopen()</code>、<code>dlsym()</code>手动进行调用。</p>
<h2 id="0x2-dyld"><a href="#0x2-dyld" class="headerlink" title="0x2 dyld"></a>0x2 dyld</h2><p>动态库不能直接运行，而是需要通过系统的动态链接加载器进行加载到内存后执行，动态链接加载器在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个<code>LC_LOAD_DYLINKER</code>的加载命令，此加载命令指定了dyld的路径，通常它的默认值是“/usr/lib/dyld”。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。</p>
<p>dyld加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被dyld映射到内存中，之后，当任何Mach-O映像加载时，dyld首先会检查该Mach-O映像与所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。在程序依赖的系统动态库很多的情况下，这种做法对程序启动性能是有明显提升的。</p>
<p><code>update_dyld_shared_cache</code>程序确保了dyld的共享缓存是最新的，它会扫描/var/db/dyld/shared_region_roots/目录下paths路径文件，这些paths文件包含了需要加入到共享缓存的Mach-O文件路径列表，<code>update_dyld_shared_cache()</code>会挨个将这些Mach-O文件及其依赖的dylib都加共享缓存中去。</p>
<p>共享缓存是以文件形式存放在/var/db/dyld/目录下的，生成共享缓存的<code>update_dyld_shared_cache</code>程序位于是/usr/bin/目录下，该工具会为每种系统加构生成一个缓存文件与对应的内存地址map表，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ls -l /var/db/dyld/</div><div class="line">total 1741296</div><div class="line">-rw-r--r--   1 root  wheel  333085108 Apr 22 15:02 dyld_shared_cache_i386</div><div class="line">-rw-r--r--   1 root  wheel      65378 Apr 22 15:02 dyld_shared_cache_i386.map</div><div class="line">-rw-r--r--   1 root  wheel  558259294 Apr 25 16:18 dyld_shared_cache_x86_64h</div><div class="line">-rw-r--r--   1 root  wheel     129633 Apr 25 16:18 dyld_shared_cache_x86_64h.map</div><div class="line">drwxr-xr-x  10 root  wheel        340 Apr  7 09:19 shared_region_roots</div></pre></td></tr></table></figure></p>
<p>生成的共享缓存可以使用工具<code>dyld_shared_cache_util</code>查看它的信息，该工具位于dyld源码中的 launch-cache\dyld_shared_cache_util.cpp 文件，需要自己手动编译。另外，也可以使用dyld提供的两个函数<code>dyld_shared_cache_extract_dylibs()</code>与<code>dyld_shared_cache_extract_dylibs_progress()</code>来自己解开cache文件，代码位于dyld源码的launch-cache\dsc_extractor.cpp文件中。</p>
<p><code>update_dyld_shared_cache</code>通常它只在系统的安装器安装软件与系统更新时调用，当然，可以手动运行“sudo update_dyld_shared_cache”来更新共享缓存。新的共享缓存会在系统下次启动后自动更新。</p>
<h2 id="0x3-动态库的加载过程分析"><a href="#0x3-动态库的加载过程分析" class="headerlink" title="0x3 动态库的加载过程分析"></a>0x3 动态库的加载过程分析</h2><p>dyld是苹果操作系统一个重要组成部分，而且令人兴奋的是，它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式（下载地址：<a href="http://opensource.apple.com/tarballs/dyld），了解系统加载动态库的细节。" target="_blank" rel="external">http://opensource.apple.com/tarballs/dyld），了解系统加载动态库的细节。</a></p>
<p>系统内核在加载动态库前，会加载dyld，然后调用去执行<code>__dyld_start()</code>，该函数会执行<code>dyldbootstrap::start()</code>，后者会执行<code>_main()</code>函数，dyld的加载动态库的代码就是从<code>_main()</code>开始执行的。下面以dyld源码的360.18版本为蓝本进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">uintptr_t</div><div class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,</div><div class="line">		int argc, const char* argv[], const char* envp[], const char* apple[],</div><div class="line">		uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">    //第一步，设置运行环境，处理环境变量</div><div class="line">	uintptr_t result = 0;</div><div class="line">	sMainExecutableMachHeader = mainExecutableMH;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	CRSetCrashLogMessage(&quot;dyld: launch started&quot;);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</div><div class="line"></div><div class="line">	// Pickup the pointer to the exec path.</div><div class="line">	sExecPath = _simple_getenv(apple, &quot;executable_path&quot;);</div><div class="line"></div><div class="line">	// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</div><div class="line">	if (!sExecPath) sExecPath = apple[0];</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	sExecShortName = ::strrchr(sExecPath, &apos;/&apos;);</div><div class="line">	if ( sExecShortName != NULL )</div><div class="line">		++sExecShortName;</div><div class="line">	else</div><div class="line">		sExecShortName = sExecPath;</div><div class="line">    sProcessIsRestricted = processRestricted(mainExecutableMH, &amp;ignoreEnvironmentVariables, &amp;sProcessRequiresLibraryValidation);</div><div class="line">    if ( sProcessIsRestricted ) &#123;</div><div class="line">#if SUPPORT_LC_DYLD_ENVIRONMENT</div><div class="line">		checkLoadCommandEnvironmentVariables();</div><div class="line">#endif 	</div><div class="line">		pruneEnvironmentVariables(envp, &amp;apple);</div><div class="line">		setContext(mainExecutableMH, argc, argv, envp, apple);</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		if ( !ignoreEnvironmentVariables )</div><div class="line">			checkEnvironmentVariables(envp);</div><div class="line">		defaultUninitializedFallbackPaths(envp);</div><div class="line">	&#125;</div><div class="line">	if ( sEnv.DYLD_PRINT_OPTS )</div><div class="line">		printOptions(argv);</div><div class="line">	if ( sEnv.DYLD_PRINT_ENV )</div><div class="line">		printEnvironmentVariables(envp);</div><div class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line"></div><div class="line">    //第二步，初始化主程序</div><div class="line">	try &#123;</div><div class="line">		// add dyld itself to UUID list</div><div class="line">		addDyldImageToUUIDList();</div><div class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</div><div class="line">		// instantiate ImageLoader for main executable</div><div class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</div><div class="line">		gLinkContext.mainExecutable = sMainExecutable;</div><div class="line">		gLinkContext.processIsRestricted = sProcessIsRestricted;</div><div class="line">		gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation;</div><div class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">		//第三步，加载共享缓存</div><div class="line">		checkSharedRegionDisable();</div><div class="line">	#if DYLD_SHARED_CACHE_SUPPORT</div><div class="line">		if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</div><div class="line">			mapSharedCache();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		// Now that shared cache is loaded, setup an versioned dylib overrides</div><div class="line">	#if SUPPORT_VERSIONED_PATHS</div><div class="line">		checkVersionedPaths();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		//第四步，加载插入的动态库</div><div class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</div><div class="line">			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib)</div><div class="line">				loadInsertedDylib(*lib);</div><div class="line">		&#125;</div><div class="line">		sInsertedDylibCount = sAllImages.size()-1;</div><div class="line"></div><div class="line">		//第五步，链接主程序</div><div class="line">		gLinkContext.linkingMainExecutable = true;</div><div class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</div><div class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</div><div class="line">			gLinkContext.bindFlat = true;</div><div class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//第六步，链接插入的动态库</div><div class="line">		if ( sInsertedDylibCount &gt; 0 ) &#123;</div><div class="line">			for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</div><div class="line">				ImageLoader* image = sAllImages[i+1];</div><div class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">				image-&gt;setNeverUnloadRecursive();</div><div class="line">			&#125;</div><div class="line">			// only INSERTED libraries can interpose</div><div class="line">			for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</div><div class="line">				ImageLoader* image = sAllImages[i+1];</div><div class="line">				image-&gt;registerInterposing();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</div><div class="line">		for (int i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123;</div><div class="line">			ImageLoader* image = sAllImages[i];</div><div class="line">			if ( image-&gt;inSharedCache() )</div><div class="line">				continue;</div><div class="line">			image-&gt;registerInterposing();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// apply interposing to initial set of images</div><div class="line">		for(int i=0; i &lt; sImageRoots.size(); ++i) &#123;</div><div class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        //第七步，执行弱符号绑定</div><div class="line">		gLinkContext.linkingMainExecutable = false;</div><div class="line">		// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</div><div class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</div><div class="line"></div><div class="line">        //第八步，执行初始化方法</div><div class="line">		CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;);</div><div class="line">	#if SUPPORT_OLD_CRT_INITIALIZATION</div><div class="line">		// Old way is to run initializers via a callback from crt1.o</div><div class="line">		if ( ! gRunInitializersOldWay )</div><div class="line">			initializeMainExecutable();</div><div class="line">	#else</div><div class="line">		// run all initializers</div><div class="line">		initializeMainExecutable();</div><div class="line">	#endif</div><div class="line"></div><div class="line">        //第九步，查找入口点并返回</div><div class="line">		result = (uintptr_t)sMainExecutable-&gt;getThreadPC();</div><div class="line">		if ( result != 0 ) &#123;</div><div class="line">			// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</div><div class="line">			if ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= 9) )</div><div class="line">				*startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit;</div><div class="line">			else</div><div class="line">				halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</div><div class="line">			result = (uintptr_t)sMainExecutable-&gt;getMain();</div><div class="line">			*startGlue = 0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	catch(const char* message) &#123;</div><div class="line">		syncAllImages();</div><div class="line">		halt(message);</div><div class="line">	&#125;</div><div class="line">	catch(...) &#123;</div><div class="line">		dyld::log(&quot;dyld: launch failed\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	CRSetCrashLogMessage(NULL);</div><div class="line"></div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个方法的代码比较长，将它按功能分成九个步骤进行讲解：</p>
<h4 id="第一步，设置运行环境，处理环境变量"><a href="#第一步，设置运行环境，处理环境变量" class="headerlink" title="第一步，设置运行环境，处理环境变量"></a>第一步，设置运行环境，处理环境变量</h4><p>代码在开始时候，将传入的变量<code>mainExecutableMH</code>赋值给了<code>sMainExecutableMachHeader</code>，这是一个<code>macho_header</code>类型的变量，其结构体内容就是本章前面介绍的<code>mach_header</code>结构体，表示的是当前主程序的Mach-O头部信息，有了头部信息，加载器就可以从头开始，遍历整个Mach-O文件的信息。<br>接着执行了<code>setContext()</code>，此方法设置了全局一个链接上下文，包括一些回调函数、参数与标志设置信息，代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void setContext(const macho_header* mainExecutableMH, int argc, const char* argv[], const char* envp[], const char* apple[])</div><div class="line">&#123;</div><div class="line">	gLinkContext.loadLibrary			= &amp;libraryLocator;</div><div class="line">	gLinkContext.terminationRecorder	= &amp;terminationRecorder;</div><div class="line">	gLinkContext.flatExportFinder		= &amp;flatFindExportedSymbol;</div><div class="line">	gLinkContext.coalescedExportFinder	= &amp;findCoalescedExportedSymbol;</div><div class="line">	gLinkContext.getCoalescedImages		= &amp;getCoalescedImages;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	gLinkContext.bindingOptions			= ImageLoader::kBindingNone;</div><div class="line">	gLinkContext.argc					= argc;</div><div class="line">	gLinkContext.argv					= argv;</div><div class="line">	gLinkContext.envp					= envp;</div><div class="line">	gLinkContext.apple					= apple;</div><div class="line">	gLinkContext.progname				= (argv[0] != NULL) ? basename(argv[0]) : &quot;&quot;;</div><div class="line">	gLinkContext.programVars.mh			= mainExecutableMH;</div><div class="line">	gLinkContext.programVars.NXArgcPtr	= &amp;gLinkContext.argc;</div><div class="line">	gLinkContext.programVars.NXArgvPtr	= &amp;gLinkContext.argv;</div><div class="line">	gLinkContext.programVars.environPtr	= &amp;gLinkContext.envp;</div><div class="line">	gLinkContext.programVars.__prognamePtr=&amp;gLinkContext.progname;</div><div class="line">	gLinkContext.mainExecutable			= NULL;</div><div class="line">	gLinkContext.imageSuffix			= NULL;</div><div class="line">	gLinkContext.dynamicInterposeArray	= NULL;</div><div class="line">	gLinkContext.dynamicInterposeCount	= 0;</div><div class="line">	gLinkContext.prebindUsage			= ImageLoader::kUseAllPrebinding;</div><div class="line">#if TARGET_IPHONE_SIMULATOR</div><div class="line">	gLinkContext.sharedRegionMode		= ImageLoader::kDontUseSharedRegion;</div><div class="line">#else</div><div class="line">	gLinkContext.sharedRegionMode		= ImageLoader::kUseSharedRegion;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置的回调函数都是dyld本模块实现的，如<code>loadLibrary</code>方法就是本模块的<code>libraryLocator()</code>方法，负责加载动态库。<br>在设置完这些信息后，执行<code>processRestricted()</code>方法判断进程是否受限。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">static bool processRestricted(const macho_header* mainExecutableMH, bool* ignoreEnvVars, bool* processRequiresLibraryValidation)</div><div class="line">&#123;</div><div class="line">#if TARGET_IPHONE_SIMULATOR</div><div class="line">	gLinkContext.codeSigningEnforced = true;</div><div class="line">#else</div><div class="line">    // ask kernel if code signature of program makes it restricted</div><div class="line">    uint32_t flags;</div><div class="line">	if ( csops(0, CS_OPS_STATUS, &amp;flags, sizeof(flags)) != -1 ) &#123;</div><div class="line">		if (flags &amp; CS_REQUIRE_LV)</div><div class="line">			*processRequiresLibraryValidation = true;</div><div class="line"></div><div class="line">  #if __MAC_OS_X_VERSION_MIN_REQUIRED</div><div class="line">		if ( flags &amp; CS_ENFORCEMENT ) &#123;</div><div class="line">			gLinkContext.codeSigningEnforced = true;</div><div class="line">		&#125;</div><div class="line">		if ( ((flags &amp; CS_RESTRICT) == CS_RESTRICT) &amp;&amp; (csr_check(CSR_ALLOW_TASK_FOR_PID) != 0) ) &#123;</div><div class="line">			sRestrictedReason = restrictedByEntitlements;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">  #else</div><div class="line">		if ((flags &amp; CS_ENFORCEMENT) &amp;&amp; !(flags &amp; CS_GET_TASK_ALLOW)) &#123;</div><div class="line">			*ignoreEnvVars = true;</div><div class="line">		&#125;</div><div class="line">		gLinkContext.codeSigningEnforced = true;</div><div class="line">  #endif</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">	// all processes with setuid or setgid bit set are restricted</div><div class="line">    if ( issetugid() ) &#123;</div><div class="line">		sRestrictedReason = restrictedBySetGUid;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// &lt;rdar://problem/13158444&amp;13245742&gt; Respect __RESTRICT,__restrict section for root processes</div><div class="line">	if ( hasRestrictedSegment(mainExecutableMH) ) &#123;</div><div class="line">		// existence of __RESTRICT/__restrict section make process restricted</div><div class="line">		sRestrictedReason = restrictedBySegment;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程受限会是以下三种可能：<br><code>restrictedByEntitlements</code>：在macOS系统上，在需要验证代码签名（<code>Gatekeeper</code>开启）的情况下，且<code>csr_check(CSR_ALLOW_TASK_FOR_PID)</code>返回为真（表示Rootless开启了<code>TASK_FOR_PID</code>标志）时，进程才不会受限，在macOS版本10.12系统上，默认<code>Gatekeeper</code>是开启的，并且<code>Rootless</code>是关闭了<code>CSR_ALLOW_TASK_FOR_PID</code>标志位的，这意味着，默认情况下，系统上运行的进程是受限的。<br><code>restrictedBySetGUid</code>：当进程的setuid与setgid位被设置时，进程会被设置成受限。这样做是出于安全的考虑，受限后的进程无法访问<code>DYLD_</code>开头的环境变量，一种典型的系统攻击就是针对这种情况而发生的，在macOS版本10.10系统上，一个由<code>DYLD_PRINT_TO_FILE</code>环境变量引发的系统本地提权漏洞，就是通过向<code>DYLD_PRINT_TO_FILE</code>环境变量传入拥有SUID权限的受限文件，而系统没做安全检测，而这些文件是直接有向系统创建与写入文件权限的。关于漏洞的具体细节可以参看：<a href="https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html" target="_blank" rel="external">https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html</a><br><code>restrictedBySegment</code>：段名受限。当Mach-O包含一个<code>__RESTRICT/__restrict</code>段时，进程会被设置成受限。</p>
<p>在进程受限后，执行了以下三个方法：<br><code>checkLoadCommandEnvironmentVariables()</code>:遍历Mach-O中所有的<code>LC_DYLD_ENVIRONMENT</code>加载命令，然后调用<code>processDyldEnvironmentVariable()</code>对不同的环境变量做相应的处理。<br><code>pruneEnvironmentVariables()</code>:删除进程的<code>LD_LIBRARY_PATH</code>与所有以DYLD_开头的环境变量，这样以后创建的子进程就不包含这些环境变量了。<br><code>setContext()</code>:重新设置链接上下文。这一步执行的主要目的是由于环境变量发生变化了，需要更新进程的<code>envp</code>与<code>apple</code>参数。</p>
<h4 id="第二步，初始化主程序"><a href="#第二步，初始化主程序" class="headerlink" title="第二步，初始化主程序"></a>第二步，初始化主程序</h4><p>这一步主要执行了<code>instantiateFromLoadedImage()</code>。它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</div><div class="line">&#123;</div><div class="line">	// try mach-o loader</div><div class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</div><div class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</div><div class="line">		addImage(image);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	throw &quot;main executable not a known format&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>isCompatibleMachO()</code>主要检查Mach-O的头部的<code>cputype</code>与<code>cpusubtype</code>来判断程序与当前的系统是否兼容。如果兼容接下来就调用<code>instantiateMainExecutable()</code>实例化主程序，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n&quot;,</div><div class="line">	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</div><div class="line">	bool compressed;</div><div class="line">	unsigned int segCount;</div><div class="line">	unsigned int libCount;</div><div class="line">	const linkedit_data_command* codeSigCmd;</div><div class="line">	const encryption_info_command* encryptCmd;</div><div class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</div><div class="line">	// instantiate concrete class based on content of load commands</div><div class="line">	if ( compressed )</div><div class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">	else</div><div class="line">#if SUPPORT_CLASSIC_MACHO</div><div class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">#else</div><div class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sniffLoadCommands()</code>主要获取了加载命令中的如下信息：<br><code>compressed</code>：判断Mach-O的<code>Compressed</code>还是<code>Classic</code>类型。判断的依据是Mach-O是否包含<code>LC_DYLD_INFO</code>或<code>LC_DYLD_INFO_ONLY</code>加载命令。这2个加载命令记录了Mach-O的动态库加载信息，使用结构体<code>dyld_info_command</code>表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct dyld_info_command &#123;</div><div class="line">   uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</div><div class="line">   uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */</div><div class="line">   uint32_t   rebase_off;	/* file offset to rebase info  */</div><div class="line">   uint32_t   rebase_size;	/* size of rebase info   */</div><div class="line">   uint32_t   bind_off;	/* file offset to binding info   */</div><div class="line">   uint32_t   bind_size;	/* size of binding info  */</div><div class="line">   uint32_t   weak_bind_off;	/* file offset to weak binding info   */</div><div class="line">   uint32_t   weak_bind_size;  /* size of weak binding info  */</div><div class="line">   uint32_t   lazy_bind_off;	/* file offset to lazy binding info */</div><div class="line">   uint32_t   lazy_bind_size;  /* size of lazy binding infs */</div><div class="line">   uint32_t   export_off;	/* file offset to lazy binding info */</div><div class="line">   uint32_t   export_size;	/* size of lazy binding infs */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>rebase_off</code>与大小<code>rebase_size</code>存储了rebase（重设基址）相关信息，当Mach-O加载到内存中的地址不是指定的首选地址时，就需要对当前的映像数据进行rebase（重设基址）。<br><code>bind_off</code>与<code>bind_size</code>存储了进程的符号绑定信息，当进程启动时必须绑定这些符号，典型的有<code>dyld_stub_binder</code>，该符号被dyld用来做迟绑定加载符号，一般动态库都包含该符号。<br><code>weak_bind_off</code>与<code>weak_bind_size</code>存储了进程的弱绑定符号信息。弱符号主要用于面向对旬语言中的符号重载，典型的有c++中使用new创建对象，默认情况下会绑定ibstdc++.dylib，如果检测到某个映像使用弱符号引用重载了<code>new</code>符号，dyld则会重新绑定该符号并调用重载的版本。<br><code>lazy_bind_off</code>与<code>lazy_bind_size</code>存储了进程的延迟绑定符号信息。有些符号在进程启动时不需要马上解析，它们会在第一次调用时被解析，这类符号叫延迟绑定符号（Lazy Symbol）。<br><code>export_off</code>与<code>export_size</code>存储了进程的导出符号绑定信息。导出符号可以被外部的Mach-O访问，通常动态库会导出一个或多个符号供外部使用，而可执行程序由导出<code>_main</code>与<code>_mh_execute_header</code>符号供dyld使用。</p>
<p><code>segCount</code>：段的数量。<code>sniffLoadCommands()</code>通过遍历所有的<code>LC_SEGMENT_COMMAND</code>加载命令来获取段的数量。</p>
<p><code>libCount</code>：需要加载的动态库的数量。Mach-O中包含的每一条<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>、<code>LC_REEXPORT_DYLIB</code>、<code>LC_LOAD_UPWARD_DYLIB</code>加载命令，都表示需要加载一个动态库。</p>
<p><code>codeSigCmd</code>：通过解析<code>LC_CODE_SIGNATURE</code>来获取代码签名的加载命令。</p>
<p><code>encryptCmd</code>：通过<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>来获取段加密信息。</p>
<p>获取<code>compressed</code>后，根据Mach-O是否<code>compressed</code>来分别调用<code>ImageLoaderMachOCompressed::instantiateMainExecutable()</code>与<code>ImageLoaderMachOClassic::instantiateMainExecutable()</code>。<code>ImageLoaderMachOCompressed::instantiateMainExecutable()</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// create image for main executable</div><div class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path,</div><div class="line">																		unsigned int segCount, unsigned int libCount, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);</div><div class="line"></div><div class="line">	// set slide for PIE programs</div><div class="line">	image-&gt;setSlide(slide);</div><div class="line"></div><div class="line">	// for PIE record end of program, to know where to start loading dylibs</div><div class="line">	if ( slide != 0 )</div><div class="line">		fgNextPIEDylibAddress = (uintptr_t)image-&gt;getEnd();</div><div class="line"></div><div class="line">	image-&gt;disableCoverageCheck();</div><div class="line">	image-&gt;instantiateFinish(context);</div><div class="line">	image-&gt;setMapped(context);</div><div class="line"></div><div class="line">	if ( context.verboseMapping ) &#123;</div><div class="line">		dyld::log(&quot;dyld: Main executable mapped %s\n&quot;, path);</div><div class="line">		for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</div><div class="line">			const char* name = image-&gt;segName(i);</div><div class="line">			if ( (strcmp(name, &quot;__PAGEZERO&quot;) == 0) || (strcmp(name, &quot;__UNIXSTACK&quot;) == 0)  )</div><div class="line">				dyld::log(&quot;%18s at 0x%08lX-&gt;0x%08lX\n&quot;, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</div><div class="line">			else</div><div class="line">				dyld::log(&quot;%18s at 0x%08lX-&gt;0x%08lX\n&quot;, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ImageLoaderMachOCompressed::instantiateStart()</code>使用主程序Mach-O信息构造了一个<code>ImageLoaderMachOCompressed</code>对象。<code>disableCoverageCheck()</code>禁用覆盖率检查。<code>instantiateFinish()</code>调用<code>parseLoadCmds()</code>解析其它所有的加载命令，后者会填充完<code>ImageLoaderMachOCompressed</code>的一些保护成员信息，最后调用<code>setDyldInfo()</code>设置动态库链接信息，然后调用<code>setSymbolTableInfo()</code>设置符号表信息。</p>
<p><code>instantiateFromLoadedImage()</code>调用完了<code>ImageLoaderMachO::instantiateMainExecutable()</code>后，接着调用<code>addImage()</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void addImage(ImageLoader* image)</div><div class="line">&#123;</div><div class="line">	// add to master list</div><div class="line">    allImagesLock();</div><div class="line">        sAllImages.push_back(image);</div><div class="line">    allImagesUnlock();</div><div class="line"></div><div class="line">	// update mapped ranges</div><div class="line">	uintptr_t lastSegStart = 0;</div><div class="line">	uintptr_t lastSegEnd = 0;</div><div class="line">	for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</div><div class="line">		if ( image-&gt;segUnaccessible(i) )</div><div class="line">			continue;</div><div class="line">		uintptr_t start = image-&gt;segActualLoadAddress(i);</div><div class="line">		uintptr_t end = image-&gt;segActualEndAddress(i);</div><div class="line">		if ( start == lastSegEnd ) &#123;</div><div class="line">			// two segments are contiguous, just record combined segments</div><div class="line">			lastSegEnd = end;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// non-contiguous segments, record last (if any)</div><div class="line">			if ( lastSegEnd != 0 )</div><div class="line">				addMappedRange(image, lastSegStart, lastSegEnd);</div><div class="line">			lastSegStart = start;</div><div class="line">			lastSegEnd = end;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">	if ( lastSegEnd != 0 )</div><div class="line">		addMappedRange(image, lastSegStart, lastSegEnd);</div><div class="line"></div><div class="line"></div><div class="line">	if ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=NULL) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</div><div class="line">		dyld::log(&quot;dyld: loaded: %s\n&quot;, image-&gt;getPath());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码将实例化好的主程序添加到全局主列表<code>sAllImages</code>中，最后调用<code>addMappedRange()</code>申请内存，更新主程序映像映射的内存区。做完这些工作，第二步初始化主程序就算完成了。</p>
<h4 id="第三步，加载共享缓存"><a href="#第三步，加载共享缓存" class="headerlink" title="第三步，加载共享缓存"></a>第三步，加载共享缓存</h4><p>这一步主要执行<code>mapSharedCache()</code>来映射共享缓存。该函数先通过<code>_shared_region_check_np()</code>来检查缓存是否已经映射到了共享区域了，如果已经映射了，就更新缓存的<code>slide</code>与<code>UUID</code>，然后返回。反之，判断系统是否处于安全启动模式（safe-boot mode）下，如果是就删除缓存文件并返回，正常启动的情况下，接下来调用<code>openSharedCacheFile()</code>打开缓存文件，该函数在<code>sSharedCacheDir</code>路径下，打开与系统当前cpu架构匹配的缓存文件，也就是/var/db/dyld/dyld_shared_cache_x86_64h，接着读取缓存文件的前8192字节，解析缓存头<code>dyld_cache_header</code>的信息，将解析好的缓存信息存入<code>mappings</code>变量，最后调用<code>_shared_region_map_and_slide_np()</code>完成真正的映射工作。部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">static void mapSharedCache()</div><div class="line">&#123;</div><div class="line">	uint64_t cacheBaseAddress = 0;</div><div class="line">	if ( _shared_region_check_np(&amp;cacheBaseAddress) == 0 ) &#123;</div><div class="line">		sSharedCache = (dyld_cache_header*)cacheBaseAddress;</div><div class="line">#if __x86_64__</div><div class="line">		const char* magic = (sHaswell ? ARCH_CACHE_MAGIC_H : ARCH_CACHE_MAGIC);</div><div class="line">#else</div><div class="line">		const char* magic = ARCH_CACHE_MAGIC;</div><div class="line">#endif</div><div class="line">		if ( strcmp(sSharedCache-&gt;magic, magic) != 0 ) &#123;</div><div class="line">			sSharedCache = NULL;</div><div class="line">			if ( gLinkContext.verboseMapping ) &#123;</div><div class="line">				dyld::log(&quot;dyld: existing shared cached in memory is not compatible\n&quot;);</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		const dyld_cache_header* header = sSharedCache;</div><div class="line">		......</div><div class="line">		// if cache has a uuid, copy it</div><div class="line">		if ( header-&gt;mappingOffset &gt;= 0x68 ) &#123;</div><div class="line">			memcpy(dyld::gProcessInfo-&gt;sharedCacheUUID, header-&gt;uuid, 16);</div><div class="line">		&#125;</div><div class="line">		......</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">#if __i386__ || __x86_64__</div><div class="line">		uint32_t	safeBootValue = 0;</div><div class="line">		size_t		safeBootValueSize = sizeof(safeBootValue);</div><div class="line">		if ( (sysctlbyname(&quot;kern.safeboot&quot;, &amp;safeBootValue, &amp;safeBootValueSize, NULL, 0) == 0) &amp;&amp; (safeBootValue != 0) ) &#123;</div><div class="line">			struct stat dyldCacheStatInfo;</div><div class="line">			if ( my_stat(MACOSX_DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME, &amp;dyldCacheStatInfo) == 0 ) &#123;</div><div class="line">				struct timeval bootTimeValue;</div><div class="line">				size_t bootTimeValueSize = sizeof(bootTimeValue);</div><div class="line">				if ( (sysctlbyname(&quot;kern.boottime&quot;, &amp;bootTimeValue, &amp;bootTimeValueSize, NULL, 0) == 0) &amp;&amp; (bootTimeValue.tv_sec != 0) ) &#123;</div><div class="line">					if ( dyldCacheStatInfo.st_mtime &lt; bootTimeValue.tv_sec ) &#123;</div><div class="line">						::unlink(MACOSX_DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME);</div><div class="line">						gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;</div><div class="line">						return;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">#endif</div><div class="line">		// map in shared cache to shared region</div><div class="line">		int fd = openSharedCacheFile();</div><div class="line">		if ( fd != -1 ) &#123;</div><div class="line">			uint8_t firstPages[8192];</div><div class="line">			if ( ::read(fd, firstPages, 8192) == 8192 ) &#123;</div><div class="line">				dyld_cache_header* header = (dyld_cache_header*)firstPages;</div><div class="line">		#if __x86_64__</div><div class="line">				const char* magic = (sHaswell ? ARCH_CACHE_MAGIC_H : ARCH_CACHE_MAGIC);</div><div class="line">		#else</div><div class="line">				const char* magic = ARCH_CACHE_MAGIC;</div><div class="line">		#endif</div><div class="line">				if ( strcmp(header-&gt;magic, magic) == 0 ) &#123;</div><div class="line">					const dyld_cache_mapping_info* const fileMappingsStart = (dyld_cache_mapping_info*)&amp;firstPages[header-&gt;mappingOffset];</div><div class="line">					const dyld_cache_mapping_info* const fileMappingsEnd = &amp;fileMappingsStart[header-&gt;mappingCount];</div><div class="line">					shared_file_mapping_np	mappings[header-&gt;mappingCount+1]; // add room for code-sig</div><div class="line"></div><div class="line">					......</div><div class="line"></div><div class="line">						if (_shared_region_map_and_slide_np(fd, mappingCount, mappings, codeSignatureMappingIndex, cacheSlide, slideInfo, slideInfoSize) == 0) &#123;</div><div class="line">							sSharedCache = (dyld_cache_header*)mappings[0].sfm_address;</div><div class="line">							sSharedCacheSlide = cacheSlide;</div><div class="line">							dyld::gProcessInfo-&gt;sharedCacheSlide = cacheSlide;</div><div class="line">							......</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED</div><div class="line">							throw &quot;dyld shared cache could not be mapped&quot;;</div><div class="line">#endif</div><div class="line">							if ( gLinkContext.verboseMapping )</div><div class="line">								dyld::log(&quot;dyld: shared cached file could not be mapped\n&quot;);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					if ( gLinkContext.verboseMapping )</div><div class="line">						dyld::log(&quot;dyld: shared cached file is invalid\n&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				if ( gLinkContext.verboseMapping )</div><div class="line">					dyld::log(&quot;dyld: shared cached file cannot be read\n&quot;);</div><div class="line">			&#125;</div><div class="line">			close(fd);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			if ( gLinkContext.verboseMapping )</div><div class="line">				dyld::log(&quot;dyld: shared cached file cannot be opened\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>共享缓存加载完毕后，接着进行动态库的版本化重载，这主要通过函数checkVersionedPaths()完成。该函数读取<code>DYLD_VERSIONED_LIBRARY_PATH</code>与<code>DYLD_VERSIONED_FRAMEWORK_PATH</code>环境变量，将指定版本的库比当前加载的库的版本做比较，如果当前的库版本更高的话，就使用新版本的库来替换掉旧版本的。</p>
<h4 id="第四步，加载插入的动态库"><a href="#第四步，加载插入的动态库" class="headerlink" title="第四步，加载插入的动态库"></a>第四步，加载插入的动态库</h4><p>这一步循环遍历<code>DYLD_INSERT_LIBRARIES</code>环境变量中指定的动态库列表，并调用<code>loadInsertedDylib()</code>将其加载。该函数调用<code>load()</code>完成加载工作。<code>load()</code>会调用<code>loadPhase0()</code>尝试从文件加载，<code>loadPhase0()</code>会向下调用下一层phase来查找动态库的路径，直到<code>loadPhase6()</code>，查找的顺序为<code>DYLD_ROOT_PATH</code>-&gt;<code>LD_LIBRARY_PATH</code>-&gt;<code>DYLD_FRAMEWORK_PATH</code>-&gt;原始路径-&gt;<code>DYLD_FALLBACK_LIBRARY_PATH</code>，找到后调用<code>ImageLoaderMachO::instantiateFromFile()</code>来实例化一个<code>ImageLoader</code>，之后调用<code>checkandAddImage()</code>验证映像并将其加入到全局映像列表中。如果<code>loadPhase0()</code>返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用<code>ImageLoaderMachO::instantiateFromCache()</code>从缓存中加载，否则就抛出没找到映像的异常。部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">ImageLoader* load(const char* path, const LoadContext&amp; context)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if ( context.useSearchPaths &amp;&amp; ( gLinkContext.imageSuffix != NULL) ) &#123;</div><div class="line">		if ( realpath(path, realPath) != NULL )</div><div class="line">			path = realPath;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, NULL);</div><div class="line">	if ( image != NULL ) &#123;</div><div class="line">		CRSetCrashLogMessage2(NULL);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">	image = loadPhase0(path, orgPath, context, &amp;exceptions);</div><div class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; DYLD_SHARED_CACHE_SUPPORT &amp;&amp; !TARGET_IPHONE_SIMULATOR</div><div class="line">	// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</div><div class="line">	if ( (image == NULL) &amp;&amp; cacheablePath(path) &amp;&amp; !context.dontLoad ) &#123;</div><div class="line">		......</div><div class="line">		if ( (myerr == ENOENT) || (myerr == 0) )</div><div class="line">		&#123;</div><div class="line">			const macho_header* mhInCache;</div><div class="line">			const char*			pathInCache;</div><div class="line">			long				slideInCache;</div><div class="line">			if ( findInSharedCacheImage(resolvedPath, false, NULL, &amp;mhInCache, &amp;pathInCache, &amp;slideInCache) ) &#123;</div><div class="line">				struct stat stat_buf;</div><div class="line">				bzero(&amp;stat_buf, sizeof(stat_buf));</div><div class="line">				try &#123;</div><div class="line">					image = ImageLoaderMachO::instantiateFromCache(mhInCache, pathInCache, slideInCache, stat_buf, gLinkContext);</div><div class="line">					image = checkandAddImage(image, context);</div><div class="line">				&#125;</div><div class="line">				catch (...) &#123;</div><div class="line">					image = NULL;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line">    ......</div><div class="line">	else &#123;</div><div class="line">		const char* msgStart = &quot;no suitable image found.  Did find:&quot;;</div><div class="line">		......</div><div class="line">		throw (const char*)fullMsg;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第五步，链接主程序"><a href="#第五步，链接主程序" class="headerlink" title="第五步，链接主程序"></a>第五步，链接主程序</h4><p>这一步执行<code>link()</code>完成主程序的链接操作。该函数调用了<code>ImageLoader</code>自身的<code>link()</code>函数，主要的目的是将实例化的主程序的动态数据进行修正，达到让进程可用的目的，典型的就是主程序中的符号表修正操作，它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	context.clearAllDepths();</div><div class="line">	this-&gt;recursiveUpdateDepth(context.imageCount());</div><div class="line"></div><div class="line"> 	this-&gt;recursiveRebase(context);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line"> 	this-&gt;recursiveBind(context, forceLazysBound, neverUnload);</div><div class="line"></div><div class="line">	if ( !context.linkingMainExecutable )</div><div class="line">		this-&gt;weakBind(context);	//现在是链接主程序，这里现在不会执行</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	std::vector&lt;DOFInfo&gt; dofs;</div><div class="line">	this-&gt;recursiveGetDOFSections(context, dofs);</div><div class="line">	context.registerDOFs(dofs);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123;</div><div class="line">		this-&gt;recursiveApplyInterposing(context);	//现在是链接主程序，这里现在不会执行</div><div class="line">	&#125;</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>recursiveLoadLibraries()</code>采用递归的方式来加载程序依赖的动态库，加载的方法是调用<code>context</code>的<code>loadLibrary</code>指针方法，该方法在前面看到过，是<code>setContext()</code>设置的<code>libraryLocator()</code>，该函数只是调用了<code>load()</code>来完成加载，<code>load()</code>加载动态库的过程在上一步已经分析过了。</p>
<p>接着调用<code>recursiveUpdateDepth()</code>对映像及其依赖库按列表方式进行排序。<code>recursiveRebase()</code>则对映像完成递归rebase操作，该函数只是调用了虚函数<code>doRebase()</code>，<code>doRebase()</code>被<code>ImageLoaderMachO</code>重载，实际只是将代码段设置成可写后调用了<code>rebase()</code>，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>rebase_off</code>与<code>rebase_size</code>来确定需要rebase的数据偏移与大小，然后挨个修正它们的地址信息。</p>
<p><code>recursiveBind()</code>完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，它的核心是调用了<code>doBind()</code>，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>bind_off</code>与<code>bind_size</code>来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用<code>bindAt()</code>函数，它主要通过调用<code>resolve()</code>解析完符号表后，调用<code>bindLocation()</code>完成最终的绑定操作，需要绑定的符号信息有三种：<br><code>BIND_TYPE_POINTER</code>：需要绑定的是一个指针。直接将计算好的新值屿值即可。<br><code>BIND_TYPE_TEXT_ABSOLUTE32</code>：一个32位的值。取计算的值的低32位赋值过去。<br><code>BIND_TYPE_TEXT_PCREL32</code>：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。</p>
<p><code>recursiveGetDOFSections</code>()与<code>registerDOFs()</code>主要注册程序的DOF节区，供<code>dtrace</code>使用。</p>
<h4 id="第六步，链接插入的动态库"><a href="#第六步，链接插入的动态库" class="headerlink" title="第六步，链接插入的动态库"></a>第六步，链接插入的动态库</h4><p>链接插入的动态库与链接主程序一样，都是使用的<code>link()</code>,插入的动态库列表是前面调用<code>addImage()</code>保存到<code>sAllImages</code>中的，之后，循环获取每一个动态库的<code>ImageLoader</code>，调用<code>link()</code>对其进行链接，注意：<code>sAllImages</code>中保存的第一项是主程序的映像。接下来调用每个映像的<code>registerInterposing()</code>方法来注册动态库插入与调用<code>applyInterposing()</code>应用插入操作。<code>registerInterposing()</code>查找<code>__DATA</code>段的<code>__interpose</code>节区，找到需要应用插入操作（也可以叫作符号地址替换）的数据，然后做一些检查后，将要替换的符号与被替换的符号信息存入<code>fgInterposingTuples</code>列表中，供以后具体符号替换时查询。<code>applyInterposing()</code>调用了虚方法<code>doInterpose()</code>来做符号替换操作，在<code>ImageLoaderMachOCompressed</code>中实际是调用了<code>eachBind()</code>与<code>eachLazyBind()</code>分别对常规的符号与延迟加载的符号进行应用插入操作，具体使用的是<code>interposeAt()</code>，该方法调用<code>interposedAddress()</code>在<code>fgInterposingTuples</code>中查找要替换的符号地址，找到后然后进行最终的符号地址替换。</p>
<h4 id="第七步，执行弱符号绑定"><a href="#第七步，执行弱符号绑定" class="headerlink" title="第七步，执行弱符号绑定"></a>第七步，执行弱符号绑定</h4><p><code>weakBind()</code>函数执行弱符号绑定。首先通过调用<code>context</code>的<code>getCoalescedImages()</code>将<code>sAllImages</code>中所有含有弱符号的映像合并成一个列表，合并完后调用<code>initializeCoalIterator()</code>对映像进行排序，排序完成后调用<code>incrementCoalIterator()</code>收集需要进行绑定的弱符号，后者是一个虚函数，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>weak_bind_off</code>与<code>weak_bind_size</code>来确定弱符号的数据偏移与大小，然后挨个计算它们的地址信息。之后调用<code>getAddressCoalIterator()</code>，按照映像的加载顺序在导出表中查找符号的地址，找到后调用<code>updateUsesCoalIterator()</code>执行最终的绑定操作，执行绑定的是<code>bindLocation()</code>，前面有讲过，此处不再赘述。</p>
<h4 id="第八步，执行初始化方法"><a href="#第八步，执行初始化方法" class="headerlink" title="第八步，执行初始化方法"></a>第八步，执行初始化方法</h4><p>执行初始化的方法是<code>initializeMainExecutable()</code>。该函数主要执行<code>runInitializers()</code>，后者调用了<code>ImageLoader</code>的<code>runInitializers()</code>方法，最终迭代执行了<code>ImageLoaderMachO</code>的<code>doInitialization()</code>方法，后者主要调用<code>doImageInit()</code>与<code>doModInitFunctions()</code>执行映像与模块中设置为init的函数与静态初始化方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	CRSetCrashLogMessage2(this-&gt;getPath());</div><div class="line"></div><div class="line">	doImageInit(context);</div><div class="line">	doModInitFunctions(context);</div><div class="line"></div><div class="line">	CRSetCrashLogMessage2(NULL);</div><div class="line"></div><div class="line">	return (fHasDashInit || fHasInitializers);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第九步，查找入口点并返回"><a href="#第九步，查找入口点并返回" class="headerlink" title="第九步，查找入口点并返回"></a>第九步，查找入口点并返回</h4><p>这一步调用主程序映像的<code>getThreadPC()</code>函数来查找主程序的<code>LC_MAIN</code>加载命令获取程序的入口点，没找到就调用<code>getMain()</code>到<code>LC_UNIXTHREAD</code>加载命令中去找，找到后就跳到入口点指定的地址并返回了。</p>
<p>到这里，dyld整个加载动态库的过程就算完成了。</p>
<p>另外再讨论下延迟符号加载的技术细节。在所有拥有延迟加载符号的Mach-O文件里，它的符号表中一定有一个<code>dyld_stub_helper</code>符号，它是延迟符号加载的关键！延迟绑定符号的修正工作就是由它完成的。绑定符号信息可以使用<code>XCode</code>提供的命令行工具<code>dyldinfo</code>来查看，执行以下命令可以查看<code>python</code>的绑定信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">xcrun dyldinfo -bind /usr/bin/python</div><div class="line">for arch i386:</div><div class="line">bind information:</div><div class="line">segment section          address        type    addend dylib            symbol</div><div class="line">__DATA  __cfstring       0x000040F0    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __cfstring       0x00004100    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __nl_symbol_ptr  0x00004010    pointer      0 CoreFoundation   _kCFAllocatorNull</div><div class="line">__DATA  __nl_symbol_ptr  0x00004008    pointer      0 libSystem        ___stack_chk_guard</div><div class="line">__DATA  __nl_symbol_ptr  0x0000400C    pointer      0 libSystem        _environ</div><div class="line">__DATA  __nl_symbol_ptr  0x00004000    pointer      0 libSystem        dyld_stub_binder</div><div class="line">bind information:</div><div class="line">segment section          address        type    addend dylib            symbol</div><div class="line">__DATA  __cfstring       0x1000031D8    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __cfstring       0x1000031F8    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __got            0x100003010    pointer      0 CoreFoundation   _kCFAllocatorNull</div><div class="line">__DATA  __got            0x100003000    pointer      0 libSystem        ___stack_chk_guard</div><div class="line">__DATA  __got            0x100003008    pointer      0 libSystem        _environ</div><div class="line">__DATA  __nl_symbol_ptr  0x100003018    pointer      0 libSystem        dyld_stub_binder</div></pre></td></tr></table></figure></p>
<p>所有的延迟绑定符号都存储在<code>_TEXT</code>段的<code>stubs</code>节区（桩节区），编译器在生成代码时创建的符号调用就生成在此节区中，该节区被称为“桩”节区，桩只是一小段临时使用的指令，在<code>stubs</code>中只是一条<code>jmp</code>跳转指令，跳转的地址位于<code>__DATA</code>段<code>__la_symbol_ptr</code>节区中，指向的是一段代码，类似于如下的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">push xxx</div><div class="line">jmp yyy</div></pre></td></tr></table></figure></p>
<p>其中xxx是符号在动态链接信息中延迟绑定符号数据的偏移值，yyy则是跳转到<code>_TEXT</code>段的<code>stub_helper</code>节区头部，此处的代码通常为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lea        r11, qword [ds:zzz]</div><div class="line">push       r11</div><div class="line">jmp        qword [ds:imp___nl_symbol_ptr_dyld_stub_binder]</div></pre></td></tr></table></figure></p>
<p><code>jmp</code>跳转的地址是<code>__DATA</code>段中<code>__nl_symbol_ptr</code>节区，指向的是符号<code>dyld_stub_binder()</code>，该函数由dyld导出，实现位于dyld源码的“dyld_stub_binder.s”文件中，它调用<code>dyld::fastBindLazySymbol()</code>来绑定延迟加载的符号，后者是一个虚函数，实际调用<code>ImageLoaderMachOCompressed</code>的<code>doBindFastLazySymbol()</code>，后者调用<code>bindAt()</code>解析并返回正确的符号地址，<code>dyld_stub_binder()</code>在最后跳转到符号地址去执行。这一步完成后，<code>__DATA</code>段<code>__la_symbol_ptr</code>节区中存储的符号地址就是修正后的地址，下一次调用该符号时，就直接跳转到真正的符号地址去执行，而不用<code>dyld_stub_binder()</code>来重新解析该符号了，</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/14/dylib/" data-id="ciz2fqef80001xuvjpofbkzmb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-macho" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/macho/" class="article-date">
  <time datetime="2017-01-13T01:03:08.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/macho/">Mach-O文件格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x1-通用二进制格式"><a href="#0x1-通用二进制格式" class="headerlink" title="0x1 通用二进制格式"></a>0x1 通用二进制格式</h2><p>虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。</p>
<p>macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。<br>又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同CPU架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行<code>file</code>命令可以查看它的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ file /usr/bin/python</div><div class="line">/usr/bin/python: Mach-O universal binary with 2 architectures</div><div class="line">/usr/bin/python (for architecture x86_64):	Mach-O 64-bit executable x86_64</div><div class="line">/usr/bin/python (for architecture i386):	Mach-O executable i386</div></pre></td></tr></table></figure></p>
<p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。例如提取<code>python</code>中x86_64版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>删除x86版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>或者直接瘦身为x86_64版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>通用二进制的“通用”不止针对可以直接运行的可执行程序，系统中的动态库dylib、静态库.a文件以及框架等都可以是通用二进制文件，对它们也可以同样使用<code>lipo</code>命令来进行管理。<br>下来看一下通用二进制的文件格式。安装好macOS程序开发的SDK后，或者在xnu的内核源码中，都可以在&lt;mach-o/fat.h&gt;文件中找到通用二进制文件格式的声明。从文件命名上看，将通用二进制称为胖二进制更方便一些。胖二进制头部结构<code>fat_header</code>定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define FAT_MAGIC	0xcafebabe</div><div class="line">#define FAT_CIGAM	0xbebafeca	/* NXSwapLong(FAT_MAGIC) */</div><div class="line"></div><div class="line">struct fat_header &#123;</div><div class="line">	uint32_t	magic;		/* FAT_MAGIC */</div><div class="line">	uint32_t	nfat_arch;	/* number of structs that follow */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段被定义为常量<code>FAT_MAGIC</code>，它的取值是固定的0xcafebabe，表示这是一个通用的二进制文件。<code>nfat_arch</code>字段指明了通用二进制中包含多少个Mach-O文件。<br>每个通用二进制架构信息都使用<code>fat_arch</code>结构表示，在<code>fat_header</code>结构体之后，紧接着的是一个或多个连续的<code>fat_arch</code>结构体，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct fat_arch &#123;</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier (int) */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier (int) */</div><div class="line">	uint32_t	offset;		/* file offset to this object file */</div><div class="line">	uint32_t	size;		/* size of this object file */</div><div class="line">	uint32_t	align;		/* alignment as a power of 2 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cputype</code>指定了具体的cpu类型，它的类型是<code>cpu_type_t</code>，定义位于mach/machine.h中。<code>cpu</code>的常用类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define CPU_TYPE_X86		((cpu_type_t) 7)</div><div class="line">#define CPU_TYPE_I386		CPU_TYPE_X86		</div><div class="line">#define	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC98000	((cpu_type_t) 10)</div><div class="line">#define CPU_TYPE_HPPA           ((cpu_type_t) 11)</div><div class="line">#define CPU_TYPE_ARM		((cpu_type_t) 12)</div><div class="line">#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC88000	((cpu_type_t) 13)</div><div class="line">#define CPU_TYPE_SPARC		((cpu_type_t) 14)</div><div class="line">#define CPU_TYPE_I860		((cpu_type_t) 15)</div><div class="line">#define CPU_TYPE_POWERPC		((cpu_type_t) 18)</div><div class="line">#define CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64</div></pre></td></tr></table></figure></p>
<p>macOS平台上的CPU类型一般为<code>CPU_TYPE_X86_64</code>。</p>
<p><code>cpusubtype</code>指定了cpu的子类型。它的类型是<code>cpu_subtype_t</code>。cpu子类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define CPU_SUBTYPE_MASK	0xff000000</div><div class="line">#define CPU_SUBTYPE_LIB64	0x80000000</div><div class="line">#define CPU_SUBTYPE_X86_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_64_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_ARCH1		((cpu_subtype_t)4)</div><div class="line">#define CPU_SUBTYPE_X86_64_H		((cpu_subtype_t)8)</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>cpu子类型一般<code>CPU_SUBTYPE_LIB64</code>与<code>CPU_SUBTYPE_X86_64_ALL</code>比较常见。</p>
<p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值。<code>size</code>字段指明了数据的大小。</p>
<p><code>align</code>字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。</p>
<p>可以使用<code>otool</code>工具打印本机安装的<code>python</code>程序的<code>fat_header</code>信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">otool -f -V /usr/bin/python</div><div class="line">Fat headers</div><div class="line">fat_magic FAT_MAGIC</div><div class="line">nfat_arch 2</div><div class="line">architecture i386</div><div class="line">    cputype CPU_TYPE_I386</div><div class="line">    cpusubtype CPU_SUBTYPE_I386_ALL</div><div class="line">    capabilities 0x0</div><div class="line">    offset 4096</div><div class="line">    size 29632</div><div class="line">    align 2^12 (4096)</div><div class="line">architecture x86_64</div><div class="line">    cputype CPU_TYPE_X86_64</div><div class="line">    cpusubtype CPU_SUBTYPE_X86_64_ALL</div><div class="line">    capabilities CPU_SUBTYPE_LIB64</div><div class="line">    offset 36864</div><div class="line">    size 29872</div><div class="line">    align 2^12 (4096)</div></pre></td></tr></table></figure></p>
<p>如果你是UNIX的使用者，经常使用GNU里面<code>binutils</code>提供的<code>objdump</code>查看可执行文件信息的话，在macOS上可以使用它的移植版本<code>gobjdump</code>，使用<code>HomeBrew</code>运行以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install binutils</div></pre></td></tr></table></figure></p>
<p>完装完成后，执行下面的命令也可以查看<code>python</code>程序的<code>fat_header</code>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ gobjdump -f /usr/bin/python</div><div class="line">In archive /usr/bin/python:</div><div class="line"></div><div class="line">i386:     file format mach-o-i386</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00001be0</div><div class="line"></div><div class="line">i386:x86-64:     file format mach-o-x86-64</div><div class="line">architecture: i386:x86-64, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x0000000100000e20</div></pre></td></tr></table></figure></p>
<p>在<code>fat_arch</code>结构体往下就是具体的Mach-O文件格式了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h2 id="0x2-Mach-O文件格式简介"><a href="#0x2-Mach-O文件格式简介" class="headerlink" title="0x2 Mach-O文件格式简介"></a>0x2 Mach-O文件格式简介</h2><p>Mach-O（Mach Object File Format）描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式，有助于了解苹果底层软件运行机制，更好的掌握<code>dyld</code>加载Mach-O的步骤，为自己动手开发Mach-O相关的加解密工具打下基础。</p>
<p>一个典型的Mach-O文件格式如图所示：<br><img src="/2017/01/13/macho/mach-o.png" alt="mach-o"><br>通过上图，可以看出Mach-O主要由以下三部分组成：</p>
<ul>
<li>Mach-O头部（mach header）。描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</li>
<li>加载命令（load command）。描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</li>
<li>Data。Data中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个Section，它们存放了具体的数据与代码。</li>
</ul>
<h2 id="0x3-Mach-O头部"><a href="#0x3-Mach-O头部" class="headerlink" title="0x3 Mach-O头部"></a>0x3 Mach-O头部</h2><p>与Mach-O文件格式有关的结构体，都可以直接或间接的在”mach-o/loader.h“文件中找到。<br>针对32位与64位架构的cpu，分别使用了<code>mach_header</code>与<code>mach_header_64</code>结构体来描述Mach-O头部。<br><code>mach_header</code>结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct mach_header &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样，表示Mach-O文件的魔数值，对于32位架构的程序来说，它的取值是<code>MH_MAGIC</code>，固定为0xfeedface。<br><code>cputype</code>与<code>cpusubtype</code>字段与<code>fat_header</code>结构体中的含义完全相同。<br><code>filetype</code>字段表示Mach-O的具体文件类型。它的取值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define	MH_OBJECT	0x1		/* relocatable object file */</div><div class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */</div><div class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</div><div class="line">#define	MH_CORE		0x4		/* core file */</div><div class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</div><div class="line">#define	MH_DYLIB	0x6		/* dynamically bound shared library */</div><div class="line">#define	MH_DYLINKER	0x7		/* dynamic link editor */</div><div class="line">#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */</div><div class="line">#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */</div><div class="line">					/*  linking only, no section contents */</div><div class="line">#define	MH_DSYM		0xa		/* companion file with only debug sections */</div><div class="line">#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */</div></pre></td></tr></table></figure></p>
<p>这里主要关注<code>MH_EXECUTE</code>、<code>MH_DYLIB</code>与<code>MH_DYLIB</code>这3个文件格式。</p>
<p>接下来的<code>ncmds</code>指明了Mach-O文件中加载命令（load commands）的数量。</p>
<p><code>sizeofcmds</code>字段指明了Mach-O文件加载命令（load commands）所占的总字节大小。</p>
<p><code>flags</code>字段表示文件标志，它是一个含有一组位标志的整数，指明了Mach-O文件的一些标志信息。可用的值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define	MH_NOUNDEFS	0x1</div><div class="line">#define	MH_INCRLINK	0x2</div><div class="line">#define MH_DYLDLINK	0x4</div><div class="line">#define MH_LAZY_INIT 0x40</div><div class="line">#define MH_TWOLEVEL	0x80</div><div class="line">#define MH_PIE 0x200000</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>针对64位Mach-O的<code>mach_header_64</code>结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct mach_header_64 &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">	uint32_t	reserved;	/* reserved */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>相比<code>mach_header</code>，它多出了一个<code>reserved</code>字段，目前它的取值系统保留。<code>mach_header_64</code>结构体中的字段与<code>mach_header</code>中的基本一致，除了<code>magic</code>字段的取值是<code>MH_MAGIC_64</code>，固定的值为0xfeedfacf。<br>学习Mach-o文件格式时，可以使用辅助工具查看具体的文件结构，这样效果更加直观。<br>下图是<code>MachOView</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/mach_header.png" alt="mach_header"><br>下图是<code>010 Editor</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/010_editor.png" alt="010_editor"><br>下图是<code>Synalyze It!</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/synalyze_it.png" alt="synalyze_it"><br>这三款工具对于学习Mach-O文件格式都是非常有帮助的，读者在实际分析时可以多多使用。</p>
<h2 id="0x4-加载命令"><a href="#0x4-加载命令" class="headerlink" title="0x4 加载命令"></a>0x4 加载命令</h2><p>在<code>mach_header</code>之后的是Load Command加载命令，这些加载命令在Mach-O文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">	uint32_t cmd;		/* type of load command */</div><div class="line">	uint32_t cmdsize;	/* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此结构对应的成员只有2个：<code>cmd</code>字段代表当前加载命令的类型。<code>cmdsize</code>字段代表当前加载命令的大小。<br>cmd的类型不同，所代表的加载命令的类型就不同，它的结构体也会有所不一样，对于不同类型的加载命令，它们都会在<code>load_command</code>结构体后面加上一个或多个字段来表示自己特定的结构体信息。</p>
<p>macOS系统在进化的过程中，加载命令算是比较频繁被更新的一个数据结构体，截止到macOS 10.12系统，加载命令的类型cmd的取值共有48种。它们的部分定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */</div><div class="line">#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */</div><div class="line">#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */</div><div class="line">#define	LC_THREAD	0x4	/* thread */</div><div class="line">#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */</div><div class="line">#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */</div><div class="line">#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */</div><div class="line">#define	LC_IDENT	0x8	/* object identification info (obsolete) */</div><div class="line">#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */</div><div class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</div><div class="line">#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */</div><div class="line">#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */</div><div class="line">......</div><div class="line">#define	LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</div><div class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</div><div class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</div><div class="line">#ifndef __OPEN_SOURCE__</div><div class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</div><div class="line">#endif /* __OPEN_SOURCE__ */</div><div class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</div></pre></td></tr></table></figure></p>
<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_SEGMENT</code>、<code>LC_LOAD_DYLINKER</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等。</p>
<p><code>LC_SEGMENT</code>：表示这是一个段加载命令，需要将它加载到对应的进程空间上去。段加载命令将在下一小节进行讨论。</p>
<p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用<code>dylib_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct dylib_command &#123;</div><div class="line">	uint32_t	cmd;		/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,LC_REEXPORT_DYLIB */</div><div class="line">	uint32_t	cmdsize;	/* includes pathname string */</div><div class="line">	struct dylib dylib;		/* the library identification */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当cmd类型时<code>LC_ID_DYLIB</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>与<code>LC_REEXPORT_DYLIB</code>时，统一使用<code>dylib_command</code>结构体表示。<br>它使用dylib结构体来存储要加载的动态库的具体信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct dylib &#123;</div><div class="line">    union lc_str  name;			/* library&apos;s path name */</div><div class="line">    uint32_t timestamp;			/* library&apos;s build time stamp */</div><div class="line">    uint32_t current_version;		/* library&apos;s current version number */</div><div class="line">    uint32_t compatibility_version;	/* library&apos;s compatibility vers number*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>name</code>字段是动态库的完整路径，动态链接器在加载动态库时，通用此路径来进行加载它。<br><code>timestamp</code>字段描述了动态库构建时的时间戳。<code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号。</p>
<p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数<code>main()</code>的位置。它使用<code>entry_point_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct entry_point_command &#123;</div><div class="line">    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */</div><div class="line">    uint32_t  cmdsize;	/* 24 */</div><div class="line">    uint64_t  entryoff;	/* file (__TEXT) offset of main() */</div><div class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>entryoff</code>字段中就指定了<code>main()</code>函数的文件偏移。<code>stacksize</code>指定了初始的堆栈大小。</p>
<h2 id="0x5-LC-CODE-SIGNATURE与代码签名过程分析"><a href="#0x5-LC-CODE-SIGNATURE与代码签名过程分析" class="headerlink" title="0x5 LC_CODE_SIGNATURE与代码签名过程分析"></a>0x5 LC_CODE_SIGNATURE与代码签名过程分析</h2><p><code>LC_CODE_SIGNATURE</code>：代码签名加载命令。描述了Mach-O的代码签名信息，它属于链接信息，使用<code>linkedit_data_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct linkedit_data_command &#123;</div><div class="line">    uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,</div><div class="line">                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,</div><div class="line">				   LC_DYLIB_CODE_SIGN_DRS or</div><div class="line">				   LC_LINKER_OPTIMIZATION_HINT. */</div><div class="line">    uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */</div><div class="line">    uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */</div><div class="line">    uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>dataoff</code>字段指明了相对于<code>__LINKEDIT</code>段的文件偏移位置，<code>datasize</code>字段指明了数据的大小。<br>由于<code>dataoff</code>与<code>datasize</code>分别指明了代码签名的位置与大小，那么笔者在此提个问：如何删除Mach-O中包含的代码签名信息？</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的“bsd/sys/codesign.h”文件中找到。整个代码签名部分的头部使用一个<code>CS_SuperBlob</code>结构体定义，它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_SuperBlob &#123;</div><div class="line">	uint32_t magic;					/* magic number */</div><div class="line">	uint32_t length;				/* total length of SuperBlob */</div><div class="line">	uint32_t count;					/* number of index entries following */</div><div class="line">	CS_BlobIndex index[];			/* (count) entries */</div><div class="line">	/* followed by Blobs in no particular order as indicated by offsets in index */</div><div class="line">&#125; CS_SuperBlob;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段指明了Blob的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">	CSMAGIC_REQUIREMENT = 0xfade0c00,		/* single Requirement blob */</div><div class="line">	CSMAGIC_REQUIREMENTS = 0xfade0c01,		/* Requirements vector (internal requirements) */</div><div class="line">	CSMAGIC_CODEDIRECTORY = 0xfade0c02,		/* CodeDirectory blob */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02,	/* XXX */</div><div class="line">	CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,	/* embedded entitlements */</div><div class="line">	CSMAGIC_DETACHED_SIGNATURE = 0xfade0cc1, /* multi-arch collection of embedded signatures */</div><div class="line">	CSMAGIC_BLOBWRAPPER = 0xfade0b01,	/* CMS Signature, among other things */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第一个Blob来说，它的值必定是<code>CSMAGIC_EMBEDDED_SIGNATURE</code>，表示代码签名采用的嵌入式的签名信息。<br><code>length</code>字段指明了整个SuperBlob的大小，其中包含马上的介绍的CodeDirectory、Requirement、Entitlement的大小。<br><code>count</code>字段指明了接下来会有多少个子条目。<br>从<code>index</code>开始，就是每一个字条目的索引了，它的结构是<code>CS_BlobIndex</code>，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct __BlobIndex &#123;</div><div class="line">	uint32_t type;					/* type of entry */</div><div class="line">	uint32_t offset;				/* offset of entry */</div><div class="line">&#125; CS_BlobIndex;</div></pre></td></tr></table></figure></p>
<p><code>type</code>指明了子条目的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSSLOT_CODEDIRECTORY = 0,				/* slot index for CodeDirectory */</div><div class="line">CSSLOT_INFOSLOT = 1,</div><div class="line">CSSLOT_REQUIREMENTS = 2,</div><div class="line">CSSLOT_RESOURCEDIR = 3,</div><div class="line">CSSLOT_APPLICATION = 4,</div><div class="line">CSSLOT_ENTITLEMENTS = 5,</div><div class="line">CSSLOT_SIGNATURESLOT = 0x10000,			/* CMS Signature */</div></pre></td></tr></table></figure></p>
<p><code>offset</code>字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>通常，签名后的程序，签名数据的第一个子条目指向的是一个<code>type</code>为<code>CSSLOT_CODEDIRECTORY</code>的结构，它是一个<code>CS_CodeDirectory</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct __CodeDirectory &#123;</div><div class="line">	uint32_t magic;					/* magic number (CSMAGIC_CODEDIRECTORY) */</div><div class="line">	uint32_t length;				/* total length of CodeDirectory blob */</div><div class="line">	uint32_t version;				/* compatibility version */</div><div class="line">	uint32_t flags;					/* setup and mode flags */</div><div class="line">	uint32_t hashOffset;			/* offset of hash slot element at index zero */</div><div class="line">	uint32_t identOffset;			/* offset of identifier string */</div><div class="line">	uint32_t nSpecialSlots;			/* number of special hash slots */</div><div class="line">	uint32_t nCodeSlots;			/* number of ordinary (code) hash slots */</div><div class="line">	uint32_t codeLimit;				/* limit to main image signature range */</div><div class="line">	uint8_t hashSize;				/* size of each hash in bytes */</div><div class="line">	uint8_t hashType;				/* type of hash (cdHashType* constants) */</div><div class="line">	uint8_t platform;				/* platform identifier; zero if not platform binary */</div><div class="line">	uint8_t	pageSize;				/* log2(page size in bytes); 0 =&gt; infinite */</div><div class="line">	uint32_t spare2;				/* unused (must be zero) */</div><div class="line">	/* Version 0x20100 */</div><div class="line">	uint32_t scatterOffset;				/* offset of optional scatter vector */</div><div class="line">	/* Version 0x20200 */</div><div class="line">	uint32_t teamOffset;				/* offset of optional team identifier */</div><div class="line">	/* followed by dynamic content as located by offset fields above */</div><div class="line">&#125; CS_CodeDirectory;</div></pre></td></tr></table></figure></p>
<p>该结构体数据字段较多，此处只关注与签名相关的字段。<code>hashOffset</code>指明了Hash数据的文件相对偏移，注意是相对于当前结构体<code>CS_CodeDirectory</code>，<code>hashType</code>与<code>hashSize</code>指明了代码签名时使用的算法与每一项签名数据的长度，目前macOS使用的签名算法是SHA-1，长度为20字节。<br><code>nSpecialSlots</code>与<code>nCodeSlots</code>指定的代码签名数据条目的个数，前者是针对代码签名中所有的Blob，后者针对程序文件内容。<code>codesign</code>程序在对程序进行签名时，会对SuperBlob中每个子条目进行签名，即对Blob的内容调用SHA-1算法取Hash值，<code>nSpecialSlots</code>的值就是子条目Blob的个数；同时，<code>codesign</code>会以<code>pageSize</code>字段指定的页大小为单位（通常取值是0x1000），对程序数据进行签名，每一页签名后生成一条签名数据，<code>nCodeSlots</code>的值就是签名数据的页数，即程序数据大小除以<code>pageSize</code>字段后的值。</p>
<p>在<code>CS_CodeDirectory</code>之后，就是Requirements了，它是一个<code>CS_SuperBlob</code>结构体，指明了Requirement的个数与每一个的偏移。接下来就是每一个Requirement数据了，它是一个<code>CS_GenericBlob</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_GenericBlob &#123;</div><div class="line">	uint32_t magic;				/* magic number */</div><div class="line">	uint32_t length;			/* total length of blob */</div><div class="line">	char data[];</div><div class="line">&#125; CS_GenericBlob;</div></pre></td></tr></table></figure></p>
<p>可以看到，它的前两个字段与<code>CS_SuperBlob</code>是一样的，只是后面多出一个<code>data</code>字段，用来存放Blob的数据长度。<br>在Requirement数据下面，就是Entitlement了，它同样是<code>CS_GenericBlob</code>结构。拿本机Calculator计算器程序来说，它的Entitlement的数据内容是一个xml文件，提取出来内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class="line">&lt;plist version=&quot;1.0&quot;&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.network.client&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.print&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">&lt;/dict&gt;</div><div class="line">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>
<p>最后一个Blob通常是签名使用的证书了，Certificates签名证书也是<code>CS_GenericBlob</code>结构，提取它的证书数据后保存为cer文件，使用macOS的文件预览证书内容，效果如图所示：<br><img src="/2017/01/13/macho/calc_cer.png" alt="calc_cer"></p>
<p>下面再来看看，系统是如何实施代码签名验证的！内核加载解析Mach-O加载命令的函数是<code>parse_machfile()</code>，位于内核代码”/bsd/kern/mach_loader.c“文件中，部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	uint32_t		ncmds;</div><div class="line">	struct load_command	*lcp;</div><div class="line">	struct dylinker_command	*dlp = 0;</div><div class="line">	integer_t		dlarchbits = 0;</div><div class="line">	void *			control;</div><div class="line">	load_return_t		ret = LOAD_SUCCESS;</div><div class="line">	caddr_t			addr;</div><div class="line">	void *			kl_addr;</div><div class="line">	vm_size_t		size,kl_size;</div><div class="line">	size_t			offset;</div><div class="line">	size_t			oldoffset;	/* for overflow check */</div><div class="line">	int			pass;</div><div class="line">	proc_t			p = current_proc();		/* XXXX */</div><div class="line">	int			error;</div><div class="line">	int resid=0;</div><div class="line">	size_t			mach_header_sz = sizeof(struct mach_header);</div><div class="line">	boolean_t		abi64;</div><div class="line">	boolean_t		got_code_signatures = FALSE;</div><div class="line">	int64_t			slide = 0;</div><div class="line"></div><div class="line">	if (header-&gt;magic == MH_MAGIC_64 ||</div><div class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</div><div class="line">	    	mach_header_sz = sizeof(struct mach_header_64);</div><div class="line">	&#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">	case LC_CODE_SIGNATURE:</div><div class="line">		/* CODE SIGNING */</div><div class="line">		if (pass != 1)</div><div class="line">			break;</div><div class="line">		/* pager -&gt; uip -&gt;</div><div class="line">			load signatures &amp; store in uip</div><div class="line">			set VM object &quot;signed_pages&quot;</div><div class="line">		*/</div><div class="line">		ret = load_code_signature(</div><div class="line">			(struct linkedit_data_command *) lcp,</div><div class="line">			vp,</div><div class="line">			file_offset,</div><div class="line">			macho_size,</div><div class="line">			header-&gt;cputype,</div><div class="line">			result);</div><div class="line">		if (ret != LOAD_SUCCESS) &#123;</div><div class="line">			printf(&quot;proc %d: load code signature error %d &quot;</div><div class="line">					&quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">			/*</div><div class="line">				* Allow injections to be ignored on devices w/o enforcement enabled</div><div class="line">				*/</div><div class="line">			if (!cs_enforcement(NULL))</div><div class="line">				ret = LOAD_SUCCESS; /* ignore error */</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			got_code_signatures = TRUE;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (got_code_signatures) &#123;</div><div class="line">			unsigned tainted = CS_VALIDATE_TAINTED;</div><div class="line">			boolean_t valid = FALSE;</div><div class="line">			struct cs_blob *blobs;</div><div class="line">			vm_size_t off = 0;</div><div class="line"></div><div class="line"></div><div class="line">			if (cs_debug &gt; 10)</div><div class="line">				printf(&quot;validating initial pages of %s\n&quot;, vp-&gt;v_name);</div><div class="line">			blobs = ubc_get_cs_blobs(vp);</div><div class="line"></div><div class="line">			while (off &lt; size &amp;&amp; ret == LOAD_SUCCESS) &#123;</div><div class="line">					tainted = CS_VALIDATE_TAINTED;</div><div class="line"></div><div class="line">					valid = cs_validate_page(blobs,</div><div class="line">								NULL,</div><div class="line">								file_offset + off,</div><div class="line">								addr + off,</div><div class="line">								&amp;tainted);</div><div class="line">					if (!valid || (tainted &amp; CS_VALIDATE_TAINTED)) &#123;</div><div class="line">						if (cs_debug)</div><div class="line">							printf(&quot;CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n&quot;,</div><div class="line">							vp-&gt;v_name, p-&gt;p_pid, (long long)(file_offset + off), valid, tainted, result-&gt;csflags);</div><div class="line">						if (cs_enforcement(NULL) ||</div><div class="line">						(result-&gt;csflags &amp; (CS_HARD|CS_KILL|CS_ENFORCEMENT))) &#123;</div><div class="line">							ret = LOAD_FAILURE;</div><div class="line">						&#125;</div><div class="line">						result-&gt;csflags &amp;= ~CS_VALID;</div><div class="line">					&#125;</div><div class="line">					off += PAGE_SIZE;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>整个代码签名的验证过程大致分为<code>load_code_signature()</code>与<code>cs_validate_page()</code>两步，前者负责加载代码签名，后者负责验证数据页面。<code>load_code_signature()</code>在加载代码签名时，通过调用<code>ubc_cs_blob_get()</code>来获取特定CPU的<code>cs_blob</code>指针，<code>ubc_cs_blob_get()</code>第一次调用时，返回的<code>cs_blob</code>指针为空，会调用<code>ubc_cs_blob_add()</code>来加载与验证文件中的Blob信息，以后再调用<code>ubc_cs_blob_get()</code>，就会返回内存中的<code>cs_blob</code>指针，当然不是直接返回，系统会再次判断内存中的<code>cs_blob</code>指针是否损坏或遭到篡改，具体方法是调用<code>ubc_cs_generation_check()</code>做初步的检查，之后调用<code>ubc_cs_blob_revalidate()</code>对blob做重验证。load_code_signature()`函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">static load_return_t</div><div class="line">load_code_signature(</div><div class="line">	struct linkedit_data_command	*lcp,</div><div class="line">	struct vnode			*vp,</div><div class="line">	off_t				macho_offset,</div><div class="line">	off_t				macho_size,</div><div class="line">	cpu_type_t			cputype,</div><div class="line">	load_result_t			*result)</div><div class="line">&#123;</div><div class="line">	int		ret;</div><div class="line">	kern_return_t	kr;</div><div class="line">	vm_offset_t	addr;</div><div class="line">	int		resid;</div><div class="line">	struct cs_blob	*blob;</div><div class="line">	int		error;</div><div class="line">	vm_size_t	blob_size;</div><div class="line"></div><div class="line">	addr = 0;</div><div class="line">	blob = NULL;</div><div class="line"></div><div class="line">	if (lcp-&gt;cmdsize != sizeof (struct linkedit_data_command) ||</div><div class="line">	    lcp-&gt;dataoff + lcp-&gt;datasize &gt; macho_size) &#123;</div><div class="line">		ret = LOAD_BADMACHO;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line">	if (blob != NULL) &#123;</div><div class="line">		/* we already have a blob for this vnode and cputype */</div><div class="line">		if (blob-&gt;csb_cpu_type == cputype &amp;&amp;</div><div class="line">		    blob-&gt;csb_base_offset == macho_offset &amp;&amp;</div><div class="line">		    blob-&gt;csb_mem_size == lcp-&gt;datasize) &#123;</div><div class="line">			/* it matches the blob we want here, lets verify the version */</div><div class="line">			if(0 != ubc_cs_generation_check(vp)) &#123;</div><div class="line">				if (0 != ubc_cs_blob_revalidate(vp, blob, 0)) &#123;</div><div class="line">					ret = LOAD_FAILURE; /* set error same as from ubc_cs_blob_add */</div><div class="line">					goto out;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			ret = LOAD_SUCCESS;</div><div class="line">		&#125; else &#123;</div><div class="line">			/* the blob has changed for this vnode: fail ! */</div><div class="line">			ret = LOAD_BADMACHO;</div><div class="line">		&#125;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob_size = lcp-&gt;datasize;</div><div class="line">	kr = ubc_cs_blob_allocate(&amp;addr, &amp;blob_size);</div><div class="line">	if (kr != KERN_SUCCESS) &#123;</div><div class="line">		ret = LOAD_NOSPACE;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resid = 0;</div><div class="line">	error = vn_rdwr(UIO_READ,</div><div class="line">			vp,</div><div class="line">			(caddr_t) addr,</div><div class="line">			lcp-&gt;datasize,</div><div class="line">			macho_offset + lcp-&gt;dataoff,</div><div class="line">			UIO_SYSSPACE,</div><div class="line">			0,</div><div class="line">			kauth_cred_get(),</div><div class="line">			&amp;resid,</div><div class="line">			current_proc());</div><div class="line">	if (error || resid != 0) &#123;</div><div class="line">		ret = LOAD_IOERROR;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (ubc_cs_blob_add(vp,</div><div class="line">			    cputype,</div><div class="line">			    macho_offset,</div><div class="line">			    addr,</div><div class="line">			    lcp-&gt;datasize,</div><div class="line">			    0)) &#123;</div><div class="line">		ret = LOAD_FAILURE;</div><div class="line">		goto out;</div><div class="line">	&#125; else &#123;</div><div class="line">		/* ubc_cs_blob_add() has consumed &quot;addr&quot; */</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">#if CHECK_CS_VALIDATION_BITMAP</div><div class="line">	ubc_cs_validation_bitmap_allocate( vp );</div><div class="line">#endif</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line"></div><div class="line">	ret = LOAD_SUCCESS;</div><div class="line">out:</div><div class="line">	if (ret == LOAD_SUCCESS) &#123;</div><div class="line">		result-&gt;csflags |= blob-&gt;csb_flags;</div><div class="line">		result-&gt;platform_binary = blob-&gt;csb_platform_binary;</div><div class="line">		result-&gt;cs_end_offset = blob-&gt;csb_end_offset;</div><div class="line">	&#125;</div><div class="line">	if (addr != 0) &#123;</div><div class="line">		ubc_cs_blob_deallocate(addr, blob_size);</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，上面提到的<code>cs_blob</code>指针，其实就是代码签名数据中的<code>CS_SuperBlob</code>指针类型。<br><code>ubc_cs_blob_add()</code>的代码比较长，它主要做了三个工作：一是调用<code>cs_validate_csblob()</code>验证<code>cs_blob</code>指针的合法性，<code>cs_validate_csblob()</code>会对<code>CSMAGIC_EMBEDDED_SIGNATURE</code>与<code>CSMAGIC_CODEDIRECTORY</code>做相应的验证处理，包括调用<code>cs_validate_codedirectory()</code>验证<code>CS_CodeDirectory</code>结构体的合法性，以及调用<code>cs_validate_blob()</code>来验证<code>CS_SuperBlob</code>中每一个<code>CS_GenericBlob</code>是否合法有效；二是调用<code>mac_vnode_check_signature()</code>验证Blob块的代码签名，也就是比较Blob块的SHA1哈希值是否与计算的值相同；三是加载所有的代码签名Hash信息，填充<code>cs_blobs</code>字段，为下一步的内存页签名验证做准备。<br><code>ubc_cs_blob_revalidate()</code>做着与<code>ubc_cs_blob_add()</code>几乎相同的验证检查，但前者因为已经有了一些缓存信息，因此检查时会快一些。</p>
<p><code>load_code_signature()</code>完事以后，会调用<code>ubc_get_cs_blobs()</code>获取<code>cs_blobs</code>指针，最后调用<code>cs_validate_page()</code>以逐页的形式验证文件中每一页的数据的签名。<br>以上检查做完后，<code>LC_CODE_SIGNATURE</code>就处理完了，没有错误发生就表示代码签名验证通过了。</p>
<p>讲完了代码签名，再讲讲代码加密。Mach-O程序如果使用了代码加密技术，在加载命令列表中会有一个<code>LC_ENCRYPTION_INFO</code>加载命令。它存储了Mach-O的加密信息。关于此加载命令，对于搞过iOS程序逆向的读者应该不会感到陌生。iOS系统由于安全机制的原因，会对App Store中上架的应用默认开启数据加密。<br>被加密过的App文件，部分段的数据内容是经过加密的，而记录加密数据的关键就是<code>LC_ENCRYPTION_INFO</code>加载命令。分析人员要想对加密过的App进行逆向分析，必须先经过一次解密（俗称“砸壳”）操作。<br><code>LC_ENCRYPTION_INFO</code>使用<code>encryption_info_command</code>结构体表示。定义如下（<code>LC_ENCRYPTION_INFO_64</code>使用<code>encryption_info_command_64</code>表示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct encryption_info_command &#123;</div><div class="line">   uint32_t	cmd;		/* LC_ENCRYPTION_INFO */</div><div class="line">   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command) */</div><div class="line">   uint32_t	cryptoff;	/* file offset of encrypted range */</div><div class="line">   uint32_t	cryptsize;	/* file size of encrypted range */</div><div class="line">   uint32_t	cryptid;	/* which enryption system, 0 means not-encrypted yet */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cryptoff</code>与<code>cryptsize</code>字段分别指明了加密数据的文件偏移与大小。<code>cryptid</code>指定了使用的加密系统。<br>聪明的安全研究人员，根据Mach-O在内存中被加载完后即解密完成的特点，开发了针对iOS平台App的代码解密工具<code>dumpdecrypted</code>，<br>下载地址是：<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">https://github.com/stefanesser/dumpdecrypted</a> 。通过将内存中解密后的数据写回原位置，并将<code>cryptid</code>置0来达到解密App的目的。</p>
<p>再来看看系统是如何处理<code>LC_ENCRYPTION_INFO</code>的，它的解析函数也是<code>parse_machfile()</code>，代码片断如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line">			case LC_ENCRYPTION_INFO:</div><div class="line">			case LC_ENCRYPTION_INFO_64:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				ret = set_code_unprotect(</div><div class="line">					(struct encryption_info_command *) lcp,</div><div class="line">					addr, map, slide, vp,</div><div class="line">					header-&gt;cputype, header-&gt;cpusubtype);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: set_code_unprotect() error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					/*</div><div class="line">					 * Don&apos;t let the app run if it&apos;s</div><div class="line">					 * encrypted but we failed to set up the</div><div class="line">					 * decrypter. If the keys are missing it will</div><div class="line">					 * return LOAD_DECRYPTFAIL.</div><div class="line">					 */</div><div class="line">					 if (ret == LOAD_DECRYPTFAIL) &#123;</div><div class="line">						/* failed to load due to missing FP keys */</div><div class="line">						proc_lock(p);</div><div class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</div><div class="line">						proc_unlock(p);</div><div class="line">					&#125;</div><div class="line">					 psignal(p, SIGKILL);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#endif</div><div class="line">			default:</div><div class="line">				/* Other commands are ignored by the kernel */</div><div class="line">				ret = LOAD_SUCCESS;</div><div class="line">				break;</div><div class="line"></div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>当系统内核被配置为启用代码解密，即定义了<code>CONFIG_CODE_DECRYPTION</code>之后，<code>parse_machfile()</code>函数会解析<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令。<br>最终是调用了<code>set_code_unprotect()</code>函数来对代码进行解密。该函数通过<code>encryption_info_command</code>中的<code>cryptid</code>来确定使用的加密系统，然后对代码进行内存解密。它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line"></div><div class="line">static load_return_t</div><div class="line">set_code_unprotect(</div><div class="line">		   struct encryption_info_command *eip,</div><div class="line">		   caddr_t addr, 	</div><div class="line">		   vm_map_t map,</div><div class="line">		   int64_t slide,</div><div class="line">		   struct vnode	*vp,</div><div class="line">		   cpu_type_t cputype,</div><div class="line">		   cpu_subtype_t cpusubtype)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if (eip-&gt;cmdsize &lt; sizeof(*eip)) return LOAD_BADMACHO;</div><div class="line"></div><div class="line">	switch(eip-&gt;cryptid) &#123;</div><div class="line">		case 0:</div><div class="line">			/* not encrypted, just an empty load command */</div><div class="line">			return LOAD_SUCCESS;</div><div class="line">		case 1:</div><div class="line">			cryptname=&quot;com.apple.unfree&quot;;</div><div class="line">			break;</div><div class="line">		case 0x10:</div><div class="line">			/* some random cryptid that you could manually put into</div><div class="line">			 * your binary if you want NULL */</div><div class="line">			cryptname=&quot;com.apple.null&quot;;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			return LOAD_BADMACHO;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (map == VM_MAP_NULL) return (LOAD_SUCCESS);</div><div class="line">	if (NULL == text_crypter_create) return LOAD_FAILURE;</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	/* set up decrypter first */</div><div class="line">	crypt_file_data_t crypt_data = &#123;</div><div class="line">		.filename = vpath,</div><div class="line">		.cputype = cputype,</div><div class="line">		.cpusubtype = cpusubtype&#125;;</div><div class="line">	kr=text_crypter_create(&amp;crypt_info, cryptname, (void*)&amp;crypt_data);</div><div class="line">	FREE_ZONE(vpath, MAXPATHLEN, M_NAMEI);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	offset = mach_header_sz;</div><div class="line">	uint32_t ncmds = header-&gt;ncmds;</div><div class="line">	while (ncmds--) &#123;</div><div class="line">		/*</div><div class="line">		 *	Get a pointer to the command.</div><div class="line">		 */</div><div class="line">		struct load_command *lcp = (struct load_command *)(addr + offset);</div><div class="line">		offset += lcp-&gt;cmdsize;</div><div class="line"></div><div class="line">		switch(lcp-&gt;cmd) &#123;</div><div class="line">			case LC_SEGMENT_64:</div><div class="line">				seg64 = (struct segment_command_64 *)lcp;</div><div class="line">				if ((seg64-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg64-&gt;fileoff+seg64-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg64-&gt;vmaddr + eip-&gt;cryptoff - seg64-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">			case LC_SEGMENT:</div><div class="line">				seg32 = (struct segment_command *)lcp;</div><div class="line">				if ((seg32-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg32-&gt;fileoff+seg32-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg32-&gt;vmaddr + eip-&gt;cryptoff - seg32-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* if we get here, did not find anything */</div><div class="line">	return LOAD_BADMACHO;</div><div class="line"></div><div class="line">remap_now:</div><div class="line">	/* now remap using the decrypter */</div><div class="line">	kr = vm_map_apple_protected(map, map_offset, map_offset+map_size, &amp;crypt_info);</div><div class="line">	if(kr) &#123;</div><div class="line">		printf(&quot;set_code_unprotect(): mapping failed with %x\n&quot;, kr);</div><div class="line">		crypt_info.crypt_end(crypt_info.crypt_ops);</div><div class="line">		return LOAD_PROTECT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return LOAD_SUCCESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p><code>text_crypter_create()</code>是一个全局的<code>text_crypter_create_hook_t</code>类型的指针，在内核代码“osfmk/kern/page_decrypt.c”文件中通过<code>text_crypter_create_hook_set()</code>进行设置。<br><code>text_crypter_create()</code>在填充完解密所需的信息<code>crypt_info</code>后，会再次计算需要重新解密映射到内存的地址与大小，调用<code>vm_map_apple_protected()</code>进行解密操作。</p>
<p>由于内核的代码可以直接审阅，数据加密在macOS系统上显得意义不大，在目前最新的macOS 10.12系统上，苹果没有启用代码解密功能，<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令也就没那么常见了。</p>
<p>最后，可以使用<code>otool</code>命令行工具来查看Mach-O文件的加载命令信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> otool -l /usr/bin/python</div><div class="line">/usr/bin/python:</div><div class="line">Load command 0</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 72</div><div class="line">  segname __PAGEZERO</div><div class="line">   vmaddr 0x0000000000000000</div><div class="line">   vmsize 0x0000000100000000</div><div class="line">  fileoff 0</div><div class="line"> filesize 0</div><div class="line">  maxprot 0x00000000</div><div class="line"> initprot 0x00000000</div><div class="line">   nsects 0</div><div class="line">    flags 0x0</div><div class="line">Load command 1</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">    ......</div><div class="line">Load command 15</div><div class="line">      cmd LC_DATA_IN_CODE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 17776</div><div class="line"> datasize 0</div><div class="line">Load command 16</div><div class="line">      cmd LC_CODE_SIGNATURE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 20528</div><div class="line"> datasize 9344</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>MachOView</code>查看，效果如图所示：<br><img src="/2017/01/13/macho/load_command.png" alt="load_command"></p>
<h2 id="0x6-LC-SEGMENT"><a href="#0x6-LC-SEGMENT" class="headerlink" title="0x6 LC_SEGMENT"></a>0x6 LC_SEGMENT</h2><p>段加载命令<code>LC_SEGMENT</code>，描述了32位Mach-O文件的段的信息，使用<code>segment_command</code>结构体来表示，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command &#123; /* for 32-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint32_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint32_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint32_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint32_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>segname</code>字段是一个16字节大小的空间，用来存储段的名称。<br><code>vmaddr</code>字段指明了段要加载的虚拟内存地址。<br><code>vmsize</code>字段指明了段所占的虚拟内存的大小。<br><code>fileoff</code>字段指明了段数据所在文件中偏移地址。<br><code>filesize</code>字段指明了段数据实际的大小。<br><code>maxprot</code>字段指明了页面所需要的最高内存保护。<br><code>initprot</code>字段指明了页面初始的内存保护。<br><code>nsects</code>字段指明了段所包含的节区（section）。<br><code>flags</code>字段指明了段的标志信息。</p>
<p>与<code>LC_SEGMENT</code>对应的是<code>LC_SEGMENT_64</code>，它使用<code>segment_command_64</code>结构体表示，描述了64位Mach-O文件的段的基本信息，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section_64 structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint64_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint64_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint64_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的字段含义与32位基本一致。主要讨论一下它最后4个字段。</p>
<p>一个编译后可能执行的程序分成了多个段，不同的类型的数据放入了不同的段中。如程序的代码被称作代码段，<br>放入一个名为<code>__TEXT</code>的段中，代码段的<code>maxprot</code>字段在编译时被设置成<code>VM_PROT_READ</code>（可读）、<code>VM_PROT_WRITE</code>（可写）、<code>VM_PROT_EXECUTE</code>（可执行），<code>initprot</code>字段被设置成<br><code>VM_PROT_READ</code>（可读）与<code>VM_PROT_EXECUTE</code>（可执行），这样做是合理的，一个普通的应用程序，它的代码段部分通常是不可写的，特殊需求的程序，如果要求代码段可写，必须在编译时设置它的<br><code>initprot</code>字段为<code>VM_PROT_WRITE</code>（可写）。</p>
<p><code>nsects</code>字段指定了段加载命令包含几个节区（section），一个段可以包含0个或多个节区。如<code>__PAGEZERO</code>段就不包含任何节区，该段被称为空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。<br>当一个段包含多个节区时，节区信息会以数组形式紧随着存储在段加载命令后面。节区使用结构体<code>section</code>表示（64位使用<code>section_64</code>表示），定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">	char		sectname[16];	/* name of this section */</div><div class="line">	char		segname[16];	/* segment this section goes in */</div><div class="line">	uint32_t	addr;		/* memory address of this section */</div><div class="line">	uint32_t	size;		/* size in bytes of this section */</div><div class="line">	uint32_t	offset;		/* file offset of this section */</div><div class="line">	uint32_t	align;		/* section alignment (power of 2) */</div><div class="line">	uint32_t	reloff;		/* file offset of relocation entries */</div><div class="line">	uint32_t	nreloc;		/* number of relocation entries */</div><div class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</div><div class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</div><div class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>sectname</code>字段表示节区的名称，<code>segname</code>字段表示节区所在的段名，<code>addr</code>与<code>size</code>指明了节区所在的内存地址与大小，<code>offset</code>指明了区取所在的文件偏移，<br><code>align</code>表示节区的内存对齐边界，<code>reloff</code>指明了重定位信息的文件偏移，<code>nreloc</code>表示重定位条目的数目，<code>flags</code>则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段<code>flags</code>存储了段的一些标志属性，它的取值有如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define	SG_HIGHVM	0x1</div><div class="line">#define	SG_FVMLIB	0x2</div><div class="line">#define	SG_NORELOC	0x4</div><div class="line">#define SG_PROTECTED_VERSION_1	0x8</div></pre></td></tr></table></figure></p>
<p>值得关注的是<code>SG_PROTECTED_VERSION_1</code>，当段被设置了该标志位，表示段是经过加密的！在macOS版本10.6以前，系统使用AES算法进行段的加密与解密，10.6的时候，则使用的Blowfish加密算法，著名的iOS逆向工具<code>class-dump</code>（地址：<a href="https://github.com/nygard/class-dump）" target="_blank" rel="external">https://github.com/nygard/class-dump）</a> 提供了一个静态数据段解密工具<code>deprotect</code>，有兴趣的读者可以参看它的代码来了解段解密的部分。</p>
<p>最后，使用<code>MachOView</code>工具查看系统python程序的<code>__TEXT</code>段的信息如图所示：<br><img src="/2017/01/13/macho/python_seg.png" alt="python_seg"></p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/13/macho/" data-id="ciz2fqefz0008xuvjt5tg71to" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-install-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/install-software/" class="article-date">
  <time datetime="2017-01-12T03:27:10.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/install-software/">macOS平台软件的下载与安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于一个操作系统来说，对其影响最大的莫过于运行在它上面的软件，正因为这些形形色色软件的存在，操作系统才得以广泛应用。与Linux、Windows等主流操作系统一样，运行在macOS上的软件也有着自己独有的特点。</p>
<p>macOS上的软件有着自己独特的UI界面与操作方式。macOS的设计师一直秉承着自己的设计理念，设计出的Aqua界面别具风格。银灰的金属色主题始终是分辨macOS系统最快捷的一种方式，与Windows界面将最小按钮与关闭按钮设置到窗口右上角不同，Aqua界面的程序，最小化与关闭按钮位于软件的左上角，并且使用全屏按钮替换了Windows上的最大化按钮。进入全屏模式下的软件会新开一个窗口并占据屏幕的全部空间，可以在触摸板上使用三根手指左右划动来切换不同的全屏窗口。</p>
<p>每个常规的Aqua界面的程序都有一个菜单，菜单显示在用户屏幕的顶端，菜单的最左边始终是一个苹果图标，点击它会弹出系统设置、<code>App Store</code>、关机、重启等多个选项。<br>macOS使用Dock栏来管理显示常用的软件，它位于用户屏幕的底部，展示效果与Windows的任务栏相似，正在运行的macOS界面程序，都可以在Dock上右键点击该程序，在弹出的菜单中选择Options-&gt;Keep in Dock，将程序在Dock上保留下来，以后就可以直接从Dock中单击图标启动程序。<br>在Windows系统中，用户可以使用开始菜单-&gt;所有程序来找到系统中安装的软件并启动它，macOS中则提供了一个<code>Launchpad</code>程序来管理安装在/Applications目录中的软件。<code>Launchpad</code>移植于iOS系统中的<code>SpringBoard</code>，展示的效果也与之类似，它以全屏网格形式的界面显示了所有可以运行的软件与系统工具，如果软件安装过多，会以多个页面来展示。点击Dock上的<code>Launchpad</code>图标可以启动它，如图所示：<br><img src="/2017/01/12/install-software/launchpad.png" alt="launchpad"><br>使用二根手指左右划动可以在不同的页面间切换。</p>
<h3 id="0x0-可执行文件"><a href="#0x0-可执行文件" class="headerlink" title="0x0 可执行文件"></a>0x0 可执行文件</h3><p>除了Aqua界面的程序，macOS上还可以运行很多其它种类的文件，这里将所有可以运行在macOS系统上文件的统称为macOS可执行文件。</p>
<p>首先是脚本，macOS提供了UNIX系统中的Shell环境来支持运行脚本与命令行程序，脚本实质是一个文本文件，在脚本文件中指定运行它解释器后，Shell在运行脚本时，会调用解释器来解释运行它，任何一个文件都可以通过执行”chmod +x”命令给它加上可执行权限，拥有可执行权限的文件并不一定能执行，它必须是能满足某种解释器的语法规则才算得上可执行文件。<br>除了主流的几种Shell脚本支持外，macOS还内置了目前比较流行的<code>Perl</code>、<code>Python</code>和<code>Ruby</code>等脚本的解释器，任何人都可以直接编写<code>Perl</code>、<code>Python</code>和<code>Ruby</code>脚本并调用它们的解释器来运行，而不需要安装额外的软件。</p>
<p>另外，苹果公司还开发了一种脚本：AppleScript（苹果脚本）。它的作用是用于运行在macOS的程序并实际自动化工作的。苹果提供了一个单独的脚本编辑器来开发与调试AppleScript。它位于/Applications/Ｕtilities/Script Editor。使用<code>Script Editor</code>编写好的脚本保存的格式为scpt。随着macOS系统的不断升级，<code>AppleScript</code>也在不停的发展，目前甚至可以使用<code>AppleScript</code>来开发macOS上的界面程序。具体的步骤是在XCode中选择File-&gt;New-&gt;Project，在打开的对话框中选择Other-&gt;Cocoa-AppleScript。有兴趣的读者可以参看苹果的官方文档来深入了解AppleScript，地址上：<a href="https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html</a> 。</p>
<p>除了脚本外，可执行文件还包括可以由用户主动执行的程序与被动执行的程序文件。<br>主动执行的程序包括：GUI界面程序、命令行程序、游戏等；被动执行的程序包括被系统调用的程序，如：<code>Quick Look</code>插件、屏幕保护程序、内核驱动与扩展等，以及被程序调用的框架、库、Bundle、XPC服务等。所有的这些可执行文件都使用苹果独有的可执行文件格式Mach-O。关于Mach-O文件的格式，将在后面的小节中进行详细讲解。</p>
<h3 id="0x1-下载与安装软件"><a href="#0x1-下载与安装软件" class="headerlink" title="0x1 下载与安装软件"></a>0x1 下载与安装软件</h3><p>苹果支持从自家的<code>App Store</code>应用商店直接安装软件，也支持从第三方渠道，如其它磁盘介质、网络下载来安装软件。从<code>App Store</code>下载软件是最方便快捷，也是最安全的一种方式，苹果公司一向以软件审查严格闻名，自家商店中的应用软件在界面、功能以及对系统资源的使用上，都是经常严格审查与限制的，对于普通用户来说，这种下载软件的方式最合适不过了，但对于专业用户来说，由于一些专业软件在用户授权协议、资源访问上或其它方面的原因未能在<code>App Store</code>上架，就只能从网络或第三方渠道来获取这类软件了。</p>
<h4 id="0x1-1-免费与付费软件"><a href="#0x1-1-免费与付费软件" class="headerlink" title="0x1.1 免费与付费软件"></a>0x1.1 免费与付费软件</h4><p><code>App Store</code>应用商店上提供了丰富的免费与付费的软件供用户下载使用。下载免费的软件不需要用户付出额外的成本，只需要到官网<a href="https://appleid.apple.com/" target="_blank" rel="external">https://appleid.apple.com/</a> 注册一个的帐号，使用帐号登录<code>App Store</code>就可以下载上面的免费软件了。<br>如果要下载<code>App Store</code>上面的收费软件，需要为帐号绑定一张银行卡，购买软件成功后会直接从银行卡中扣取费用。另外，<code>App Store</code>中的软件还支持另一种收费方式：<code>In-App Purchase</code>（应用内付费），简称IAP，这种收费方式在苹果自家的iOS系统中应用非常广泛，它允许开发人员为自己的软件某些特定功能设定为需要购买才能使用，目前，很多软件开发商以此平台作为主要的软件收入来源。</p>
<p><code>App Store</code>中的收费软件只有IAP与直接购买这两种方式，而网络下载的收费软件的付费形式则丰富很多。部分软件官网只提供软件基础功能的演示版本供用户下载，如果需要使用正式版本，则需要联系软件开发商购买完整版本。例如著名的反汇编软件<code>IDA Pro</code>，官网就只提供了Demo版本可供下载：<a href="https://www.hex-rays.com/products/ida/support/download_demo.shtml" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/download_demo.shtml</a> ，正式版本需要找软件开发商或代理商购买。也有些软件的官网会提供完整版本下载，但会有使用时间或功能限制，如果需要正常无限制使用软件，则需要购买软件授权，如反汇编软件<code>Hopper</code>（<a href="http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010" target="_blank" rel="external">http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010</a> Editor`（<a href="http://www.sweetscape.com/010editor/）。" target="_blank" rel="external">http://www.sweetscape.com/010editor/）。</a></p>
<h4 id="0x1-2-安装软件"><a href="#0x1-2-安装软件" class="headerlink" title="0x1.2 安装软件"></a>0x1.2 安装软件</h4><p>普通的macOS软件只是一个以扩展名.app结尾的目录，这种目录有着特定的组织结构，macOS将它称之为Bundle，安装这类软件只需要将Bundle复制到系统的/Applications目录即可，复制完成后，<code>Launchpad</code>面板会自动更新安装好的软件图标，启动软件不需要到/Applications目录中去寻找它，只需要打开<code>Launchpad</code>，找到软件的图标并点击就可以运行该程序了。<br>从网络上下载的软件通常是经过打包后发布的，普通的软件多是zip或其它方式压缩后，以压缩包的形式提供下载，还有的使用磁盘工具将软件打包成一个dmg磁盘镜像文件，这类dmg文件内通常还会有一个Applications目录的软链接，安装的时候，只需要将dmg中的软件直接拖放到该软链接上就算完成安装了。如图所示，是<code>AppDelete</code>的安装镜像：<br><img src="/2017/01/12/install-software/install_app.png" alt="install_app"></p>
<p>macOS上的软件还有一种是以pkg或mpkg结尾的安装包，类似于Windows系统上的msi或exe安装程序，通过不停的点击下一步就可以完成安装，这类软件除了将主程序写入/Applications目录外，一般还会在系统上做一些只有管理员权限才能完成的动作，比如为特定的目录或文件创建软链接、安装与卸载内核扩展、复制命令行程序到用户可执行文件目录/usr/local/bin中等。因此，在安装的过程中，可能会提示输入管理员用户名与密码来执行需要Root权限的操作。</p>
<p>另一种是命令行工具，这类程序的安装使用第一章中介绍的<code>Homebrew</code>即可，此处不再赘述。</p>
<h3 id="0x3-Bundle"><a href="#0x3-Bundle" class="headerlink" title="0x3 Bundle"></a>0x3 Bundle</h3><p>Bundle是苹果系统独有的特色，在苹果系统上大量中使用了Bundle。</p>
<h4 id="0x3-1-Bundle目录结构"><a href="#0x3-1-Bundle目录结构" class="headerlink" title="0x3.1 Bundle目录结构"></a>0x3.1 Bundle目录结构</h4><p>安装到macOS系统上的软件有着自己特定的格式，它们是以.app扩展名结尾的Bundle目录结构。Bundle有着固定的组织格式，在Finder中查看Bundle的目录内容，可以在程序上点右键，在弹出的菜单中选择Show Package Contents，查看Bundle的目录结构。以/Applications目录下<code>App Store</code>为例，它的目录结构如图所示：<br><img src="/2017/01/12/install-software/bundle.png" alt="bundle"></p>
<p>在App Store.app目录下，只有一个Contents子目录，所有软件的内容都在此目录下。它们包括：</p>
<ul>
<li>CodeSignature目录。此目录下只有一个CodeResources文件，它是一个plist格式的文件，保存了软件包中所有文件的签名信息。</li>
<li>info.plist文件。此文件记录了软件的一些信息。如软件构建的机器的版本<code>BuildMachineOSBuild</code>、可执行文件名<code>CFBundleExecutable</code>、软件的标识<code>CFBundleIdentifier</code>、软件包名<code>CFBundleName</code>等。</li>
<li>MacOS目录。此目录存放了可执行文件。</li>
<li>Pkginfo文件。软件包的8字节的标识符。</li>
<li>Resources目录。软件运行所需要的资源，包括.iproj本地化资源、.nib资源、图片、字体、声音、文档以及其它文件。</li>
<li>Plugins目录。插件目录，存放了软件用到的插件，插件也是使用Bundle目录结构进行组织的一种程序。</li>
</ul>
<p>除了Plugins目录外，根据软件需求与实现的不同，Contents下可能还会有Frameworks与XPCServices目录，Frameworks里面存放了软件需要用到的框架，它是以.framework结尾的Bundle结构；XPCServices则存放了软件用到的XPC服务，它是以.xpc结尾的Bundle结构，还有一种以.bundle扩展名结尾的Bundle，它是“纯粹”的Bundle，目录结构与其它的Bundle无异，存放的内容可以是二进制代码，也可以是资源，也可以二者同时存放，如果存放二进制代码的话，可供程序在代码中使用<code>dlopen()</code>函数打开，这种Bundle通常用于制作软件的插件，存放在软件Bundle的Resources目录下。</p>
<h4 id="0x3-2-代码中访问Bundle"><a href="#0x3-2-代码中访问Bundle" class="headerlink" title="0x3.2 代码中访问Bundle"></a>0x3.2 代码中访问Bundle</h4><p>在程序中，开发人员可以使用<code>Cocoa</code>框架提供的<code>NSBundle</code>类来获取程序的Bundle信息。调用<code>NSBundle</code>的<code>mainBundle()</code>方法可以返回当前程序的主Bundle对象，调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSBundle *bundle = [NSBundle mainBundle]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>infoDictionary()</code>方法可以访问软件Bundle目录下info.plist文件中的信息，它返回的是一个字典对象，如下所示是获取程序标识符的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleIdentifier&quot;]]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>pathForResource()</code>方法可以访问Bundle目录下任意资源文件。如下所示是访问Bundle根目录下的monkey.png文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *monkey = [[NSBundle mainBundle] pathForResource:@&quot;monkey&quot; ofType:@&quot;png&quot;];</div></pre></td></tr></table></figure></p>
<p>与主Bundle对应的是自定义Bundle，这一类Bundle的访问可以这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *resourceBundle = [[NSBundle mainBundle] pathForResource:@&quot;ResPack&quot; ofType:@&quot;bundle&quot;];</div><div class="line">NSLog(@&quot;resourceBundle: %@&quot;, resourceBundle);</div><div class="line">NSString *monkey = [[NSBundle bundleWithPath:resourceBundle] pathForResource:@&quot;monkey&quot;</div><div class="line">			ofType:@&quot;png&quot; inDirectory:@&quot;Images&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;monkey path: %@&quot;, monkey);</div></pre></td></tr></table></figure></p>
<p>上面这段代码访问了ResPack.bundle中Images目录下的monkey.png文件。</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/install-software/" data-id="ciz2fqeff0003xuvjfq4at2j9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-new-chapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/new-chapter/" class="article-date">
  <time datetime="2017-01-11T05:56:48.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/new-chapter/">新的篇章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>欢迎来到 <a href="https://feicong.github.io/">非虫的博客</a>! 自从12年放弃百度空间后，再没写过博客了。</p>
<p>新的一年，新的篇章，非虫的博客全新开启，以此记录生活点滴，同时作为自己技术分享的平台，希望你会喜欢！</p>

      
    </div>
  	
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/11/new-chapter/" data-id="ciz2fqega000dxuvjyh351jmr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android软件安全/">Android软件安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android软件安全/" style="font-size: 10px;">Android软件安全</a> <a href="/tags/macOS软件安全/" style="font-size: 20px;">macOS软件安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/12/legend/">Android免Root环境下Hook框架Legend原理分析</a>
          </li>
        
          <li>
            <a href="/2017/02/03/macho-unpack/">Mach-O脱壳技巧一则</a>
          </li>
        
          <li>
            <a href="/2017/01/17/dmg/">DMG文件管理</a>
          </li>
        
          <li>
            <a href="/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a>
          </li>
        
          <li>
            <a href="/2017/01/15/staticlib/">静态库的管理与文件格式分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
      <div class="widget">
      	<ul>
        	
          	<li class='link'><a href='https://ydc1992.github.io'>Ken&#39;s Blog</a></li>
        	
      	</ul>
      </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>