<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fEICOnG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="fEICOnG's Blog">
<meta property="og:url" content="https://feicong.github.io/index.html">
<meta property="og:site_name" content="fEICOnG's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fEICOnG's Blog">
  
    <link rel="alternate" href="/atom.xml" title="fEICOnG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fEICOnG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RE makes life easier</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://feicong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-macos-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/macos-software/" class="article-date">
  <time datetime="2017-01-12T02:20:31.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/macos-software/">［置顶］macOS软件安全系列-软件内幕篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>macOS平台上的软件安全话题讨论在国内仍是软件安全领域的沼泽地带，除了在部分安全论坛上见过几篇破解分析的文章外，鲜有人问津。</p>
<p>如今，macOS平台的安全问题已经被越来越多的人关注，本系列的文章为macOS软件安全系列的一个篇章－软件内幕篇，探讨macOS系统上常见的文件格式与它们的管理方式，让各位关注软件安全领域的朋友，对macOS系统上的软件安全有直观的认识。</p>
<h2 id="每日更新一篇中…"><a href="#每日更新一篇中…" class="headerlink" title="每日更新一篇中…"></a>每日更新一篇中…</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本系列文章为非虫（微信：feicongcn）原创，任何个人与组织未经允许，不得转载与摘抄，否则，作者保留一切追究法律责任的权利。</p>
<h3 id="macOS平台软件的下载与安装"><a href="#macOS平台软件的下载与安装" class="headerlink" title="macOS平台软件的下载与安装"></a><a href="https://feicong.github.io/2017/01/12/install-software/">macOS平台软件的下载与安装</a></h3><h3 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a><a href="https://feicong.github.io/2017/01/13/macho/">Mach-O文件格式</a></h3><h3 id="dylib动态库加载过程分析"><a href="#dylib动态库加载过程分析" class="headerlink" title="dylib动态库加载过程分析"></a><a href="https://feicong.github.io/2017/01/14/dylib/">dylib动态库加载过程分析</a></h3><h3 id="静态库的管理与文件格式分析"><a href="#静态库的管理与文件格式分析" class="headerlink" title="静态库的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/15/staticlib/">静态库的管理与文件格式分析</a></h3><h3 id="PKG安装包的管理与文件格式分析"><a href="#PKG安装包的管理与文件格式分析" class="headerlink" title="PKG安装包的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a></h3><h3 id="DMG文件管理"><a href="#DMG文件管理" class="headerlink" title="DMG文件管理"></a><a href="https://feicong.github.io/2017/01/17/dmg/">DMG文件管理</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/macos-software/" data-id="cixv4zw4k0001v7vjvx3r98hu" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-macho" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/macho/" class="article-date">
  <time datetime="2017-01-13T01:03:08.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/macho/">Mach-O文件格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x1-通用二进制格式"><a href="#0x1-通用二进制格式" class="headerlink" title="0x1 通用二进制格式"></a>0x1 通用二进制格式</h2><p>虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。</p>
<p>macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。<br>又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同CPU架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行<code>file</code>命令可以查看它的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ file /usr/bin/python</div><div class="line">/usr/bin/python: Mach-O universal binary with 2 architectures</div><div class="line">/usr/bin/python (for architecture x86_64):	Mach-O 64-bit executable x86_64</div><div class="line">/usr/bin/python (for architecture i386):	Mach-O executable i386</div></pre></td></tr></table></figure></p>
<p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。例如提取<code>python</code>中x86_64版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>删除x86版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>或者直接瘦身为x86_64版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>通用二进制的“通用”不止针对可以直接运行的可执行程序，系统中的动态库dylib、静态库.a文件以及框架等都可以是通用二进制文件，对它们也可以同样使用<code>lipo</code>命令来进行管理。<br>下来看一下通用二进制的文件格式。安装好macOS程序开发的SDK后，或者在xnu的内核源码中，都可以在&lt;mach-o/fat.h&gt;文件中找到通用二进制文件格式的声明。从文件命名上看，将通用二进制称为胖二进制更方便一些。胖二进制头部结构<code>fat_header</code>定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define FAT_MAGIC	0xcafebabe</div><div class="line">#define FAT_CIGAM	0xbebafeca	/* NXSwapLong(FAT_MAGIC) */</div><div class="line"></div><div class="line">struct fat_header &#123;</div><div class="line">	uint32_t	magic;		/* FAT_MAGIC */</div><div class="line">	uint32_t	nfat_arch;	/* number of structs that follow */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段被定义为常量<code>FAT_MAGIC</code>，它的取值是固定的0xcafebabe，表示这是一个通用的二进制文件。<code>nfat_arch</code>字段指明了通用二进制中包含多少个Mach-O文件。<br>每个通用二进制架构信息都使用<code>fat_arch</code>结构表示，在<code>fat_header</code>结构体之后，紧接着的是一个或多个连续的<code>fat_arch</code>结构体，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct fat_arch &#123;</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier (int) */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier (int) */</div><div class="line">	uint32_t	offset;		/* file offset to this object file */</div><div class="line">	uint32_t	size;		/* size of this object file */</div><div class="line">	uint32_t	align;		/* alignment as a power of 2 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cputype</code>指定了具体的cpu类型，它的类型是<code>cpu_type_t</code>，定义位于mach/machine.h中。<code>cpu</code>的常用类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define CPU_TYPE_X86		((cpu_type_t) 7)</div><div class="line">#define CPU_TYPE_I386		CPU_TYPE_X86		</div><div class="line">#define	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC98000	((cpu_type_t) 10)</div><div class="line">#define CPU_TYPE_HPPA           ((cpu_type_t) 11)</div><div class="line">#define CPU_TYPE_ARM		((cpu_type_t) 12)</div><div class="line">#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC88000	((cpu_type_t) 13)</div><div class="line">#define CPU_TYPE_SPARC		((cpu_type_t) 14)</div><div class="line">#define CPU_TYPE_I860		((cpu_type_t) 15)</div><div class="line">#define CPU_TYPE_POWERPC		((cpu_type_t) 18)</div><div class="line">#define CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64</div></pre></td></tr></table></figure></p>
<p>macOS平台上的CPU类型一般为<code>CPU_TYPE_X86_64</code>。</p>
<p><code>cpusubtype</code>指定了cpu的子类型。它的类型是<code>cpu_subtype_t</code>。cpu子类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define CPU_SUBTYPE_MASK	0xff000000</div><div class="line">#define CPU_SUBTYPE_LIB64	0x80000000</div><div class="line">#define CPU_SUBTYPE_X86_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_64_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_ARCH1		((cpu_subtype_t)4)</div><div class="line">#define CPU_SUBTYPE_X86_64_H		((cpu_subtype_t)8)</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>cpu子类型一般<code>CPU_SUBTYPE_LIB64</code>与<code>CPU_SUBTYPE_X86_64_ALL</code>比较常见。</p>
<p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值。<code>size</code>字段指明了数据的大小。</p>
<p><code>align</code>字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。</p>
<p>可以使用<code>otool</code>工具打印本机安装的<code>python</code>程序的<code>fat_header</code>信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">otool -f -V /usr/bin/python</div><div class="line">Fat headers</div><div class="line">fat_magic FAT_MAGIC</div><div class="line">nfat_arch 2</div><div class="line">architecture i386</div><div class="line">    cputype CPU_TYPE_I386</div><div class="line">    cpusubtype CPU_SUBTYPE_I386_ALL</div><div class="line">    capabilities 0x0</div><div class="line">    offset 4096</div><div class="line">    size 29632</div><div class="line">    align 2^12 (4096)</div><div class="line">architecture x86_64</div><div class="line">    cputype CPU_TYPE_X86_64</div><div class="line">    cpusubtype CPU_SUBTYPE_X86_64_ALL</div><div class="line">    capabilities CPU_SUBTYPE_LIB64</div><div class="line">    offset 36864</div><div class="line">    size 29872</div><div class="line">    align 2^12 (4096)</div></pre></td></tr></table></figure></p>
<p>如果你是UNIX的使用者，经常使用GNU里面<code>binutils</code>提供的<code>objdump</code>查看可执行文件信息的话，在macOS上可以使用它的移植版本<code>gobjdump</code>，使用<code>HomeBrew</code>运行以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install binutils</div></pre></td></tr></table></figure></p>
<p>完装完成后，执行下面的命令也可以查看<code>python</code>程序的<code>fat_header</code>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ gobjdump -f /usr/bin/python</div><div class="line">In archive /usr/bin/python:</div><div class="line"></div><div class="line">i386:     file format mach-o-i386</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00001be0</div><div class="line"></div><div class="line">i386:x86-64:     file format mach-o-x86-64</div><div class="line">architecture: i386:x86-64, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x0000000100000e20</div></pre></td></tr></table></figure></p>
<p>在<code>fat_arch</code>结构体往下就是具体的Mach-O文件格式了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h2 id="0x2-Mach-O文件格式简介"><a href="#0x2-Mach-O文件格式简介" class="headerlink" title="0x2 Mach-O文件格式简介"></a>0x2 Mach-O文件格式简介</h2><p>Mach-O（Mach Object File Format）描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式，有助于了解苹果底层软件运行机制，更好的掌握<code>dyld</code>加载Mach-O的步骤，为自己动手开发Mach-O相关的加解密工具打下基础。</p>
<p>一个典型的Mach-O文件格式如图所示：<br><img src="/2017/01/13/macho/mach-o.png" alt="mach-o"><br>通过上图，可以看出Mach-O主要由以下三部分组成：</p>
<ul>
<li>Mach-O头部（mach header）。描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</li>
<li>加载命令（load command）。描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</li>
<li>Data。Data中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个Section，它们存放了具体的数据与代码。</li>
</ul>
<h2 id="0x3-Mach-O头部"><a href="#0x3-Mach-O头部" class="headerlink" title="0x3 Mach-O头部"></a>0x3 Mach-O头部</h2><p>与Mach-O文件格式有关的结构体，都可以直接或间接的在”mach-o/loader.h“文件中找到。<br>针对32位与64位架构的cpu，分别使用了<code>mach_header</code>与<code>mach_header_64</code>结构体来描述Mach-O头部。<br><code>mach_header</code>结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct mach_header &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样，表示Mach-O文件的魔数值，对于32位架构的程序来说，它的取值是<code>MH_MAGIC</code>，固定为0xfeedface。<br><code>cputype</code>与<code>cpusubtype</code>字段与<code>fat_header</code>结构体中的含义完全相同。<br><code>filetype</code>字段表示Mach-O的具体文件类型。它的取值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define	MH_OBJECT	0x1		/* relocatable object file */</div><div class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */</div><div class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</div><div class="line">#define	MH_CORE		0x4		/* core file */</div><div class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</div><div class="line">#define	MH_DYLIB	0x6		/* dynamically bound shared library */</div><div class="line">#define	MH_DYLINKER	0x7		/* dynamic link editor */</div><div class="line">#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */</div><div class="line">#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */</div><div class="line">					/*  linking only, no section contents */</div><div class="line">#define	MH_DSYM		0xa		/* companion file with only debug sections */</div><div class="line">#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */</div></pre></td></tr></table></figure></p>
<p>这里主要关注<code>MH_EXECUTE</code>、<code>MH_DYLIB</code>与<code>MH_DYLIB</code>这3个文件格式。</p>
<p>接下来的<code>ncmds</code>指明了Mach-O文件中加载命令（load commands）的数量。</p>
<p><code>sizeofcmds</code>字段指明了Mach-O文件加载命令（load commands）所占的总字节大小。</p>
<p><code>flags</code>字段表示文件标志，它是一个含有一组位标志的整数，指明了Mach-O文件的一些标志信息。可用的值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define	MH_NOUNDEFS	0x1</div><div class="line">#define	MH_INCRLINK	0x2</div><div class="line">#define MH_DYLDLINK	0x4</div><div class="line">#define MH_LAZY_INIT 0x40</div><div class="line">#define MH_TWOLEVEL	0x80</div><div class="line">#define MH_PIE 0x200000</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>针对64位Mach-O的<code>mach_header_64</code>结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct mach_header_64 &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">	uint32_t	reserved;	/* reserved */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>相比<code>mach_header</code>，它多出了一个<code>reserved</code>字段，目前它的取值系统保留。<code>mach_header_64</code>结构体中的字段与<code>mach_header</code>中的基本一致，除了<code>magic</code>字段的取值是<code>MH_MAGIC_64</code>，固定的值为0xfeedfacf。<br>学习Mach-o文件格式时，可以使用辅助工具查看具体的文件结构，这样效果更加直观。<br>下图是<code>MachOView</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/mach_header.png" alt="mach_header"><br>下图是<code>010 Editor</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/010_editor.png" alt="010_editor"><br>下图是<code>Synalyze It!</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/synalyze_it.png" alt="synalyze_it"><br>这三款工具对于学习Mach-O文件格式都是非常有帮助的，读者在实际分析时可以多多使用。</p>
<h2 id="0x4-加载命令"><a href="#0x4-加载命令" class="headerlink" title="0x4 加载命令"></a>0x4 加载命令</h2><p>在<code>mach_header</code>之后的是Load Command加载命令，这些加载命令在Mach-O文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">	uint32_t cmd;		/* type of load command */</div><div class="line">	uint32_t cmdsize;	/* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此结构对应的成员只有2个：<code>cmd</code>字段代表当前加载命令的类型。<code>cmdsize</code>字段代表当前加载命令的大小。<br>cmd的类型不同，所代表的加载命令的类型就不同，它的结构体也会有所不一样，对于不同类型的加载命令，它们都会在<code>load_command</code>结构体后面加上一个或多个字段来表示自己特定的结构体信息。</p>
<p>macOS系统在进化的过程中，加载命令算是比较频繁被更新的一个数据结构体，截止到macOS 10.12系统，加载命令的类型cmd的取值共有48种。它们的部分定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */</div><div class="line">#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */</div><div class="line">#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */</div><div class="line">#define	LC_THREAD	0x4	/* thread */</div><div class="line">#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */</div><div class="line">#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */</div><div class="line">#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */</div><div class="line">#define	LC_IDENT	0x8	/* object identification info (obsolete) */</div><div class="line">#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */</div><div class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</div><div class="line">#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */</div><div class="line">#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */</div><div class="line">......</div><div class="line">#define	LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</div><div class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</div><div class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</div><div class="line">#ifndef __OPEN_SOURCE__</div><div class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</div><div class="line">#endif /* __OPEN_SOURCE__ */</div><div class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</div></pre></td></tr></table></figure></p>
<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_SEGMENT</code>、<code>LC_LOAD_DYLINKER</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等。</p>
<p><code>LC_SEGMENT</code>：表示这是一个段加载命令，需要将它加载到对应的进程空间上去。段加载命令将在下一小节进行讨论。</p>
<p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用<code>dylib_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct dylib_command &#123;</div><div class="line">	uint32_t	cmd;		/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,LC_REEXPORT_DYLIB */</div><div class="line">	uint32_t	cmdsize;	/* includes pathname string */</div><div class="line">	struct dylib dylib;		/* the library identification */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当cmd类型时<code>LC_ID_DYLIB</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>与<code>LC_REEXPORT_DYLIB</code>时，统一使用<code>dylib_command</code>结构体表示。<br>它使用dylib结构体来存储要加载的动态库的具体信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct dylib &#123;</div><div class="line">    union lc_str  name;			/* library&apos;s path name */</div><div class="line">    uint32_t timestamp;			/* library&apos;s build time stamp */</div><div class="line">    uint32_t current_version;		/* library&apos;s current version number */</div><div class="line">    uint32_t compatibility_version;	/* library&apos;s compatibility vers number*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>name</code>字段是动态库的完整路径，动态链接器在加载动态库时，通用此路径来进行加载它。<br><code>timestamp</code>字段描述了动态库构建时的时间戳。<code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号。</p>
<p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数<code>main()</code>的位置。它使用<code>entry_point_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct entry_point_command &#123;</div><div class="line">    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */</div><div class="line">    uint32_t  cmdsize;	/* 24 */</div><div class="line">    uint64_t  entryoff;	/* file (__TEXT) offset of main() */</div><div class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>entryoff</code>字段中就指定了<code>main()</code>函数的文件偏移。<code>stacksize</code>指定了初始的堆栈大小。</p>
<h2 id="0x5-LC-CODE-SIGNATURE与代码签名过程分析"><a href="#0x5-LC-CODE-SIGNATURE与代码签名过程分析" class="headerlink" title="0x5 LC_CODE_SIGNATURE与代码签名过程分析"></a>0x5 LC_CODE_SIGNATURE与代码签名过程分析</h2><p><code>LC_CODE_SIGNATURE</code>：代码签名加载命令。描述了Mach-O的代码签名信息，它属于链接信息，使用<code>linkedit_data_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct linkedit_data_command &#123;</div><div class="line">    uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,</div><div class="line">                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,</div><div class="line">				   LC_DYLIB_CODE_SIGN_DRS or</div><div class="line">				   LC_LINKER_OPTIMIZATION_HINT. */</div><div class="line">    uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */</div><div class="line">    uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */</div><div class="line">    uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>dataoff</code>字段指明了相对于<code>__LINKEDIT</code>段的文件偏移位置，<code>datasize</code>字段指明了数据的大小。<br>由于<code>dataoff</code>与<code>datasize</code>分别指明了代码签名的位置与大小，那么笔者在此提个问：如何删除Mach-O中包含的代码签名信息？</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的“bsd/sys/codesign.h”文件中找到。整个代码签名部分的头部使用一个<code>CS_SuperBlob</code>结构体定义，它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_SuperBlob &#123;</div><div class="line">	uint32_t magic;					/* magic number */</div><div class="line">	uint32_t length;				/* total length of SuperBlob */</div><div class="line">	uint32_t count;					/* number of index entries following */</div><div class="line">	CS_BlobIndex index[];			/* (count) entries */</div><div class="line">	/* followed by Blobs in no particular order as indicated by offsets in index */</div><div class="line">&#125; CS_SuperBlob;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段指明了Blob的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">	CSMAGIC_REQUIREMENT = 0xfade0c00,		/* single Requirement blob */</div><div class="line">	CSMAGIC_REQUIREMENTS = 0xfade0c01,		/* Requirements vector (internal requirements) */</div><div class="line">	CSMAGIC_CODEDIRECTORY = 0xfade0c02,		/* CodeDirectory blob */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02,	/* XXX */</div><div class="line">	CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,	/* embedded entitlements */</div><div class="line">	CSMAGIC_DETACHED_SIGNATURE = 0xfade0cc1, /* multi-arch collection of embedded signatures */</div><div class="line">	CSMAGIC_BLOBWRAPPER = 0xfade0b01,	/* CMS Signature, among other things */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第一个Blob来说，它的值必定是<code>CSMAGIC_EMBEDDED_SIGNATURE</code>，表示代码签名采用的嵌入式的签名信息。<br><code>length</code>字段指明了整个SuperBlob的大小，其中包含马上的介绍的CodeDirectory、Requirement、Entitlement的大小。<br><code>count</code>字段指明了接下来会有多少个子条目。<br>从<code>index</code>开始，就是每一个字条目的索引了，它的结构是<code>CS_BlobIndex</code>，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct __BlobIndex &#123;</div><div class="line">	uint32_t type;					/* type of entry */</div><div class="line">	uint32_t offset;				/* offset of entry */</div><div class="line">&#125; CS_BlobIndex;</div></pre></td></tr></table></figure></p>
<p><code>type</code>指明了子条目的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSSLOT_CODEDIRECTORY = 0,				/* slot index for CodeDirectory */</div><div class="line">CSSLOT_INFOSLOT = 1,</div><div class="line">CSSLOT_REQUIREMENTS = 2,</div><div class="line">CSSLOT_RESOURCEDIR = 3,</div><div class="line">CSSLOT_APPLICATION = 4,</div><div class="line">CSSLOT_ENTITLEMENTS = 5,</div><div class="line">CSSLOT_SIGNATURESLOT = 0x10000,			/* CMS Signature */</div></pre></td></tr></table></figure></p>
<p><code>offset</code>字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>通常，签名后的程序，签名数据的第一个子条目指向的是一个<code>type</code>为<code>CSSLOT_CODEDIRECTORY</code>的结构，它是一个<code>CS_CodeDirectory</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct __CodeDirectory &#123;</div><div class="line">	uint32_t magic;					/* magic number (CSMAGIC_CODEDIRECTORY) */</div><div class="line">	uint32_t length;				/* total length of CodeDirectory blob */</div><div class="line">	uint32_t version;				/* compatibility version */</div><div class="line">	uint32_t flags;					/* setup and mode flags */</div><div class="line">	uint32_t hashOffset;			/* offset of hash slot element at index zero */</div><div class="line">	uint32_t identOffset;			/* offset of identifier string */</div><div class="line">	uint32_t nSpecialSlots;			/* number of special hash slots */</div><div class="line">	uint32_t nCodeSlots;			/* number of ordinary (code) hash slots */</div><div class="line">	uint32_t codeLimit;				/* limit to main image signature range */</div><div class="line">	uint8_t hashSize;				/* size of each hash in bytes */</div><div class="line">	uint8_t hashType;				/* type of hash (cdHashType* constants) */</div><div class="line">	uint8_t platform;				/* platform identifier; zero if not platform binary */</div><div class="line">	uint8_t	pageSize;				/* log2(page size in bytes); 0 =&gt; infinite */</div><div class="line">	uint32_t spare2;				/* unused (must be zero) */</div><div class="line">	/* Version 0x20100 */</div><div class="line">	uint32_t scatterOffset;				/* offset of optional scatter vector */</div><div class="line">	/* Version 0x20200 */</div><div class="line">	uint32_t teamOffset;				/* offset of optional team identifier */</div><div class="line">	/* followed by dynamic content as located by offset fields above */</div><div class="line">&#125; CS_CodeDirectory;</div></pre></td></tr></table></figure></p>
<p>该结构体数据字段较多，此处只关注与签名相关的字段。<code>hashOffset</code>指明了Hash数据的文件相对偏移，注意是相对于当前结构体<code>CS_CodeDirectory</code>，<code>hashType</code>与<code>hashSize</code>指明了代码签名时使用的算法与每一项签名数据的长度，目前macOS使用的签名算法是SHA-1，长度为20字节。<br><code>nSpecialSlots</code>与<code>nCodeSlots</code>指定的代码签名数据条目的个数，前者是针对代码签名中所有的Blob，后者针对程序文件内容。<code>codesign</code>程序在对程序进行签名时，会对SuperBlob中每个子条目进行签名，即对Blob的内容调用SHA-1算法取Hash值，<code>nSpecialSlots</code>的值就是子条目Blob的个数；同时，<code>codesign</code>会以<code>pageSize</code>字段指定的页大小为单位（通常取值是0x1000），对程序数据进行签名，每一页签名后生成一条签名数据，<code>nCodeSlots</code>的值就是签名数据的页数，即程序数据大小除以<code>pageSize</code>字段后的值。</p>
<p>在<code>CS_CodeDirectory</code>之后，就是Requirements了，它是一个<code>CS_SuperBlob</code>结构体，指明了Requirement的个数与每一个的偏移。接下来就是每一个Requirement数据了，它是一个<code>CS_GenericBlob</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_GenericBlob &#123;</div><div class="line">	uint32_t magic;				/* magic number */</div><div class="line">	uint32_t length;			/* total length of blob */</div><div class="line">	char data[];</div><div class="line">&#125; CS_GenericBlob;</div></pre></td></tr></table></figure></p>
<p>可以看到，它的前两个字段与<code>CS_SuperBlob</code>是一样的，只是后面多出一个<code>data</code>字段，用来存放Blob的数据长度。<br>在Requirement数据下面，就是Entitlement了，它同样是<code>CS_GenericBlob</code>结构。拿本机Calculator计算器程序来说，它的Entitlement的数据内容是一个xml文件，提取出来内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class="line">&lt;plist version=&quot;1.0&quot;&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.network.client&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.print&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">&lt;/dict&gt;</div><div class="line">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>
<p>最后一个Blob通常是签名使用的证书了，Certificates签名证书也是<code>CS_GenericBlob</code>结构，提取它的证书数据后保存为cer文件，使用macOS的文件预览证书内容，效果如图所示：<br><img src="/2017/01/13/macho/calc_cer.png" alt="calc_cer"></p>
<p>下面再来看看，系统是如何实施代码签名验证的！内核加载解析Mach-O加载命令的函数是<code>parse_machfile()</code>，位于内核代码”/bsd/kern/mach_loader.c“文件中，部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	uint32_t		ncmds;</div><div class="line">	struct load_command	*lcp;</div><div class="line">	struct dylinker_command	*dlp = 0;</div><div class="line">	integer_t		dlarchbits = 0;</div><div class="line">	void *			control;</div><div class="line">	load_return_t		ret = LOAD_SUCCESS;</div><div class="line">	caddr_t			addr;</div><div class="line">	void *			kl_addr;</div><div class="line">	vm_size_t		size,kl_size;</div><div class="line">	size_t			offset;</div><div class="line">	size_t			oldoffset;	/* for overflow check */</div><div class="line">	int			pass;</div><div class="line">	proc_t			p = current_proc();		/* XXXX */</div><div class="line">	int			error;</div><div class="line">	int resid=0;</div><div class="line">	size_t			mach_header_sz = sizeof(struct mach_header);</div><div class="line">	boolean_t		abi64;</div><div class="line">	boolean_t		got_code_signatures = FALSE;</div><div class="line">	int64_t			slide = 0;</div><div class="line"></div><div class="line">	if (header-&gt;magic == MH_MAGIC_64 ||</div><div class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</div><div class="line">	    	mach_header_sz = sizeof(struct mach_header_64);</div><div class="line">	&#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">	case LC_CODE_SIGNATURE:</div><div class="line">		/* CODE SIGNING */</div><div class="line">		if (pass != 1)</div><div class="line">			break;</div><div class="line">		/* pager -&gt; uip -&gt;</div><div class="line">			load signatures &amp; store in uip</div><div class="line">			set VM object &quot;signed_pages&quot;</div><div class="line">		*/</div><div class="line">		ret = load_code_signature(</div><div class="line">			(struct linkedit_data_command *) lcp,</div><div class="line">			vp,</div><div class="line">			file_offset,</div><div class="line">			macho_size,</div><div class="line">			header-&gt;cputype,</div><div class="line">			result);</div><div class="line">		if (ret != LOAD_SUCCESS) &#123;</div><div class="line">			printf(&quot;proc %d: load code signature error %d &quot;</div><div class="line">					&quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">			/*</div><div class="line">				* Allow injections to be ignored on devices w/o enforcement enabled</div><div class="line">				*/</div><div class="line">			if (!cs_enforcement(NULL))</div><div class="line">				ret = LOAD_SUCCESS; /* ignore error */</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			got_code_signatures = TRUE;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (got_code_signatures) &#123;</div><div class="line">			unsigned tainted = CS_VALIDATE_TAINTED;</div><div class="line">			boolean_t valid = FALSE;</div><div class="line">			struct cs_blob *blobs;</div><div class="line">			vm_size_t off = 0;</div><div class="line"></div><div class="line"></div><div class="line">			if (cs_debug &gt; 10)</div><div class="line">				printf(&quot;validating initial pages of %s\n&quot;, vp-&gt;v_name);</div><div class="line">			blobs = ubc_get_cs_blobs(vp);</div><div class="line"></div><div class="line">			while (off &lt; size &amp;&amp; ret == LOAD_SUCCESS) &#123;</div><div class="line">					tainted = CS_VALIDATE_TAINTED;</div><div class="line"></div><div class="line">					valid = cs_validate_page(blobs,</div><div class="line">								NULL,</div><div class="line">								file_offset + off,</div><div class="line">								addr + off,</div><div class="line">								&amp;tainted);</div><div class="line">					if (!valid || (tainted &amp; CS_VALIDATE_TAINTED)) &#123;</div><div class="line">						if (cs_debug)</div><div class="line">							printf(&quot;CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n&quot;,</div><div class="line">							vp-&gt;v_name, p-&gt;p_pid, (long long)(file_offset + off), valid, tainted, result-&gt;csflags);</div><div class="line">						if (cs_enforcement(NULL) ||</div><div class="line">						(result-&gt;csflags &amp; (CS_HARD|CS_KILL|CS_ENFORCEMENT))) &#123;</div><div class="line">							ret = LOAD_FAILURE;</div><div class="line">						&#125;</div><div class="line">						result-&gt;csflags &amp;= ~CS_VALID;</div><div class="line">					&#125;</div><div class="line">					off += PAGE_SIZE;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>整个代码签名的验证过程大致分为<code>load_code_signature()</code>与<code>cs_validate_page()</code>两步，前者负责加载代码签名，后者负责验证数据页面。<code>load_code_signature()</code>在加载代码签名时，通过调用<code>ubc_cs_blob_get()</code>来获取特定CPU的<code>cs_blob</code>指针，<code>ubc_cs_blob_get()</code>第一次调用时，返回的<code>cs_blob</code>指针为空，会调用<code>ubc_cs_blob_add()</code>来加载与验证文件中的Blob信息，以后再调用<code>ubc_cs_blob_get()</code>，就会返回内存中的<code>cs_blob</code>指针，当然不是直接返回，系统会再次判断内存中的<code>cs_blob</code>指针是否损坏或遭到篡改，具体方法是调用<code>ubc_cs_generation_check()</code>做初步的检查，之后调用<code>ubc_cs_blob_revalidate()</code>对blob做重验证。load_code_signature()`函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">static load_return_t</div><div class="line">load_code_signature(</div><div class="line">	struct linkedit_data_command	*lcp,</div><div class="line">	struct vnode			*vp,</div><div class="line">	off_t				macho_offset,</div><div class="line">	off_t				macho_size,</div><div class="line">	cpu_type_t			cputype,</div><div class="line">	load_result_t			*result)</div><div class="line">&#123;</div><div class="line">	int		ret;</div><div class="line">	kern_return_t	kr;</div><div class="line">	vm_offset_t	addr;</div><div class="line">	int		resid;</div><div class="line">	struct cs_blob	*blob;</div><div class="line">	int		error;</div><div class="line">	vm_size_t	blob_size;</div><div class="line"></div><div class="line">	addr = 0;</div><div class="line">	blob = NULL;</div><div class="line"></div><div class="line">	if (lcp-&gt;cmdsize != sizeof (struct linkedit_data_command) ||</div><div class="line">	    lcp-&gt;dataoff + lcp-&gt;datasize &gt; macho_size) &#123;</div><div class="line">		ret = LOAD_BADMACHO;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line">	if (blob != NULL) &#123;</div><div class="line">		/* we already have a blob for this vnode and cputype */</div><div class="line">		if (blob-&gt;csb_cpu_type == cputype &amp;&amp;</div><div class="line">		    blob-&gt;csb_base_offset == macho_offset &amp;&amp;</div><div class="line">		    blob-&gt;csb_mem_size == lcp-&gt;datasize) &#123;</div><div class="line">			/* it matches the blob we want here, lets verify the version */</div><div class="line">			if(0 != ubc_cs_generation_check(vp)) &#123;</div><div class="line">				if (0 != ubc_cs_blob_revalidate(vp, blob, 0)) &#123;</div><div class="line">					ret = LOAD_FAILURE; /* set error same as from ubc_cs_blob_add */</div><div class="line">					goto out;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			ret = LOAD_SUCCESS;</div><div class="line">		&#125; else &#123;</div><div class="line">			/* the blob has changed for this vnode: fail ! */</div><div class="line">			ret = LOAD_BADMACHO;</div><div class="line">		&#125;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob_size = lcp-&gt;datasize;</div><div class="line">	kr = ubc_cs_blob_allocate(&amp;addr, &amp;blob_size);</div><div class="line">	if (kr != KERN_SUCCESS) &#123;</div><div class="line">		ret = LOAD_NOSPACE;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resid = 0;</div><div class="line">	error = vn_rdwr(UIO_READ,</div><div class="line">			vp,</div><div class="line">			(caddr_t) addr,</div><div class="line">			lcp-&gt;datasize,</div><div class="line">			macho_offset + lcp-&gt;dataoff,</div><div class="line">			UIO_SYSSPACE,</div><div class="line">			0,</div><div class="line">			kauth_cred_get(),</div><div class="line">			&amp;resid,</div><div class="line">			current_proc());</div><div class="line">	if (error || resid != 0) &#123;</div><div class="line">		ret = LOAD_IOERROR;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (ubc_cs_blob_add(vp,</div><div class="line">			    cputype,</div><div class="line">			    macho_offset,</div><div class="line">			    addr,</div><div class="line">			    lcp-&gt;datasize,</div><div class="line">			    0)) &#123;</div><div class="line">		ret = LOAD_FAILURE;</div><div class="line">		goto out;</div><div class="line">	&#125; else &#123;</div><div class="line">		/* ubc_cs_blob_add() has consumed &quot;addr&quot; */</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">#if CHECK_CS_VALIDATION_BITMAP</div><div class="line">	ubc_cs_validation_bitmap_allocate( vp );</div><div class="line">#endif</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line"></div><div class="line">	ret = LOAD_SUCCESS;</div><div class="line">out:</div><div class="line">	if (ret == LOAD_SUCCESS) &#123;</div><div class="line">		result-&gt;csflags |= blob-&gt;csb_flags;</div><div class="line">		result-&gt;platform_binary = blob-&gt;csb_platform_binary;</div><div class="line">		result-&gt;cs_end_offset = blob-&gt;csb_end_offset;</div><div class="line">	&#125;</div><div class="line">	if (addr != 0) &#123;</div><div class="line">		ubc_cs_blob_deallocate(addr, blob_size);</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，上面提到的<code>cs_blob</code>指针，其实就是代码签名数据中的<code>CS_SuperBlob</code>指针类型。<br><code>ubc_cs_blob_add()</code>的代码比较长，它主要做了三个工作：一是调用<code>cs_validate_csblob()</code>验证<code>cs_blob</code>指针的合法性，<code>cs_validate_csblob()</code>会对<code>CSMAGIC_EMBEDDED_SIGNATURE</code>与<code>CSMAGIC_CODEDIRECTORY</code>做相应的验证处理，包括调用<code>cs_validate_codedirectory()</code>验证<code>CS_CodeDirectory</code>结构体的合法性，以及调用<code>cs_validate_blob()</code>来验证<code>CS_SuperBlob</code>中每一个<code>CS_GenericBlob</code>是否合法有效；二是调用<code>mac_vnode_check_signature()</code>验证Blob块的代码签名，也就是比较Blob块的SHA1哈希值是否与计算的值相同；三是加载所有的代码签名Hash信息，填充<code>cs_blobs</code>字段，为下一步的内存页签名验证做准备。<br><code>ubc_cs_blob_revalidate()</code>做着与<code>ubc_cs_blob_add()</code>几乎相同的验证检查，但前者因为已经有了一些缓存信息，因此检查时会快一些。</p>
<p><code>load_code_signature()</code>完事以后，会调用<code>ubc_get_cs_blobs()</code>获取<code>cs_blobs</code>指针，最后调用<code>cs_validate_page()</code>以逐页的形式验证文件中每一页的数据的签名。<br>以上检查做完后，<code>LC_CODE_SIGNATURE</code>就处理完了，没有错误发生就表示代码签名验证通过了。</p>
<p>讲完了代码签名，再讲讲代码加密。Mach-O程序如果使用了代码加密技术，在加载命令列表中会有一个<code>LC_ENCRYPTION_INFO</code>加载命令。它存储了Mach-O的加密信息。关于此加载命令，对于搞过iOS程序逆向的读者应该不会感到陌生。iOS系统由于安全机制的原因，会对App Store中上架的应用默认开启数据加密。<br>被加密过的App文件，部分段的数据内容是经过加密的，而记录加密数据的关键就是<code>LC_ENCRYPTION_INFO</code>加载命令。分析人员要想对加密过的App进行逆向分析，必须先经过一次解密（俗称“砸壳”）操作。<br><code>LC_ENCRYPTION_INFO</code>使用<code>encryption_info_command</code>结构体表示。定义如下（<code>LC_ENCRYPTION_INFO_64</code>使用<code>encryption_info_command_64</code>表示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct encryption_info_command &#123;</div><div class="line">   uint32_t	cmd;		/* LC_ENCRYPTION_INFO */</div><div class="line">   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command) */</div><div class="line">   uint32_t	cryptoff;	/* file offset of encrypted range */</div><div class="line">   uint32_t	cryptsize;	/* file size of encrypted range */</div><div class="line">   uint32_t	cryptid;	/* which enryption system, 0 means not-encrypted yet */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cryptoff</code>与<code>cryptsize</code>字段分别指明了加密数据的文件偏移与大小。<code>cryptid</code>指定了使用的加密系统。<br>聪明的安全研究人员，根据Mach-O在内存中被加载完后即解密完成的特点，开发了针对iOS平台App的代码解密工具<code>dumpdecrypted</code>，<br>下载地址是：<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">https://github.com/stefanesser/dumpdecrypted</a> 。通过将内存中解密后的数据写回原位置，并将<code>cryptid</code>置0来达到解密App的目的。</p>
<p>再来看看系统是如何处理<code>LC_ENCRYPTION_INFO</code>的，它的解析函数也是<code>parse_machfile()</code>，代码片断如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line">			case LC_ENCRYPTION_INFO:</div><div class="line">			case LC_ENCRYPTION_INFO_64:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				ret = set_code_unprotect(</div><div class="line">					(struct encryption_info_command *) lcp,</div><div class="line">					addr, map, slide, vp,</div><div class="line">					header-&gt;cputype, header-&gt;cpusubtype);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: set_code_unprotect() error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					/*</div><div class="line">					 * Don&apos;t let the app run if it&apos;s</div><div class="line">					 * encrypted but we failed to set up the</div><div class="line">					 * decrypter. If the keys are missing it will</div><div class="line">					 * return LOAD_DECRYPTFAIL.</div><div class="line">					 */</div><div class="line">					 if (ret == LOAD_DECRYPTFAIL) &#123;</div><div class="line">						/* failed to load due to missing FP keys */</div><div class="line">						proc_lock(p);</div><div class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</div><div class="line">						proc_unlock(p);</div><div class="line">					&#125;</div><div class="line">					 psignal(p, SIGKILL);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#endif</div><div class="line">			default:</div><div class="line">				/* Other commands are ignored by the kernel */</div><div class="line">				ret = LOAD_SUCCESS;</div><div class="line">				break;</div><div class="line"></div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>当系统内核被配置为启用代码解密，即定义了<code>CONFIG_CODE_DECRYPTION</code>之后，<code>parse_machfile()</code>函数会解析<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令。<br>最终是调用了<code>set_code_unprotect()</code>函数来对代码进行解密。该函数通过<code>encryption_info_command</code>中的<code>cryptid</code>来确定使用的加密系统，然后对代码进行内存解密。它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line"></div><div class="line">static load_return_t</div><div class="line">set_code_unprotect(</div><div class="line">		   struct encryption_info_command *eip,</div><div class="line">		   caddr_t addr, 	</div><div class="line">		   vm_map_t map,</div><div class="line">		   int64_t slide,</div><div class="line">		   struct vnode	*vp,</div><div class="line">		   cpu_type_t cputype,</div><div class="line">		   cpu_subtype_t cpusubtype)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if (eip-&gt;cmdsize &lt; sizeof(*eip)) return LOAD_BADMACHO;</div><div class="line"></div><div class="line">	switch(eip-&gt;cryptid) &#123;</div><div class="line">		case 0:</div><div class="line">			/* not encrypted, just an empty load command */</div><div class="line">			return LOAD_SUCCESS;</div><div class="line">		case 1:</div><div class="line">			cryptname=&quot;com.apple.unfree&quot;;</div><div class="line">			break;</div><div class="line">		case 0x10:</div><div class="line">			/* some random cryptid that you could manually put into</div><div class="line">			 * your binary if you want NULL */</div><div class="line">			cryptname=&quot;com.apple.null&quot;;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			return LOAD_BADMACHO;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (map == VM_MAP_NULL) return (LOAD_SUCCESS);</div><div class="line">	if (NULL == text_crypter_create) return LOAD_FAILURE;</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	/* set up decrypter first */</div><div class="line">	crypt_file_data_t crypt_data = &#123;</div><div class="line">		.filename = vpath,</div><div class="line">		.cputype = cputype,</div><div class="line">		.cpusubtype = cpusubtype&#125;;</div><div class="line">	kr=text_crypter_create(&amp;crypt_info, cryptname, (void*)&amp;crypt_data);</div><div class="line">	FREE_ZONE(vpath, MAXPATHLEN, M_NAMEI);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	offset = mach_header_sz;</div><div class="line">	uint32_t ncmds = header-&gt;ncmds;</div><div class="line">	while (ncmds--) &#123;</div><div class="line">		/*</div><div class="line">		 *	Get a pointer to the command.</div><div class="line">		 */</div><div class="line">		struct load_command *lcp = (struct load_command *)(addr + offset);</div><div class="line">		offset += lcp-&gt;cmdsize;</div><div class="line"></div><div class="line">		switch(lcp-&gt;cmd) &#123;</div><div class="line">			case LC_SEGMENT_64:</div><div class="line">				seg64 = (struct segment_command_64 *)lcp;</div><div class="line">				if ((seg64-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg64-&gt;fileoff+seg64-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg64-&gt;vmaddr + eip-&gt;cryptoff - seg64-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">			case LC_SEGMENT:</div><div class="line">				seg32 = (struct segment_command *)lcp;</div><div class="line">				if ((seg32-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg32-&gt;fileoff+seg32-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg32-&gt;vmaddr + eip-&gt;cryptoff - seg32-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* if we get here, did not find anything */</div><div class="line">	return LOAD_BADMACHO;</div><div class="line"></div><div class="line">remap_now:</div><div class="line">	/* now remap using the decrypter */</div><div class="line">	kr = vm_map_apple_protected(map, map_offset, map_offset+map_size, &amp;crypt_info);</div><div class="line">	if(kr) &#123;</div><div class="line">		printf(&quot;set_code_unprotect(): mapping failed with %x\n&quot;, kr);</div><div class="line">		crypt_info.crypt_end(crypt_info.crypt_ops);</div><div class="line">		return LOAD_PROTECT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return LOAD_SUCCESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p><code>text_crypter_create()</code>是一个全局的<code>text_crypter_create_hook_t</code>类型的指针，在内核代码“osfmk/kern/page_decrypt.c”文件中通过<code>text_crypter_create_hook_set()</code>进行设置。<br><code>text_crypter_create()</code>在填充完解密所需的信息<code>crypt_info</code>后，会再次计算需要重新解密映射到内存的地址与大小，调用<code>vm_map_apple_protected()</code>进行解密操作。</p>
<p>由于内核的代码可以直接审阅，数据加密在macOS系统上显得意义不大，在目前最新的macOS 10.12系统上，苹果没有启用代码解密功能，<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令也就没那么常见了。</p>
<p>最后，可以使用<code>otool</code>命令行工具来查看Mach-O文件的加载命令信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> otool -l /usr/bin/python</div><div class="line">/usr/bin/python:</div><div class="line">Load command 0</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 72</div><div class="line">  segname __PAGEZERO</div><div class="line">   vmaddr 0x0000000000000000</div><div class="line">   vmsize 0x0000000100000000</div><div class="line">  fileoff 0</div><div class="line"> filesize 0</div><div class="line">  maxprot 0x00000000</div><div class="line"> initprot 0x00000000</div><div class="line">   nsects 0</div><div class="line">    flags 0x0</div><div class="line">Load command 1</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">    ......</div><div class="line">Load command 15</div><div class="line">      cmd LC_DATA_IN_CODE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 17776</div><div class="line"> datasize 0</div><div class="line">Load command 16</div><div class="line">      cmd LC_CODE_SIGNATURE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 20528</div><div class="line"> datasize 9344</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>MachOView</code>查看，效果如图所示：<br><img src="/2017/01/13/macho/load_command.png" alt="load_command"></p>
<h2 id="0x6-LC-SEGMENT"><a href="#0x6-LC-SEGMENT" class="headerlink" title="0x6 LC_SEGMENT"></a>0x6 LC_SEGMENT</h2><p>段加载命令<code>LC_SEGMENT</code>，描述了32位Mach-O文件的段的信息，使用<code>segment_command</code>结构体来表示，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command &#123; /* for 32-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint32_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint32_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint32_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint32_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>segname</code>字段是一个16字节大小的空间，用来存储段的名称。<br><code>vmaddr</code>字段指明了段要加载的虚拟内存地址。<br><code>vmsize</code>字段指明了段所占的虚拟内存的大小。<br><code>fileoff</code>字段指明了段数据所在文件中偏移地址。<br><code>filesize</code>字段指明了段数据实际的大小。<br><code>maxprot</code>字段指明了页面所需要的最高内存保护。<br><code>initprot</code>字段指明了页面初始的内存保护。<br><code>nsects</code>字段指明了段所包含的节区（section）。<br><code>flags</code>字段指明了段的标志信息。</p>
<p>与<code>LC_SEGMENT</code>对应的是<code>LC_SEGMENT_64</code>，它使用<code>segment_command_64</code>结构体表示，描述了64位Mach-O文件的段的基本信息，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section_64 structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint64_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint64_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint64_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的字段含义与32位基本一致。主要讨论一下它最后4个字段。</p>
<p>一个编译后可能执行的程序分成了多个段，不同的类型的数据放入了不同的段中。如程序的代码被称作代码段，<br>放入一个名为<code>__TEXT</code>的段中，代码段的<code>maxprot</code>字段在编译时被设置成<code>VM_PROT_READ</code>（可读）、<code>VM_PROT_WRITE</code>（可写）、<code>VM_PROT_EXECUTE</code>（可执行），<code>initprot</code>字段被设置成<br><code>VM_PROT_READ</code>（可读）与<code>VM_PROT_EXECUTE</code>（可执行），这样做是合理的，一个普通的应用程序，它的代码段部分通常是不可写的，特殊需求的程序，如果要求代码段可写，必须在编译时设置它的<br><code>initprot</code>字段为<code>VM_PROT_WRITE</code>（可写）。</p>
<p><code>nsects</code>字段指定了段加载命令包含几个节区（section），一个段可以包含0个或多个节区。如<code>__PAGEZERO</code>段就不包含任何节区，该段被称为空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。<br>当一个段包含多个节区时，节区信息会以数组形式紧随着存储在段加载命令后面。节区使用结构体<code>section</code>表示（64位使用<code>section_64</code>表示），定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">	char		sectname[16];	/* name of this section */</div><div class="line">	char		segname[16];	/* segment this section goes in */</div><div class="line">	uint32_t	addr;		/* memory address of this section */</div><div class="line">	uint32_t	size;		/* size in bytes of this section */</div><div class="line">	uint32_t	offset;		/* file offset of this section */</div><div class="line">	uint32_t	align;		/* section alignment (power of 2) */</div><div class="line">	uint32_t	reloff;		/* file offset of relocation entries */</div><div class="line">	uint32_t	nreloc;		/* number of relocation entries */</div><div class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</div><div class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</div><div class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>sectname</code>字段表示节区的名称，<code>segname</code>字段表示节区所在的段名，<code>addr</code>与<code>size</code>指明了节区所在的内存地址与大小，<code>offset</code>指明了区取所在的文件偏移，<br><code>align</code>表示节区的内存对齐边界，<code>reloff</code>指明了重定位信息的文件偏移，<code>nreloc</code>表示重定位条目的数目，<code>flags</code>则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段<code>flags</code>存储了段的一些标志属性，它的取值有如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define	SG_HIGHVM	0x1</div><div class="line">#define	SG_FVMLIB	0x2</div><div class="line">#define	SG_NORELOC	0x4</div><div class="line">#define SG_PROTECTED_VERSION_1	0x8</div></pre></td></tr></table></figure></p>
<p>值得关注的是<code>SG_PROTECTED_VERSION_1</code>，当段被设置了该标志位，表示段是经过加密的！在macOS版本10.6以前，系统使用AES算法进行段的加密与解密，10.6的时候，则使用的Blowfish加密算法，著名的iOS逆向工具<code>class-dump</code>（地址：<a href="https://github.com/nygard/class-dump）" target="_blank" rel="external">https://github.com/nygard/class-dump）</a> 提供了一个静态数据段解密工具<code>deprotect</code>，有兴趣的读者可以参看它的代码来了解段解密的部分。</p>
<p>最后，使用<code>MachOView</code>工具查看系统python程序的<code>__TEXT</code>段的信息如图所示：<br><img src="/2017/01/13/macho/python_seg.png" alt="python_seg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/13/macho/" data-id="cixv4zw4r0004v7vj3syulcu4" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-install-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/install-software/" class="article-date">
  <time datetime="2017-01-12T03:27:10.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/install-software/">macOS平台软件的下载与安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于一个操作系统来说，对其影响最大的莫过于运行在它上面的软件，正因为这些形形色色软件的存在，操作系统才得以广泛应用。与Linux、Windows等主流操作系统一样，运行在macOS上的软件也有着自己独有的特点。</p>
<p>macOS上的软件有着自己独特的UI界面与操作方式。macOS的设计师一直秉承着自己的设计理念，设计出的Aqua界面别具风格。银灰的金属色主题始终是分辨macOS系统最快捷的一种方式，与Windows界面将最小按钮与关闭按钮设置到窗口右上角不同，Aqua界面的程序，最小化与关闭按钮位于软件的左上角，并且使用全屏按钮替换了Windows上的最大化按钮。进入全屏模式下的软件会新开一个窗口并占据屏幕的全部空间，可以在触摸板上使用三根手指左右划动来切换不同的全屏窗口。</p>
<p>每个常规的Aqua界面的程序都有一个菜单，菜单显示在用户屏幕的顶端，菜单的最左边始终是一个苹果图标，点击它会弹出系统设置、<code>App Store</code>、关机、重启等多个选项。<br>macOS使用Dock栏来管理显示常用的软件，它位于用户屏幕的底部，展示效果与Windows的任务栏相似，正在运行的macOS界面程序，都可以在Dock上右键点击该程序，在弹出的菜单中选择Options-&gt;Keep in Dock，将程序在Dock上保留下来，以后就可以直接从Dock中单击图标启动程序。<br>在Windows系统中，用户可以使用开始菜单-&gt;所有程序来找到系统中安装的软件并启动它，macOS中则提供了一个<code>Launchpad</code>程序来管理安装在/Applications目录中的软件。<code>Launchpad</code>移植于iOS系统中的<code>SpringBoard</code>，展示的效果也与之类似，它以全屏网格形式的界面显示了所有可以运行的软件与系统工具，如果软件安装过多，会以多个页面来展示。点击Dock上的<code>Launchpad</code>图标可以启动它，如图所示：<br><img src="/2017/01/12/install-software/launchpad.png" alt="launchpad"><br>使用二根手指左右划动可以在不同的页面间切换。</p>
<h3 id="0x0-可执行文件"><a href="#0x0-可执行文件" class="headerlink" title="0x0 可执行文件"></a>0x0 可执行文件</h3><p>除了Aqua界面的程序，macOS上还可以运行很多其它种类的文件，这里将所有可以运行在macOS系统上文件的统称为macOS可执行文件。</p>
<p>首先是脚本，macOS提供了UNIX系统中的Shell环境来支持运行脚本与命令行程序，脚本实质是一个文本文件，在脚本文件中指定运行它解释器后，Shell在运行脚本时，会调用解释器来解释运行它，任何一个文件都可以通过执行”chmod +x”命令给它加上可执行权限，拥有可执行权限的文件并不一定能执行，它必须是能满足某种解释器的语法规则才算得上可执行文件。<br>除了主流的几种Shell脚本支持外，macOS还内置了目前比较流行的<code>Perl</code>、<code>Python</code>和<code>Ruby</code>等脚本的解释器，任何人都可以直接编写<code>Perl</code>、<code>Python</code>和<code>Ruby</code>脚本并调用它们的解释器来运行，而不需要安装额外的软件。</p>
<p>另外，苹果公司还开发了一种脚本：AppleScript（苹果脚本）。它的作用是用于运行在macOS的程序并实际自动化工作的。苹果提供了一个单独的脚本编辑器来开发与调试AppleScript。它位于/Applications/Ｕtilities/Script Editor。使用<code>Script Editor</code>编写好的脚本保存的格式为scpt。随着macOS系统的不断升级，<code>AppleScript</code>也在不停的发展，目前甚至可以使用<code>AppleScript</code>来开发macOS上的界面程序。具体的步骤是在XCode中选择File-&gt;New-&gt;Project，在打开的对话框中选择Other-&gt;Cocoa-AppleScript。有兴趣的读者可以参看苹果的官方文档来深入了解AppleScript，地址上：<a href="https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html</a> 。</p>
<p>除了脚本外，可执行文件还包括可以由用户主动执行的程序与被动执行的程序文件。<br>主动执行的程序包括：GUI界面程序、命令行程序、游戏等；被动执行的程序包括被系统调用的程序，如：<code>Quick Look</code>插件、屏幕保护程序、内核驱动与扩展等，以及被程序调用的框架、库、Bundle、XPC服务等。所有的这些可执行文件都使用苹果独有的可执行文件格式Mach-O。关于Mach-O文件的格式，将在后面的小节中进行详细讲解。</p>
<h3 id="0x1-下载与安装软件"><a href="#0x1-下载与安装软件" class="headerlink" title="0x1 下载与安装软件"></a>0x1 下载与安装软件</h3><p>苹果支持从自家的<code>App Store</code>应用商店直接安装软件，也支持从第三方渠道，如其它磁盘介质、网络下载来安装软件。从<code>App Store</code>下载软件是最方便快捷，也是最安全的一种方式，苹果公司一向以软件审查严格闻名，自家商店中的应用软件在界面、功能以及对系统资源的使用上，都是经常严格审查与限制的，对于普通用户来说，这种下载软件的方式最合适不过了，但对于专业用户来说，由于一些专业软件在用户授权协议、资源访问上或其它方面的原因未能在<code>App Store</code>上架，就只能从网络或第三方渠道来获取这类软件了。</p>
<h4 id="0x1-1-免费与付费软件"><a href="#0x1-1-免费与付费软件" class="headerlink" title="0x1.1 免费与付费软件"></a>0x1.1 免费与付费软件</h4><p><code>App Store</code>应用商店上提供了丰富的免费与付费的软件供用户下载使用。下载免费的软件不需要用户付出额外的成本，只需要到官网<a href="https://appleid.apple.com/" target="_blank" rel="external">https://appleid.apple.com/</a> 注册一个的帐号，使用帐号登录<code>App Store</code>就可以下载上面的免费软件了。<br>如果要下载<code>App Store</code>上面的收费软件，需要为帐号绑定一张银行卡，购买软件成功后会直接从银行卡中扣取费用。另外，<code>App Store</code>中的软件还支持另一种收费方式：<code>In-App Purchase</code>（应用内付费），简称IAP，这种收费方式在苹果自家的iOS系统中应用非常广泛，它允许开发人员为自己的软件某些特定功能设定为需要购买才能使用，目前，很多软件开发商以此平台作为主要的软件收入来源。</p>
<p><code>App Store</code>中的收费软件只有IAP与直接购买这两种方式，而网络下载的收费软件的付费形式则丰富很多。部分软件官网只提供软件基础功能的演示版本供用户下载，如果需要使用正式版本，则需要联系软件开发商购买完整版本。例如著名的反汇编软件<code>IDA Pro</code>，官网就只提供了Demo版本可供下载：<a href="https://www.hex-rays.com/products/ida/support/download_demo.shtml" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/download_demo.shtml</a> ，正式版本需要找软件开发商或代理商购买。也有些软件的官网会提供完整版本下载，但会有使用时间或功能限制，如果需要正常无限制使用软件，则需要购买软件授权，如反汇编软件<code>Hopper</code>（<a href="http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010" target="_blank" rel="external">http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010</a> Editor`（<a href="http://www.sweetscape.com/010editor/）。" target="_blank" rel="external">http://www.sweetscape.com/010editor/）。</a></p>
<h4 id="0x1-2-安装软件"><a href="#0x1-2-安装软件" class="headerlink" title="0x1.2 安装软件"></a>0x1.2 安装软件</h4><p>普通的macOS软件只是一个以扩展名.app结尾的目录，这种目录有着特定的组织结构，macOS将它称之为Bundle，安装这类软件只需要将Bundle复制到系统的/Applications目录即可，复制完成后，<code>Launchpad</code>面板会自动更新安装好的软件图标，启动软件不需要到/Applications目录中去寻找它，只需要打开<code>Launchpad</code>，找到软件的图标并点击就可以运行该程序了。<br>从网络上下载的软件通常是经过打包后发布的，普通的软件多是zip或其它方式压缩后，以压缩包的形式提供下载，还有的使用磁盘工具将软件打包成一个dmg磁盘镜像文件，这类dmg文件内通常还会有一个Applications目录的软链接，安装的时候，只需要将dmg中的软件直接拖放到该软链接上就算完成安装了。如图所示，是<code>AppDelete</code>的安装镜像：<br><img src="/2017/01/12/install-software/install_app.png" alt="install_app"></p>
<p>macOS上的软件还有一种是以pkg或mpkg结尾的安装包，类似于Windows系统上的msi或exe安装程序，通过不停的点击下一步就可以完成安装，这类软件除了将主程序写入/Applications目录外，一般还会在系统上做一些只有管理员权限才能完成的动作，比如为特定的目录或文件创建软链接、安装与卸载内核扩展、复制命令行程序到用户可执行文件目录/usr/local/bin中等。因此，在安装的过程中，可能会提示输入管理员用户名与密码来执行需要Root权限的操作。</p>
<p>另一种是命令行工具，这类程序的安装使用第一章中介绍的<code>Homebrew</code>即可，此处不再赘述。</p>
<h3 id="0x3-Bundle"><a href="#0x3-Bundle" class="headerlink" title="0x3 Bundle"></a>0x3 Bundle</h3><p>Bundle是苹果系统独有的特色，在苹果系统上大量中使用了Bundle。</p>
<h4 id="0x3-1-Bundle目录结构"><a href="#0x3-1-Bundle目录结构" class="headerlink" title="0x3.1 Bundle目录结构"></a>0x3.1 Bundle目录结构</h4><p>安装到macOS系统上的软件有着自己特定的格式，它们是以.app扩展名结尾的Bundle目录结构。Bundle有着固定的组织格式，在Finder中查看Bundle的目录内容，可以在程序上点右键，在弹出的菜单中选择Show Package Contents，查看Bundle的目录结构。以/Applications目录下<code>App Store</code>为例，它的目录结构如图所示：<br><img src="/2017/01/12/install-software/bundle.png" alt="bundle"></p>
<p>在App Store.app目录下，只有一个Contents子目录，所有软件的内容都在此目录下。它们包括：</p>
<ul>
<li>CodeSignature目录。此目录下只有一个CodeResources文件，它是一个plist格式的文件，保存了软件包中所有文件的签名信息。</li>
<li>info.plist文件。此文件记录了软件的一些信息。如软件构建的机器的版本<code>BuildMachineOSBuild</code>、可执行文件名<code>CFBundleExecutable</code>、软件的标识<code>CFBundleIdentifier</code>、软件包名<code>CFBundleName</code>等。</li>
<li>MacOS目录。此目录存放了可执行文件。</li>
<li>Pkginfo文件。软件包的8字节的标识符。</li>
<li>Resources目录。软件运行所需要的资源，包括.iproj本地化资源、.nib资源、图片、字体、声音、文档以及其它文件。</li>
<li>Plugins目录。插件目录，存放了软件用到的插件，插件也是使用Bundle目录结构进行组织的一种程序。</li>
</ul>
<p>除了Plugins目录外，根据软件需求与实现的不同，Contents下可能还会有Frameworks与XPCServices目录，Frameworks里面存放了软件需要用到的框架，它是以.framework结尾的Bundle结构；XPCServices则存放了软件用到的XPC服务，它是以.xpc结尾的Bundle结构，还有一种以.bundle扩展名结尾的Bundle，它是“纯粹”的Bundle，目录结构与其它的Bundle无异，存放的内容可以是二进制代码，也可以是资源，也可以二者同时存放，如果存放二进制代码的话，可供程序在代码中使用<code>dlopen()</code>函数打开，这种Bundle通常用于制作软件的插件，存放在软件Bundle的Resources目录下。</p>
<h4 id="0x3-2-代码中访问Bundle"><a href="#0x3-2-代码中访问Bundle" class="headerlink" title="0x3.2 代码中访问Bundle"></a>0x3.2 代码中访问Bundle</h4><p>在程序中，开发人员可以使用<code>Cocoa</code>框架提供的<code>NSBundle</code>类来获取程序的Bundle信息。调用<code>NSBundle</code>的<code>mainBundle()</code>方法可以返回当前程序的主Bundle对象，调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSBundle *bundle = [NSBundle mainBundle]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>infoDictionary()</code>方法可以访问软件Bundle目录下info.plist文件中的信息，它返回的是一个字典对象，如下所示是获取程序标识符的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleIdentifier&quot;]]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>pathForResource()</code>方法可以访问Bundle目录下任意资源文件。如下所示是访问Bundle根目录下的monkey.png文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *monkey = [[NSBundle mainBundle] pathForResource:@&quot;monkey&quot; ofType:@&quot;png&quot;];</div></pre></td></tr></table></figure></p>
<p>与主Bundle对应的是自定义Bundle，这一类Bundle的访问可以这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *resourceBundle = [[NSBundle mainBundle] pathForResource:@&quot;ResPack&quot; ofType:@&quot;bundle&quot;];</div><div class="line">NSLog(@&quot;resourceBundle: %@&quot;, resourceBundle);</div><div class="line">NSString *monkey = [[NSBundle bundleWithPath:resourceBundle] pathForResource:@&quot;monkey&quot;</div><div class="line">			ofType:@&quot;png&quot; inDirectory:@&quot;Images&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;monkey path: %@&quot;, monkey);</div></pre></td></tr></table></figure></p>
<p>上面这段代码访问了ResPack.bundle中Images目录下的monkey.png文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/install-software/" data-id="cixv4zw4f0000v7vj20p7c6gt" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-new-chapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/new-chapter/" class="article-date">
  <time datetime="2017-01-11T05:56:48.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/new-chapter/">新的篇章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>欢迎来到 <a href="https://feicong.github.io/">非虫的博客</a>! 自从12年放弃百度空间后，再没写过博客了。</p>
<p>新的一年，新的篇章，非虫的博客全新开启，以此记录生活点滴，同时作为自己技术分享的平台，希望你会喜欢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/11/new-chapter/" data-id="cixv4zw4p0003v7vjv0m9ibph" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS软件安全/" style="font-size: 10px;">macOS软件安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/13/macho/">Mach-O文件格式</a>
          </li>
        
          <li>
            <a href="/2017/01/12/install-software/">macOS平台软件的下载与安装</a>
          </li>
        
          <li>
            <a href="/2017/01/12/macos-software/">［置顶］macOS软件安全系列-软件内幕篇</a>
          </li>
        
          <li>
            <a href="/2017/01/11/new-chapter/">新的篇章</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
      <div class="widget">
      	<ul>
        	
          	<li class='link'><a href='https://ydc1992.github.io'>Ken&#39;s Blog</a></li>
        	
      	</ul>
      </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>