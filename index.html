<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fEICOnG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="fEICOnG's Blog">
<meta property="og:url" content="https://feicong.github.io/index.html">
<meta property="og:site_name" content="fEICOnG's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fEICOnG's Blog">
  
    <link rel="alternate" href="/atom.xml" title="fEICOnG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fEICOnG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RE makes life easier</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://feicong.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-macos-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/macos-software/" class="article-date">
  <time datetime="2017-01-12T02:20:31.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/macos-software/">［置顶］macOS软件安全系列-软件内幕篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>macOS平台上的软件安全话题讨论在国内仍是软件安全领域的沼泽地带，除了在部分安全论坛上见过几篇破解分析的文章外，鲜有人问津。</p>
<p>如今，macOS平台的安全问题已经被越来越多的人关注，本系列的文章为macOS软件安全系列的一个篇章－软件内幕篇，探讨macOS系统上常见的文件格式与它们的管理方式，让各位关注软件安全领域的朋友，对macOS系统上的软件安全有直观的认识。</p>
<h2 id="每日一篇更新中…"><a href="#每日一篇更新中…" class="headerlink" title="每日一篇更新中…"></a>每日一篇更新中…</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本系列文章为非虫（微信：feicongcn）原创，任何个人与组织未经允许，不得转载与摘抄，否则，作者保留一切追究法律责任的权利。</p>
<h3 id="macOS平台软件的下载与安装"><a href="#macOS平台软件的下载与安装" class="headerlink" title="macOS平台软件的下载与安装"></a><a href="https://feicong.github.io/2017/01/12/install-software/">macOS平台软件的下载与安装</a></h3><h3 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a><a href="https://feicong.github.io/2017/01/13/macho/">Mach-O文件格式</a></h3><h3 id="dylib动态库加载过程分析"><a href="#dylib动态库加载过程分析" class="headerlink" title="dylib动态库加载过程分析"></a><a href="https://feicong.github.io/2017/01/14/dylib/">dylib动态库加载过程分析</a></h3><h3 id="静态库的管理与文件格式分析"><a href="#静态库的管理与文件格式分析" class="headerlink" title="静态库的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/15/staticlib/">静态库的管理与文件格式分析</a></h3><h3 id="PKG安装包的管理与文件格式分析"><a href="#PKG安装包的管理与文件格式分析" class="headerlink" title="PKG安装包的管理与文件格式分析"></a><a href="https://feicong.github.io/2017/01/16/pkg/">PKG安装包的管理与文件格式分析</a></h3><h3 id="DMG文件管理"><a href="#DMG文件管理" class="headerlink" title="DMG文件管理"></a><a href="https://feicong.github.io/2017/01/17/dmg/">DMG文件管理</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/macos-software/" data-id="cixww7ln70003f3vjeo04opmv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
  
</article>


  
    <article id="post-dylib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/14/dylib/" class="article-date">
  <time datetime="2017-01-14T01:42:58.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/14/dylib/">dylib动态库加载过程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Windows系统的动态库是DLL文件，Linux系统是so文件，macOS系统的动态库则使用dylib文件作为动态库。<br>dylib本质上是一个Mach-O格式的文件，它与普通的Mach-O执行文件几乎使用一样的结构，只是在文件类型上一个是<code>MH_DYLIB</code>，一个是<code>MH_EXECUTE</code>。<br>在系统的/usr/lib目录下，存放了大量供系统与应用程序调用的动态库文件，使用<code>file</code>命令查看系统动态库libobjc.dylib的信息，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ file /usr/lib/libobjc.dylib</div><div class="line">/usr/lib/libobjc.dylib: Mach-O universal binary with 3 architectures</div><div class="line">/usr/lib/libobjc.dylib (for architecture i386):	Mach-O dynamically linked shared library i386</div><div class="line">/usr/lib/libobjc.dylib (for architecture x86_64):	Mach-O 64-bit dynamically linked shared library x86_64</div><div class="line">/usr/lib/libobjc.dylib (for architecture x86_64h):	Mach-O 64-bit dynamically linked shared library x86_64</div></pre></td></tr></table></figure></p>
<p>从上面的输出信息可以看出，libobjc.dylib是一个通用的二进制文件，包含了三种cpu架构的Mach-O。另外，<br>可以使用Mach-O格式文件管理工具<code>otool</code>查看dylib的信息，如查看动态库的依赖库信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ otool -L /usr/lib/libobjc.dylib</div><div class="line">/usr/lib/libobjc.dylib:</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div><div class="line">	/usr/lib/libauto.dylib (compatibility version 1.0.0, current version 1.0.0)</div><div class="line">	/usr/lib/libc++abi.dylib (compatibility version 1.0.0, current version 125.0.0)</div><div class="line">	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 120.1.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1225.0.0)</div></pre></td></tr></table></figure></p>
<h2 id="0x1-构建动态库"><a href="#0x1-构建动态库" class="headerlink" title="0x1 构建动态库"></a>0x1 构建动态库</h2><p><code>XCode</code>环境提供了创建动态库的工程模板，创建动态库的方法比较简单，在<code>XCode</code>中选择File-&gt;New-&gt;Project，在打开的工程模选择对话框中，选择标签macOS-&gt;Framework &amp; Library，在右侧选择Library，点击Next按钮，在新页面中输入项目名称mylib，Type选择Dynamic，单击Next按钮选择项目保存的路径后，工程就创建好了。接着修改工程文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//mylib.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface mylib : NSObject</div><div class="line">-(void) hello;</div><div class="line">@end</div><div class="line"></div><div class="line">//mylib.m</div><div class="line">#import &quot;mylib.h&quot;</div><div class="line"></div><div class="line">@implementation mylib</div><div class="line">-(void) hello &#123;</div><div class="line">    NSLog(@&quot;hello world&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>保存后。觇击菜单Product-&gt;Build，或者按键般的COMMAND+B键就编译成功了。命令执行完后，就会生成mylib.dylib文件。<br>XCode创建的项目是xcodeproj文件，可以使用XCode提供的工具xcodebuild在命令行下编译，在命令行下切换到工程文件所在的目录后，执行<code>xcodebuild</code>会有如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">$ xcodebuild</div><div class="line">=== BUILD TARGET mylib OF PROJECT mylib WITH THE DEFAULT CONFIGURATION (Release) ===</div><div class="line"></div><div class="line">Check dependencies</div><div class="line"></div><div class="line">Write auxiliary files</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-own-target-headers.hmap</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-all-non-framework-target-headers.hmap</div><div class="line">......</div><div class="line">/bin/mkdir -p /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64</div><div class="line">write-file /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.LinkFileList</div><div class="line"></div><div class="line">CompileC build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.o mylib/mylib.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -fmessage-length=94 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu99 -fobjc-arc -fmodules -gmodules -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/var/folders/rd/mts0362j0n92rq0z1cnmdb580000gn/C/org.llvm.clang/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -Os -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wno-deprecated-implementations -DNS_BLOCK_ASSERTIONS=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -mmacosx-version-min=10.11 -g -Wno-sign-conversion -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-generated-files.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-own-target-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-all-target-headers.hmap -iquote /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/mylib-project-headers.hmap -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/include -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/DerivedSources/x86_64 -I/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/DerivedSources -F/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -MMD -MT dependencies -MF /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.d --serialize-diagnostics /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.dia -c /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/mylib/mylib.m -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.o</div><div class="line"></div><div class="line">Ld build/Release/libmylib.dylib normal x86_64</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export MACOSX_DEPLOYMENT_TARGET=10.11</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -L/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -F/Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release -filelist /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib.LinkFileList -install_name /usr/local/lib/libmylib.dylib -mmacosx-version-min=10.11 -fobjc-arc -fobjc-link-runtime -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/mylib.build/Release/mylib.build/Objects-normal/x86_64/mylib_dependency_info.dat -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib</div><div class="line"></div><div class="line">GenerateDSYMFile build/Release/libmylib.dylib.dSYM build/Release/libmylib.dylib</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib -o /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib.dSYM</div><div class="line"></div><div class="line">CodeSign build/Release/libmylib.dylib</div><div class="line">    cd /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib</div><div class="line">    export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate</div><div class="line"></div><div class="line">Signing Identity:     &quot;-&quot;</div><div class="line"></div><div class="line">    /usr/bin/codesign --force --sign - --timestamp=none /Users/macbook/Documents/macbook/macbook/code/chapter4/mylib/build/Release/libmylib.dylib</div><div class="line"></div><div class="line">** BUILD SUCCEEDED **</div></pre></td></tr></table></figure></p>
<p>从上面的日志中可以看出，整个编译过程分为：<br>检查依赖（Check dependencies）、生成辅助文件（Write auxiliary files）、编译（CompileC）、链接（Ld）、生成调试符号（GenerateDSYMFile）、代码签名（CodeSign）等几步。<br>编译代码时，使用的编译器是<code>clang</code>，这是苹果公司开发的用来替代<code>gcc</code>的现代化编译器，该编译器目前也广泛用于安卓、Linux平台上的软件开发工作；链接时使用<code>clang</code>前端传入参数给链接器<code>ld</code>，链接完成后dylib动态库就编译成功了；生成调试符号这一步主要用于生成符号的调试信息，供调试器使用；最后一步是代码签名，在没有指定签名证书的情况下，XCode默认使用的adhoc签名。</p>
<p>编译好的动态库可以被其它程序通过头文件声明隐式的调用，也可以像Linux系统那样，使用系统函数<code>dlopen()</code>、<code>dlsym()</code>手动进行调用。</p>
<h2 id="0x2-dyld"><a href="#0x2-dyld" class="headerlink" title="0x2 dyld"></a>0x2 dyld</h2><p>动态库不能直接运行，而是需要通过系统的动态链接加载器进行加载到内存后执行，动态链接加载器在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个<code>LC_LOAD_DYLINKER</code>的加载命令，此加载命令指定了dyld的路径，通常它的默认值是“/usr/lib/dyld”。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。</p>
<p>dyld加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被dyld映射到内存中，之后，当任何Mach-O映像加载时，dyld首先会检查该Mach-O映像与所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。在程序依赖的系统动态库很多的情况下，这种做法对程序启动性能是有明显提升的。</p>
<p><code>update_dyld_shared_cache</code>程序确保了dyld的共享缓存是最新的，它会扫描/var/db/dyld/shared_region_roots/目录下paths路径文件，这些paths文件包含了需要加入到共享缓存的Mach-O文件路径列表，<code>update_dyld_shared_cache()</code>会挨个将这些Mach-O文件及其依赖的dylib都加共享缓存中去。</p>
<p>共享缓存是以文件形式存放在/var/db/dyld/目录下的，生成共享缓存的<code>update_dyld_shared_cache</code>程序位于是/usr/bin/目录下，该工具会为每种系统加构生成一个缓存文件与对应的内存地址map表，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ls -l /var/db/dyld/</div><div class="line">total 1741296</div><div class="line">-rw-r--r--   1 root  wheel  333085108 Apr 22 15:02 dyld_shared_cache_i386</div><div class="line">-rw-r--r--   1 root  wheel      65378 Apr 22 15:02 dyld_shared_cache_i386.map</div><div class="line">-rw-r--r--   1 root  wheel  558259294 Apr 25 16:18 dyld_shared_cache_x86_64h</div><div class="line">-rw-r--r--   1 root  wheel     129633 Apr 25 16:18 dyld_shared_cache_x86_64h.map</div><div class="line">drwxr-xr-x  10 root  wheel        340 Apr  7 09:19 shared_region_roots</div></pre></td></tr></table></figure></p>
<p>生成的共享缓存可以使用工具<code>dyld_shared_cache_util</code>查看它的信息，该工具位于dyld源码中的 launch-cache\dyld_shared_cache_util.cpp 文件，需要自己手动编译。另外，也可以使用dyld提供的两个函数<code>dyld_shared_cache_extract_dylibs()</code>与<code>dyld_shared_cache_extract_dylibs_progress()</code>来自己解开cache文件，代码位于dyld源码的launch-cache\dsc_extractor.cpp文件中。</p>
<p><code>update_dyld_shared_cache</code>通常它只在系统的安装器安装软件与系统更新时调用，当然，可以手动运行“sudo update_dyld_shared_cache”来更新共享缓存。新的共享缓存会在系统下次启动后自动更新。</p>
<h2 id="0x3-动态库的加载过程分析"><a href="#0x3-动态库的加载过程分析" class="headerlink" title="0x3 动态库的加载过程分析"></a>0x3 动态库的加载过程分析</h2><p>dyld是苹果操作系统一个重要组成部分，而且令人兴奋的是，它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式（下载地址：<a href="http://opensource.apple.com/tarballs/dyld），了解系统加载动态库的细节。" target="_blank" rel="external">http://opensource.apple.com/tarballs/dyld），了解系统加载动态库的细节。</a></p>
<p>系统内核在加载动态库前，会加载dyld，然后调用去执行<code>__dyld_start()</code>，该函数会执行<code>dyldbootstrap::start()</code>，后者会执行<code>_main()</code>函数，dyld的加载动态库的代码就是从<code>_main()</code>开始执行的。下面以dyld源码的360.18版本为蓝本进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">uintptr_t</div><div class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,</div><div class="line">		int argc, const char* argv[], const char* envp[], const char* apple[],</div><div class="line">		uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">    //第一步，设置运行环境，处理环境变量</div><div class="line">	uintptr_t result = 0;</div><div class="line">	sMainExecutableMachHeader = mainExecutableMH;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	CRSetCrashLogMessage(&quot;dyld: launch started&quot;);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</div><div class="line"></div><div class="line">	// Pickup the pointer to the exec path.</div><div class="line">	sExecPath = _simple_getenv(apple, &quot;executable_path&quot;);</div><div class="line"></div><div class="line">	// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</div><div class="line">	if (!sExecPath) sExecPath = apple[0];</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	sExecShortName = ::strrchr(sExecPath, &apos;/&apos;);</div><div class="line">	if ( sExecShortName != NULL )</div><div class="line">		++sExecShortName;</div><div class="line">	else</div><div class="line">		sExecShortName = sExecPath;</div><div class="line">    sProcessIsRestricted = processRestricted(mainExecutableMH, &amp;ignoreEnvironmentVariables, &amp;sProcessRequiresLibraryValidation);</div><div class="line">    if ( sProcessIsRestricted ) &#123;</div><div class="line">#if SUPPORT_LC_DYLD_ENVIRONMENT</div><div class="line">		checkLoadCommandEnvironmentVariables();</div><div class="line">#endif 	</div><div class="line">		pruneEnvironmentVariables(envp, &amp;apple);</div><div class="line">		setContext(mainExecutableMH, argc, argv, envp, apple);</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		if ( !ignoreEnvironmentVariables )</div><div class="line">			checkEnvironmentVariables(envp);</div><div class="line">		defaultUninitializedFallbackPaths(envp);</div><div class="line">	&#125;</div><div class="line">	if ( sEnv.DYLD_PRINT_OPTS )</div><div class="line">		printOptions(argv);</div><div class="line">	if ( sEnv.DYLD_PRINT_ENV )</div><div class="line">		printEnvironmentVariables(envp);</div><div class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line"></div><div class="line">    //第二步，初始化主程序</div><div class="line">	try &#123;</div><div class="line">		// add dyld itself to UUID list</div><div class="line">		addDyldImageToUUIDList();</div><div class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</div><div class="line">		// instantiate ImageLoader for main executable</div><div class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</div><div class="line">		gLinkContext.mainExecutable = sMainExecutable;</div><div class="line">		gLinkContext.processIsRestricted = sProcessIsRestricted;</div><div class="line">		gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation;</div><div class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">		//第三步，加载共享缓存</div><div class="line">		checkSharedRegionDisable();</div><div class="line">	#if DYLD_SHARED_CACHE_SUPPORT</div><div class="line">		if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</div><div class="line">			mapSharedCache();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		// Now that shared cache is loaded, setup an versioned dylib overrides</div><div class="line">	#if SUPPORT_VERSIONED_PATHS</div><div class="line">		checkVersionedPaths();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		//第四步，加载插入的动态库</div><div class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</div><div class="line">			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib)</div><div class="line">				loadInsertedDylib(*lib);</div><div class="line">		&#125;</div><div class="line">		sInsertedDylibCount = sAllImages.size()-1;</div><div class="line"></div><div class="line">		//第五步，链接主程序</div><div class="line">		gLinkContext.linkingMainExecutable = true;</div><div class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</div><div class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</div><div class="line">			gLinkContext.bindFlat = true;</div><div class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//第六步，链接插入的动态库</div><div class="line">		if ( sInsertedDylibCount &gt; 0 ) &#123;</div><div class="line">			for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</div><div class="line">				ImageLoader* image = sAllImages[i+1];</div><div class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">				image-&gt;setNeverUnloadRecursive();</div><div class="line">			&#125;</div><div class="line">			// only INSERTED libraries can interpose</div><div class="line">			for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</div><div class="line">				ImageLoader* image = sAllImages[i+1];</div><div class="line">				image-&gt;registerInterposing();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</div><div class="line">		for (int i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123;</div><div class="line">			ImageLoader* image = sAllImages[i];</div><div class="line">			if ( image-&gt;inSharedCache() )</div><div class="line">				continue;</div><div class="line">			image-&gt;registerInterposing();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// apply interposing to initial set of images</div><div class="line">		for(int i=0; i &lt; sImageRoots.size(); ++i) &#123;</div><div class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        //第七步，执行弱符号绑定</div><div class="line">		gLinkContext.linkingMainExecutable = false;</div><div class="line">		// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</div><div class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</div><div class="line"></div><div class="line">        //第八步，执行初始化方法</div><div class="line">		CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;);</div><div class="line">	#if SUPPORT_OLD_CRT_INITIALIZATION</div><div class="line">		// Old way is to run initializers via a callback from crt1.o</div><div class="line">		if ( ! gRunInitializersOldWay )</div><div class="line">			initializeMainExecutable();</div><div class="line">	#else</div><div class="line">		// run all initializers</div><div class="line">		initializeMainExecutable();</div><div class="line">	#endif</div><div class="line"></div><div class="line">        //第九步，查找入口点并返回</div><div class="line">		result = (uintptr_t)sMainExecutable-&gt;getThreadPC();</div><div class="line">		if ( result != 0 ) &#123;</div><div class="line">			// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</div><div class="line">			if ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= 9) )</div><div class="line">				*startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit;</div><div class="line">			else</div><div class="line">				halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</div><div class="line">			result = (uintptr_t)sMainExecutable-&gt;getMain();</div><div class="line">			*startGlue = 0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	catch(const char* message) &#123;</div><div class="line">		syncAllImages();</div><div class="line">		halt(message);</div><div class="line">	&#125;</div><div class="line">	catch(...) &#123;</div><div class="line">		dyld::log(&quot;dyld: launch failed\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	CRSetCrashLogMessage(NULL);</div><div class="line"></div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个方法的代码比较长，将它按功能分成九个步骤进行讲解：</p>
<h4 id="第一步，设置运行环境，处理环境变量"><a href="#第一步，设置运行环境，处理环境变量" class="headerlink" title="第一步，设置运行环境，处理环境变量"></a>第一步，设置运行环境，处理环境变量</h4><p>代码在开始时候，将传入的变量<code>mainExecutableMH</code>赋值给了<code>sMainExecutableMachHeader</code>，这是一个<code>macho_header</code>类型的变量，其结构体内容就是本章前面介绍的<code>mach_header</code>结构体，表示的是当前主程序的Mach-O头部信息，有了头部信息，加载器就可以从头开始，遍历整个Mach-O文件的信息。<br>接着执行了<code>setContext()</code>，此方法设置了全局一个链接上下文，包括一些回调函数、参数与标志设置信息，代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void setContext(const macho_header* mainExecutableMH, int argc, const char* argv[], const char* envp[], const char* apple[])</div><div class="line">&#123;</div><div class="line">	gLinkContext.loadLibrary			= &amp;libraryLocator;</div><div class="line">	gLinkContext.terminationRecorder	= &amp;terminationRecorder;</div><div class="line">	gLinkContext.flatExportFinder		= &amp;flatFindExportedSymbol;</div><div class="line">	gLinkContext.coalescedExportFinder	= &amp;findCoalescedExportedSymbol;</div><div class="line">	gLinkContext.getCoalescedImages		= &amp;getCoalescedImages;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">	gLinkContext.bindingOptions			= ImageLoader::kBindingNone;</div><div class="line">	gLinkContext.argc					= argc;</div><div class="line">	gLinkContext.argv					= argv;</div><div class="line">	gLinkContext.envp					= envp;</div><div class="line">	gLinkContext.apple					= apple;</div><div class="line">	gLinkContext.progname				= (argv[0] != NULL) ? basename(argv[0]) : &quot;&quot;;</div><div class="line">	gLinkContext.programVars.mh			= mainExecutableMH;</div><div class="line">	gLinkContext.programVars.NXArgcPtr	= &amp;gLinkContext.argc;</div><div class="line">	gLinkContext.programVars.NXArgvPtr	= &amp;gLinkContext.argv;</div><div class="line">	gLinkContext.programVars.environPtr	= &amp;gLinkContext.envp;</div><div class="line">	gLinkContext.programVars.__prognamePtr=&amp;gLinkContext.progname;</div><div class="line">	gLinkContext.mainExecutable			= NULL;</div><div class="line">	gLinkContext.imageSuffix			= NULL;</div><div class="line">	gLinkContext.dynamicInterposeArray	= NULL;</div><div class="line">	gLinkContext.dynamicInterposeCount	= 0;</div><div class="line">	gLinkContext.prebindUsage			= ImageLoader::kUseAllPrebinding;</div><div class="line">#if TARGET_IPHONE_SIMULATOR</div><div class="line">	gLinkContext.sharedRegionMode		= ImageLoader::kDontUseSharedRegion;</div><div class="line">#else</div><div class="line">	gLinkContext.sharedRegionMode		= ImageLoader::kUseSharedRegion;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置的回调函数都是dyld本模块实现的，如<code>loadLibrary</code>方法就是本模块的<code>libraryLocator()</code>方法，负责加载动态库。<br>在设置完这些信息后，执行<code>processRestricted()</code>方法判断进程是否受限。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">static bool processRestricted(const macho_header* mainExecutableMH, bool* ignoreEnvVars, bool* processRequiresLibraryValidation)</div><div class="line">&#123;</div><div class="line">#if TARGET_IPHONE_SIMULATOR</div><div class="line">	gLinkContext.codeSigningEnforced = true;</div><div class="line">#else</div><div class="line">    // ask kernel if code signature of program makes it restricted</div><div class="line">    uint32_t flags;</div><div class="line">	if ( csops(0, CS_OPS_STATUS, &amp;flags, sizeof(flags)) != -1 ) &#123;</div><div class="line">		if (flags &amp; CS_REQUIRE_LV)</div><div class="line">			*processRequiresLibraryValidation = true;</div><div class="line"></div><div class="line">  #if __MAC_OS_X_VERSION_MIN_REQUIRED</div><div class="line">		if ( flags &amp; CS_ENFORCEMENT ) &#123;</div><div class="line">			gLinkContext.codeSigningEnforced = true;</div><div class="line">		&#125;</div><div class="line">		if ( ((flags &amp; CS_RESTRICT) == CS_RESTRICT) &amp;&amp; (csr_check(CSR_ALLOW_TASK_FOR_PID) != 0) ) &#123;</div><div class="line">			sRestrictedReason = restrictedByEntitlements;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">  #else</div><div class="line">		if ((flags &amp; CS_ENFORCEMENT) &amp;&amp; !(flags &amp; CS_GET_TASK_ALLOW)) &#123;</div><div class="line">			*ignoreEnvVars = true;</div><div class="line">		&#125;</div><div class="line">		gLinkContext.codeSigningEnforced = true;</div><div class="line">  #endif</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">	// all processes with setuid or setgid bit set are restricted</div><div class="line">    if ( issetugid() ) &#123;</div><div class="line">		sRestrictedReason = restrictedBySetGUid;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// &lt;rdar://problem/13158444&amp;13245742&gt; Respect __RESTRICT,__restrict section for root processes</div><div class="line">	if ( hasRestrictedSegment(mainExecutableMH) ) &#123;</div><div class="line">		// existence of __RESTRICT/__restrict section make process restricted</div><div class="line">		sRestrictedReason = restrictedBySegment;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进程受限会是以下三种可能：<br><code>restrictedByEntitlements</code>：在macOS系统上，在需要验证代码签名（<code>Gatekeeper</code>开启）的情况下，且<code>csr_check(CSR_ALLOW_TASK_FOR_PID)</code>返回为真（表示Rootless开启了<code>TASK_FOR_PID</code>标志）时，进程才不会受限，在macOS版本10.12系统上，默认<code>Gatekeeper</code>是开启的，并且<code>Rootless</code>是关闭了<code>CSR_ALLOW_TASK_FOR_PID</code>标志位的，这意味着，默认情况下，系统上运行的进程是受限的。<br><code>restrictedBySetGUid</code>：当进程的setuid与setgid位被设置时，进程会被设置成受限。这样做是出于安全的考虑，受限后的进程无法访问<code>DYLD_</code>开头的环境变量，一种典型的系统攻击就是针对这种情况而发生的，在macOS版本10.10系统上，一个由<code>DYLD_PRINT_TO_FILE</code>环境变量引发的系统本地提权漏洞，就是通过向<code>DYLD_PRINT_TO_FILE</code>环境变量传入拥有SUID权限的受限文件，而系统没做安全检测，而这些文件是直接有向系统创建与写入文件权限的。关于漏洞的具体细节可以参看：<a href="https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html" target="_blank" rel="external">https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html</a><br><code>restrictedBySegment</code>：段名受限。当Mach-O包含一个<code>__RESTRICT/__restrict</code>段时，进程会被设置成受限。</p>
<p>在进程受限后，执行了以下三个方法：<br><code>checkLoadCommandEnvironmentVariables()</code>:遍历Mach-O中所有的<code>LC_DYLD_ENVIRONMENT</code>加载命令，然后调用<code>processDyldEnvironmentVariable()</code>对不同的环境变量做相应的处理。<br><code>pruneEnvironmentVariables()</code>:删除进程的<code>LD_LIBRARY_PATH</code>与所有以DYLD_开头的环境变量，这样以后创建的子进程就不包含这些环境变量了。<br><code>setContext()</code>:重新设置链接上下文。这一步执行的主要目的是由于环境变量发生变化了，需要更新进程的<code>envp</code>与<code>apple</code>参数。</p>
<h4 id="第二步，初始化主程序"><a href="#第二步，初始化主程序" class="headerlink" title="第二步，初始化主程序"></a>第二步，初始化主程序</h4><p>这一步主要执行了<code>instantiateFromLoadedImage()</code>。它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</div><div class="line">&#123;</div><div class="line">	// try mach-o loader</div><div class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</div><div class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</div><div class="line">		addImage(image);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	throw &quot;main executable not a known format&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>isCompatibleMachO()</code>主要检查Mach-O的头部的<code>cputype</code>与<code>cpusubtype</code>来判断程序与当前的系统是否兼容。如果兼容接下来就调用<code>instantiateMainExecutable()</code>实例化主程序，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n&quot;,</div><div class="line">	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</div><div class="line">	bool compressed;</div><div class="line">	unsigned int segCount;</div><div class="line">	unsigned int libCount;</div><div class="line">	const linkedit_data_command* codeSigCmd;</div><div class="line">	const encryption_info_command* encryptCmd;</div><div class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</div><div class="line">	// instantiate concrete class based on content of load commands</div><div class="line">	if ( compressed )</div><div class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">	else</div><div class="line">#if SUPPORT_CLASSIC_MACHO</div><div class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">#else</div><div class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sniffLoadCommands()</code>主要获取了加载命令中的如下信息：<br><code>compressed</code>：判断Mach-O的<code>Compressed</code>还是<code>Classic</code>类型。判断的依据是Mach-O是否包含<code>LC_DYLD_INFO</code>或<code>LC_DYLD_INFO_ONLY</code>加载命令。这2个加载命令记录了Mach-O的动态库加载信息，使用结构体<code>dyld_info_command</code>表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct dyld_info_command &#123;</div><div class="line">   uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</div><div class="line">   uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */</div><div class="line">   uint32_t   rebase_off;	/* file offset to rebase info  */</div><div class="line">   uint32_t   rebase_size;	/* size of rebase info   */</div><div class="line">   uint32_t   bind_off;	/* file offset to binding info   */</div><div class="line">   uint32_t   bind_size;	/* size of binding info  */</div><div class="line">   uint32_t   weak_bind_off;	/* file offset to weak binding info   */</div><div class="line">   uint32_t   weak_bind_size;  /* size of weak binding info  */</div><div class="line">   uint32_t   lazy_bind_off;	/* file offset to lazy binding info */</div><div class="line">   uint32_t   lazy_bind_size;  /* size of lazy binding infs */</div><div class="line">   uint32_t   export_off;	/* file offset to lazy binding info */</div><div class="line">   uint32_t   export_size;	/* size of lazy binding infs */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>rebase_off</code>与大小<code>rebase_size</code>存储了rebase（重设基址）相关信息，当Mach-O加载到内存中的地址不是指定的首选地址时，就需要对当前的映像数据进行rebase（重设基址）。<br><code>bind_off</code>与<code>bind_size</code>存储了进程的符号绑定信息，当进程启动时必须绑定这些符号，典型的有<code>dyld_stub_binder</code>，该符号被dyld用来做迟绑定加载符号，一般动态库都包含该符号。<br><code>weak_bind_off</code>与<code>weak_bind_size</code>存储了进程的弱绑定符号信息。弱符号主要用于面向对旬语言中的符号重载，典型的有c++中使用new创建对象，默认情况下会绑定ibstdc++.dylib，如果检测到某个映像使用弱符号引用重载了<code>new</code>符号，dyld则会重新绑定该符号并调用重载的版本。<br><code>lazy_bind_off</code>与<code>lazy_bind_size</code>存储了进程的延迟绑定符号信息。有些符号在进程启动时不需要马上解析，它们会在第一次调用时被解析，这类符号叫延迟绑定符号（Lazy Symbol）。<br><code>export_off</code>与<code>export_size</code>存储了进程的导出符号绑定信息。导出符号可以被外部的Mach-O访问，通常动态库会导出一个或多个符号供外部使用，而可执行程序由导出<code>_main</code>与<code>_mh_execute_header</code>符号供dyld使用。</p>
<p><code>segCount</code>：段的数量。<code>sniffLoadCommands()</code>通过遍历所有的<code>LC_SEGMENT_COMMAND</code>加载命令来获取段的数量。</p>
<p><code>libCount</code>：需要加载的动态库的数量。Mach-O中包含的每一条<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>、<code>LC_REEXPORT_DYLIB</code>、<code>LC_LOAD_UPWARD_DYLIB</code>加载命令，都表示需要加载一个动态库。</p>
<p><code>codeSigCmd</code>：通过解析<code>LC_CODE_SIGNATURE</code>来获取代码签名的加载命令。</p>
<p><code>encryptCmd</code>：通过<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>来获取段加密信息。</p>
<p>获取<code>compressed</code>后，根据Mach-O是否<code>compressed</code>来分别调用<code>ImageLoaderMachOCompressed::instantiateMainExecutable()</code>与<code>ImageLoaderMachOClassic::instantiateMainExecutable()</code>。<code>ImageLoaderMachOCompressed::instantiateMainExecutable()</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// create image for main executable</div><div class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path,</div><div class="line">																		unsigned int segCount, unsigned int libCount, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);</div><div class="line"></div><div class="line">	// set slide for PIE programs</div><div class="line">	image-&gt;setSlide(slide);</div><div class="line"></div><div class="line">	// for PIE record end of program, to know where to start loading dylibs</div><div class="line">	if ( slide != 0 )</div><div class="line">		fgNextPIEDylibAddress = (uintptr_t)image-&gt;getEnd();</div><div class="line"></div><div class="line">	image-&gt;disableCoverageCheck();</div><div class="line">	image-&gt;instantiateFinish(context);</div><div class="line">	image-&gt;setMapped(context);</div><div class="line"></div><div class="line">	if ( context.verboseMapping ) &#123;</div><div class="line">		dyld::log(&quot;dyld: Main executable mapped %s\n&quot;, path);</div><div class="line">		for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</div><div class="line">			const char* name = image-&gt;segName(i);</div><div class="line">			if ( (strcmp(name, &quot;__PAGEZERO&quot;) == 0) || (strcmp(name, &quot;__UNIXSTACK&quot;) == 0)  )</div><div class="line">				dyld::log(&quot;%18s at 0x%08lX-&gt;0x%08lX\n&quot;, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</div><div class="line">			else</div><div class="line">				dyld::log(&quot;%18s at 0x%08lX-&gt;0x%08lX\n&quot;, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ImageLoaderMachOCompressed::instantiateStart()</code>使用主程序Mach-O信息构造了一个<code>ImageLoaderMachOCompressed</code>对象。<code>disableCoverageCheck()</code>禁用覆盖率检查。<code>instantiateFinish()</code>调用<code>parseLoadCmds()</code>解析其它所有的加载命令，后者会填充完<code>ImageLoaderMachOCompressed</code>的一些保护成员信息，最后调用<code>setDyldInfo()</code>设置动态库链接信息，然后调用<code>setSymbolTableInfo()</code>设置符号表信息。</p>
<p><code>instantiateFromLoadedImage()</code>调用完了<code>ImageLoaderMachO::instantiateMainExecutable()</code>后，接着调用<code>addImage()</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void addImage(ImageLoader* image)</div><div class="line">&#123;</div><div class="line">	// add to master list</div><div class="line">    allImagesLock();</div><div class="line">        sAllImages.push_back(image);</div><div class="line">    allImagesUnlock();</div><div class="line"></div><div class="line">	// update mapped ranges</div><div class="line">	uintptr_t lastSegStart = 0;</div><div class="line">	uintptr_t lastSegEnd = 0;</div><div class="line">	for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</div><div class="line">		if ( image-&gt;segUnaccessible(i) )</div><div class="line">			continue;</div><div class="line">		uintptr_t start = image-&gt;segActualLoadAddress(i);</div><div class="line">		uintptr_t end = image-&gt;segActualEndAddress(i);</div><div class="line">		if ( start == lastSegEnd ) &#123;</div><div class="line">			// two segments are contiguous, just record combined segments</div><div class="line">			lastSegEnd = end;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// non-contiguous segments, record last (if any)</div><div class="line">			if ( lastSegEnd != 0 )</div><div class="line">				addMappedRange(image, lastSegStart, lastSegEnd);</div><div class="line">			lastSegStart = start;</div><div class="line">			lastSegEnd = end;</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">	if ( lastSegEnd != 0 )</div><div class="line">		addMappedRange(image, lastSegStart, lastSegEnd);</div><div class="line"></div><div class="line"></div><div class="line">	if ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=NULL) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</div><div class="line">		dyld::log(&quot;dyld: loaded: %s\n&quot;, image-&gt;getPath());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码将实例化好的主程序添加到全局主列表<code>sAllImages</code>中，最后调用<code>addMappedRange()</code>申请内存，更新主程序映像映射的内存区。做完这些工作，第二步初始化主程序就算完成了。</p>
<h4 id="第三步，加载共享缓存"><a href="#第三步，加载共享缓存" class="headerlink" title="第三步，加载共享缓存"></a>第三步，加载共享缓存</h4><p>这一步主要执行<code>mapSharedCache()</code>来映射共享缓存。该函数先通过<code>_shared_region_check_np()</code>来检查缓存是否已经映射到了共享区域了，如果已经映射了，就更新缓存的<code>slide</code>与<code>UUID</code>，然后返回。反之，判断系统是否处于安全启动模式（safe-boot mode）下，如果是就删除缓存文件并返回，正常启动的情况下，接下来调用<code>openSharedCacheFile()</code>打开缓存文件，该函数在<code>sSharedCacheDir</code>路径下，打开与系统当前cpu架构匹配的缓存文件，也就是/var/db/dyld/dyld_shared_cache_x86_64h，接着读取缓存文件的前8192字节，解析缓存头<code>dyld_cache_header</code>的信息，将解析好的缓存信息存入<code>mappings</code>变量，最后调用<code>_shared_region_map_and_slide_np()</code>完成真正的映射工作。部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">static void mapSharedCache()</div><div class="line">&#123;</div><div class="line">	uint64_t cacheBaseAddress = 0;</div><div class="line">	if ( _shared_region_check_np(&amp;cacheBaseAddress) == 0 ) &#123;</div><div class="line">		sSharedCache = (dyld_cache_header*)cacheBaseAddress;</div><div class="line">#if __x86_64__</div><div class="line">		const char* magic = (sHaswell ? ARCH_CACHE_MAGIC_H : ARCH_CACHE_MAGIC);</div><div class="line">#else</div><div class="line">		const char* magic = ARCH_CACHE_MAGIC;</div><div class="line">#endif</div><div class="line">		if ( strcmp(sSharedCache-&gt;magic, magic) != 0 ) &#123;</div><div class="line">			sSharedCache = NULL;</div><div class="line">			if ( gLinkContext.verboseMapping ) &#123;</div><div class="line">				dyld::log(&quot;dyld: existing shared cached in memory is not compatible\n&quot;);</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		const dyld_cache_header* header = sSharedCache;</div><div class="line">		......</div><div class="line">		// if cache has a uuid, copy it</div><div class="line">		if ( header-&gt;mappingOffset &gt;= 0x68 ) &#123;</div><div class="line">			memcpy(dyld::gProcessInfo-&gt;sharedCacheUUID, header-&gt;uuid, 16);</div><div class="line">		&#125;</div><div class="line">		......</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">#if __i386__ || __x86_64__</div><div class="line">		uint32_t	safeBootValue = 0;</div><div class="line">		size_t		safeBootValueSize = sizeof(safeBootValue);</div><div class="line">		if ( (sysctlbyname(&quot;kern.safeboot&quot;, &amp;safeBootValue, &amp;safeBootValueSize, NULL, 0) == 0) &amp;&amp; (safeBootValue != 0) ) &#123;</div><div class="line">			struct stat dyldCacheStatInfo;</div><div class="line">			if ( my_stat(MACOSX_DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME, &amp;dyldCacheStatInfo) == 0 ) &#123;</div><div class="line">				struct timeval bootTimeValue;</div><div class="line">				size_t bootTimeValueSize = sizeof(bootTimeValue);</div><div class="line">				if ( (sysctlbyname(&quot;kern.boottime&quot;, &amp;bootTimeValue, &amp;bootTimeValueSize, NULL, 0) == 0) &amp;&amp; (bootTimeValue.tv_sec != 0) ) &#123;</div><div class="line">					if ( dyldCacheStatInfo.st_mtime &lt; bootTimeValue.tv_sec ) &#123;</div><div class="line">						::unlink(MACOSX_DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME);</div><div class="line">						gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;</div><div class="line">						return;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">#endif</div><div class="line">		// map in shared cache to shared region</div><div class="line">		int fd = openSharedCacheFile();</div><div class="line">		if ( fd != -1 ) &#123;</div><div class="line">			uint8_t firstPages[8192];</div><div class="line">			if ( ::read(fd, firstPages, 8192) == 8192 ) &#123;</div><div class="line">				dyld_cache_header* header = (dyld_cache_header*)firstPages;</div><div class="line">		#if __x86_64__</div><div class="line">				const char* magic = (sHaswell ? ARCH_CACHE_MAGIC_H : ARCH_CACHE_MAGIC);</div><div class="line">		#else</div><div class="line">				const char* magic = ARCH_CACHE_MAGIC;</div><div class="line">		#endif</div><div class="line">				if ( strcmp(header-&gt;magic, magic) == 0 ) &#123;</div><div class="line">					const dyld_cache_mapping_info* const fileMappingsStart = (dyld_cache_mapping_info*)&amp;firstPages[header-&gt;mappingOffset];</div><div class="line">					const dyld_cache_mapping_info* const fileMappingsEnd = &amp;fileMappingsStart[header-&gt;mappingCount];</div><div class="line">					shared_file_mapping_np	mappings[header-&gt;mappingCount+1]; // add room for code-sig</div><div class="line"></div><div class="line">					......</div><div class="line"></div><div class="line">						if (_shared_region_map_and_slide_np(fd, mappingCount, mappings, codeSignatureMappingIndex, cacheSlide, slideInfo, slideInfoSize) == 0) &#123;</div><div class="line">							sSharedCache = (dyld_cache_header*)mappings[0].sfm_address;</div><div class="line">							sSharedCacheSlide = cacheSlide;</div><div class="line">							dyld::gProcessInfo-&gt;sharedCacheSlide = cacheSlide;</div><div class="line">							......</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED</div><div class="line">							throw &quot;dyld shared cache could not be mapped&quot;;</div><div class="line">#endif</div><div class="line">							if ( gLinkContext.verboseMapping )</div><div class="line">								dyld::log(&quot;dyld: shared cached file could not be mapped\n&quot;);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					if ( gLinkContext.verboseMapping )</div><div class="line">						dyld::log(&quot;dyld: shared cached file is invalid\n&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				if ( gLinkContext.verboseMapping )</div><div class="line">					dyld::log(&quot;dyld: shared cached file cannot be read\n&quot;);</div><div class="line">			&#125;</div><div class="line">			close(fd);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			if ( gLinkContext.verboseMapping )</div><div class="line">				dyld::log(&quot;dyld: shared cached file cannot be opened\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>共享缓存加载完毕后，接着进行动态库的版本化重载，这主要通过函数checkVersionedPaths()完成。该函数读取<code>DYLD_VERSIONED_LIBRARY_PATH</code>与<code>DYLD_VERSIONED_FRAMEWORK_PATH</code>环境变量，将指定版本的库比当前加载的库的版本做比较，如果当前的库版本更高的话，就使用新版本的库来替换掉旧版本的。</p>
<h4 id="第四步，加载插入的动态库"><a href="#第四步，加载插入的动态库" class="headerlink" title="第四步，加载插入的动态库"></a>第四步，加载插入的动态库</h4><p>这一步循环遍历<code>DYLD_INSERT_LIBRARIES</code>环境变量中指定的动态库列表，并调用<code>loadInsertedDylib()</code>将其加载。该函数调用<code>load()</code>完成加载工作。<code>load()</code>会调用<code>loadPhase0()</code>尝试从文件加载，<code>loadPhase0()</code>会向下调用下一层phase来查找动态库的路径，直到<code>loadPhase6()</code>，查找的顺序为<code>DYLD_ROOT_PATH</code>-&gt;<code>LD_LIBRARY_PATH</code>-&gt;<code>DYLD_FRAMEWORK_PATH</code>-&gt;原始路径-&gt;<code>DYLD_FALLBACK_LIBRARY_PATH</code>，找到后调用<code>ImageLoaderMachO::instantiateFromFile()</code>来实例化一个<code>ImageLoader</code>，之后调用<code>checkandAddImage()</code>验证映像并将其加入到全局映像列表中。如果<code>loadPhase0()</code>返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用<code>ImageLoaderMachO::instantiateFromCache()</code>从缓存中加载，否则就抛出没找到映像的异常。部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">ImageLoader* load(const char* path, const LoadContext&amp; context)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if ( context.useSearchPaths &amp;&amp; ( gLinkContext.imageSuffix != NULL) ) &#123;</div><div class="line">		if ( realpath(path, realPath) != NULL )</div><div class="line">			path = realPath;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, NULL);</div><div class="line">	if ( image != NULL ) &#123;</div><div class="line">		CRSetCrashLogMessage2(NULL);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">	image = loadPhase0(path, orgPath, context, &amp;exceptions);</div><div class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; DYLD_SHARED_CACHE_SUPPORT &amp;&amp; !TARGET_IPHONE_SIMULATOR</div><div class="line">	// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</div><div class="line">	if ( (image == NULL) &amp;&amp; cacheablePath(path) &amp;&amp; !context.dontLoad ) &#123;</div><div class="line">		......</div><div class="line">		if ( (myerr == ENOENT) || (myerr == 0) )</div><div class="line">		&#123;</div><div class="line">			const macho_header* mhInCache;</div><div class="line">			const char*			pathInCache;</div><div class="line">			long				slideInCache;</div><div class="line">			if ( findInSharedCacheImage(resolvedPath, false, NULL, &amp;mhInCache, &amp;pathInCache, &amp;slideInCache) ) &#123;</div><div class="line">				struct stat stat_buf;</div><div class="line">				bzero(&amp;stat_buf, sizeof(stat_buf));</div><div class="line">				try &#123;</div><div class="line">					image = ImageLoaderMachO::instantiateFromCache(mhInCache, pathInCache, slideInCache, stat_buf, gLinkContext);</div><div class="line">					image = checkandAddImage(image, context);</div><div class="line">				&#125;</div><div class="line">				catch (...) &#123;</div><div class="line">					image = NULL;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line">    ......</div><div class="line">	else &#123;</div><div class="line">		const char* msgStart = &quot;no suitable image found.  Did find:&quot;;</div><div class="line">		......</div><div class="line">		throw (const char*)fullMsg;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第五步，链接主程序"><a href="#第五步，链接主程序" class="headerlink" title="第五步，链接主程序"></a>第五步，链接主程序</h4><p>这一步执行<code>link()</code>完成主程序的链接操作。该函数调用了<code>ImageLoader</code>自身的<code>link()</code>函数，主要的目的是将实例化的主程序的动态数据进行修正，达到让进程可用的目的，典型的就是主程序中的符号表修正操作，它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	context.clearAllDepths();</div><div class="line">	this-&gt;recursiveUpdateDepth(context.imageCount());</div><div class="line"></div><div class="line"> 	this-&gt;recursiveRebase(context);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line"> 	this-&gt;recursiveBind(context, forceLazysBound, neverUnload);</div><div class="line"></div><div class="line">	if ( !context.linkingMainExecutable )</div><div class="line">		this-&gt;weakBind(context);	//现在是链接主程序，这里现在不会执行</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	std::vector&lt;DOFInfo&gt; dofs;</div><div class="line">	this-&gt;recursiveGetDOFSections(context, dofs);</div><div class="line">	context.registerDOFs(dofs);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123;</div><div class="line">		this-&gt;recursiveApplyInterposing(context);	//现在是链接主程序，这里现在不会执行</div><div class="line">	&#125;</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>recursiveLoadLibraries()</code>采用递归的方式来加载程序依赖的动态库，加载的方法是调用<code>context</code>的<code>loadLibrary</code>指针方法，该方法在前面看到过，是<code>setContext()</code>设置的<code>libraryLocator()</code>，该函数只是调用了<code>load()</code>来完成加载，<code>load()</code>加载动态库的过程在上一步已经分析过了。</p>
<p>接着调用<code>recursiveUpdateDepth()</code>对映像及其依赖库按列表方式进行排序。<code>recursiveRebase()</code>则对映像完成递归rebase操作，该函数只是调用了虚函数<code>doRebase()</code>，<code>doRebase()</code>被<code>ImageLoaderMachO</code>重载，实际只是将代码段设置成可写后调用了<code>rebase()</code>，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>rebase_off</code>与<code>rebase_size</code>来确定需要rebase的数据偏移与大小，然后挨个修正它们的地址信息。</p>
<p><code>recursiveBind()</code>完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，它的核心是调用了<code>doBind()</code>，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>bind_off</code>与<code>bind_size</code>来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用<code>bindAt()</code>函数，它主要通过调用<code>resolve()</code>解析完符号表后，调用<code>bindLocation()</code>完成最终的绑定操作，需要绑定的符号信息有三种：<br><code>BIND_TYPE_POINTER</code>：需要绑定的是一个指针。直接将计算好的新值屿值即可。<br><code>BIND_TYPE_TEXT_ABSOLUTE32</code>：一个32位的值。取计算的值的低32位赋值过去。<br><code>BIND_TYPE_TEXT_PCREL32</code>：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。</p>
<p><code>recursiveGetDOFSections</code>()与<code>registerDOFs()</code>主要注册程序的DOF节区，供<code>dtrace</code>使用。</p>
<h4 id="第六步，链接插入的动态库"><a href="#第六步，链接插入的动态库" class="headerlink" title="第六步，链接插入的动态库"></a>第六步，链接插入的动态库</h4><p>链接插入的动态库与链接主程序一样，都是使用的<code>link()</code>,插入的动态库列表是前面调用<code>addImage()</code>保存到<code>sAllImages</code>中的，之后，循环获取每一个动态库的<code>ImageLoader</code>，调用<code>link()</code>对其进行链接，注意：<code>sAllImages</code>中保存的第一项是主程序的映像。接下来调用每个映像的<code>registerInterposing()</code>方法来注册动态库插入与调用<code>applyInterposing()</code>应用插入操作。<code>registerInterposing()</code>查找<code>__DATA</code>段的<code>__interpose</code>节区，找到需要应用插入操作（也可以叫作符号地址替换）的数据，然后做一些检查后，将要替换的符号与被替换的符号信息存入<code>fgInterposingTuples</code>列表中，供以后具体符号替换时查询。<code>applyInterposing()</code>调用了虚方法<code>doInterpose()</code>来做符号替换操作，在<code>ImageLoaderMachOCompressed</code>中实际是调用了<code>eachBind()</code>与<code>eachLazyBind()</code>分别对常规的符号与延迟加载的符号进行应用插入操作，具体使用的是<code>interposeAt()</code>，该方法调用<code>interposedAddress()</code>在<code>fgInterposingTuples</code>中查找要替换的符号地址，找到后然后进行最终的符号地址替换。</p>
<h4 id="第七步，执行弱符号绑定"><a href="#第七步，执行弱符号绑定" class="headerlink" title="第七步，执行弱符号绑定"></a>第七步，执行弱符号绑定</h4><p><code>weakBind()</code>函数执行弱符号绑定。首先通过调用<code>context</code>的<code>getCoalescedImages()</code>将<code>sAllImages</code>中所有含有弱符号的映像合并成一个列表，合并完后调用<code>initializeCoalIterator()</code>对映像进行排序，排序完成后调用<code>incrementCoalIterator()</code>收集需要进行绑定的弱符号，后者是一个虚函数，在<code>ImageLoaderMachOCompressed</code>中，该函数读取映像动态链接信息的<code>weak_bind_off</code>与<code>weak_bind_size</code>来确定弱符号的数据偏移与大小，然后挨个计算它们的地址信息。之后调用<code>getAddressCoalIterator()</code>，按照映像的加载顺序在导出表中查找符号的地址，找到后调用<code>updateUsesCoalIterator()</code>执行最终的绑定操作，执行绑定的是<code>bindLocation()</code>，前面有讲过，此处不再赘述。</p>
<h4 id="第八步，执行初始化方法"><a href="#第八步，执行初始化方法" class="headerlink" title="第八步，执行初始化方法"></a>第八步，执行初始化方法</h4><p>执行初始化的方法是<code>initializeMainExecutable()</code>。该函数主要执行<code>runInitializers()</code>，后者调用了<code>ImageLoader</code>的<code>runInitializers()</code>方法，最终迭代执行了<code>ImageLoaderMachO</code>的<code>doInitialization()</code>方法，后者主要调用<code>doImageInit()</code>与<code>doModInitFunctions()</code>执行映像与模块中设置为init的函数与静态初始化方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	CRSetCrashLogMessage2(this-&gt;getPath());</div><div class="line"></div><div class="line">	doImageInit(context);</div><div class="line">	doModInitFunctions(context);</div><div class="line"></div><div class="line">	CRSetCrashLogMessage2(NULL);</div><div class="line"></div><div class="line">	return (fHasDashInit || fHasInitializers);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第九步，查找入口点并返回"><a href="#第九步，查找入口点并返回" class="headerlink" title="第九步，查找入口点并返回"></a>第九步，查找入口点并返回</h4><p>这一步调用主程序映像的<code>getThreadPC()</code>函数来查找主程序的<code>LC_MAIN</code>加载命令获取程序的入口点，没找到就调用<code>getMain()</code>到<code>LC_UNIXTHREAD</code>加载命令中去找，找到后就跳到入口点指定的地址并返回了。</p>
<p>到这里，dyld整个加载动态库的过程就算完成了。</p>
<p>另外再讨论下延迟符号加载的技术细节。在所有拥有延迟加载符号的Mach-O文件里，它的符号表中一定有一个<code>dyld_stub_helper</code>符号，它是延迟符号加载的关键！延迟绑定符号的修正工作就是由它完成的。绑定符号信息可以使用<code>XCode</code>提供的命令行工具<code>dyldinfo</code>来查看，执行以下命令可以查看<code>python</code>的绑定信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">xcrun dyldinfo -bind /usr/bin/python</div><div class="line">for arch i386:</div><div class="line">bind information:</div><div class="line">segment section          address        type    addend dylib            symbol</div><div class="line">__DATA  __cfstring       0x000040F0    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __cfstring       0x00004100    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __nl_symbol_ptr  0x00004010    pointer      0 CoreFoundation   _kCFAllocatorNull</div><div class="line">__DATA  __nl_symbol_ptr  0x00004008    pointer      0 libSystem        ___stack_chk_guard</div><div class="line">__DATA  __nl_symbol_ptr  0x0000400C    pointer      0 libSystem        _environ</div><div class="line">__DATA  __nl_symbol_ptr  0x00004000    pointer      0 libSystem        dyld_stub_binder</div><div class="line">bind information:</div><div class="line">segment section          address        type    addend dylib            symbol</div><div class="line">__DATA  __cfstring       0x1000031D8    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __cfstring       0x1000031F8    pointer      0 CoreFoundation   ___CFConstantStringClassReference</div><div class="line">__DATA  __got            0x100003010    pointer      0 CoreFoundation   _kCFAllocatorNull</div><div class="line">__DATA  __got            0x100003000    pointer      0 libSystem        ___stack_chk_guard</div><div class="line">__DATA  __got            0x100003008    pointer      0 libSystem        _environ</div><div class="line">__DATA  __nl_symbol_ptr  0x100003018    pointer      0 libSystem        dyld_stub_binder</div></pre></td></tr></table></figure></p>
<p>所有的延迟绑定符号都存储在<code>_TEXT</code>段的<code>stubs</code>节区（桩节区），编译器在生成代码时创建的符号调用就生成在此节区中，该节区被称为“桩”节区，桩只是一小段临时使用的指令，在<code>stubs</code>中只是一条<code>jmp</code>跳转指令，跳转的地址位于<code>__DATA</code>段<code>__la_symbol_ptr</code>节区中，指向的是一段代码，类似于如下的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">push xxx</div><div class="line">jmp yyy</div></pre></td></tr></table></figure></p>
<p>其中xxx是符号在动态链接信息中延迟绑定符号数据的偏移值，yyy则是跳转到<code>_TEXT</code>段的<code>stub_helper</code>节区头部，此处的代码通常为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lea        r11, qword [ds:zzz]</div><div class="line">push       r11</div><div class="line">jmp        qword [ds:imp___nl_symbol_ptr_dyld_stub_binder]</div></pre></td></tr></table></figure></p>
<p><code>jmp</code>跳转的地址是<code>__DATA</code>段中<code>__nl_symbol_ptr</code>节区，指向的是符号<code>dyld_stub_binder()</code>，该函数由dyld导出，实现位于dyld源码的“dyld_stub_binder.s”文件中，它调用<code>dyld::fastBindLazySymbol()</code>来绑定延迟加载的符号，后者是一个虚函数，实际调用<code>ImageLoaderMachOCompressed</code>的<code>doBindFastLazySymbol()</code>，后者调用<code>bindAt()</code>解析并返回正确的符号地址，<code>dyld_stub_binder()</code>在最后跳转到符号地址去执行。这一步完成后，<code>__DATA</code>段<code>__la_symbol_ptr</code>节区中存储的符号地址就是修正后的地址，下一次调用该符号时，就直接跳转到真正的符号地址去执行，而不用<code>dyld_stub_binder()</code>来重新解析该符号了，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/14/dylib/" data-id="cixww7lmy0000f3vjlactpdru" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
  
</article>


  
    <article id="post-macho" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/macho/" class="article-date">
  <time datetime="2017-01-13T01:03:08.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/macho/">Mach-O文件格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x1-通用二进制格式"><a href="#0x1-通用二进制格式" class="headerlink" title="0x1 通用二进制格式"></a>0x1 通用二进制格式</h2><p>虽然macOS系统使用了很多UNIX上的特性，但它并没有使用ELF作为系统的可执行文件格式，而是使用自家独创的Mach-O文件格式。</p>
<p>macOS系统一路走来，支持的CPU及硬件平台都有了很大的变化，从早期的PowerPC平台，到后来的x86，再到现在主流的arm、x86-64平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。<br>又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同CPU架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行<code>file</code>命令可以查看它的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ file /usr/bin/python</div><div class="line">/usr/bin/python: Mach-O universal binary with 2 architectures</div><div class="line">/usr/bin/python (for architecture x86_64):	Mach-O 64-bit executable x86_64</div><div class="line">/usr/bin/python (for architecture i386):	Mach-O executable i386</div></pre></td></tr></table></figure></p>
<p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。例如提取<code>python</code>中x86_64版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>删除x86版本的二进制文件可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>或者直接瘦身为x86_64版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</div></pre></td></tr></table></figure></p>
<p>通用二进制的“通用”不止针对可以直接运行的可执行程序，系统中的动态库dylib、静态库.a文件以及框架等都可以是通用二进制文件，对它们也可以同样使用<code>lipo</code>命令来进行管理。<br>下来看一下通用二进制的文件格式。安装好macOS程序开发的SDK后，或者在xnu的内核源码中，都可以在&lt;mach-o/fat.h&gt;文件中找到通用二进制文件格式的声明。从文件命名上看，将通用二进制称为胖二进制更方便一些。胖二进制头部结构<code>fat_header</code>定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define FAT_MAGIC	0xcafebabe</div><div class="line">#define FAT_CIGAM	0xbebafeca	/* NXSwapLong(FAT_MAGIC) */</div><div class="line"></div><div class="line">struct fat_header &#123;</div><div class="line">	uint32_t	magic;		/* FAT_MAGIC */</div><div class="line">	uint32_t	nfat_arch;	/* number of structs that follow */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段被定义为常量<code>FAT_MAGIC</code>，它的取值是固定的0xcafebabe，表示这是一个通用的二进制文件。<code>nfat_arch</code>字段指明了通用二进制中包含多少个Mach-O文件。<br>每个通用二进制架构信息都使用<code>fat_arch</code>结构表示，在<code>fat_header</code>结构体之后，紧接着的是一个或多个连续的<code>fat_arch</code>结构体，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct fat_arch &#123;</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier (int) */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier (int) */</div><div class="line">	uint32_t	offset;		/* file offset to this object file */</div><div class="line">	uint32_t	size;		/* size of this object file */</div><div class="line">	uint32_t	align;		/* alignment as a power of 2 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cputype</code>指定了具体的cpu类型，它的类型是<code>cpu_type_t</code>，定义位于mach/machine.h中。<code>cpu</code>的常用类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define CPU_TYPE_X86		((cpu_type_t) 7)</div><div class="line">#define CPU_TYPE_I386		CPU_TYPE_X86		</div><div class="line">#define	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC98000	((cpu_type_t) 10)</div><div class="line">#define CPU_TYPE_HPPA           ((cpu_type_t) 11)</div><div class="line">#define CPU_TYPE_ARM		((cpu_type_t) 12)</div><div class="line">#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</div><div class="line">#define CPU_TYPE_MC88000	((cpu_type_t) 13)</div><div class="line">#define CPU_TYPE_SPARC		((cpu_type_t) 14)</div><div class="line">#define CPU_TYPE_I860		((cpu_type_t) 15)</div><div class="line">#define CPU_TYPE_POWERPC		((cpu_type_t) 18)</div><div class="line">#define CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64</div></pre></td></tr></table></figure></p>
<p>macOS平台上的CPU类型一般为<code>CPU_TYPE_X86_64</code>。</p>
<p><code>cpusubtype</code>指定了cpu的子类型。它的类型是<code>cpu_subtype_t</code>。cpu子类型主要有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define CPU_SUBTYPE_MASK	0xff000000</div><div class="line">#define CPU_SUBTYPE_LIB64	0x80000000</div><div class="line">#define CPU_SUBTYPE_X86_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_64_ALL		((cpu_subtype_t)3)</div><div class="line">#define CPU_SUBTYPE_X86_ARCH1		((cpu_subtype_t)4)</div><div class="line">#define CPU_SUBTYPE_X86_64_H		((cpu_subtype_t)8)</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>cpu子类型一般<code>CPU_SUBTYPE_LIB64</code>与<code>CPU_SUBTYPE_X86_64_ALL</code>比较常见。</p>
<p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值。<code>size</code>字段指明了数据的大小。</p>
<p><code>align</code>字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。</p>
<p>可以使用<code>otool</code>工具打印本机安装的<code>python</code>程序的<code>fat_header</code>信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">otool -f -V /usr/bin/python</div><div class="line">Fat headers</div><div class="line">fat_magic FAT_MAGIC</div><div class="line">nfat_arch 2</div><div class="line">architecture i386</div><div class="line">    cputype CPU_TYPE_I386</div><div class="line">    cpusubtype CPU_SUBTYPE_I386_ALL</div><div class="line">    capabilities 0x0</div><div class="line">    offset 4096</div><div class="line">    size 29632</div><div class="line">    align 2^12 (4096)</div><div class="line">architecture x86_64</div><div class="line">    cputype CPU_TYPE_X86_64</div><div class="line">    cpusubtype CPU_SUBTYPE_X86_64_ALL</div><div class="line">    capabilities CPU_SUBTYPE_LIB64</div><div class="line">    offset 36864</div><div class="line">    size 29872</div><div class="line">    align 2^12 (4096)</div></pre></td></tr></table></figure></p>
<p>如果你是UNIX的使用者，经常使用GNU里面<code>binutils</code>提供的<code>objdump</code>查看可执行文件信息的话，在macOS上可以使用它的移植版本<code>gobjdump</code>，使用<code>HomeBrew</code>运行以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install binutils</div></pre></td></tr></table></figure></p>
<p>完装完成后，执行下面的命令也可以查看<code>python</code>程序的<code>fat_header</code>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ gobjdump -f /usr/bin/python</div><div class="line">In archive /usr/bin/python:</div><div class="line"></div><div class="line">i386:     file format mach-o-i386</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00001be0</div><div class="line"></div><div class="line">i386:x86-64:     file format mach-o-x86-64</div><div class="line">architecture: i386:x86-64, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x0000000100000e20</div></pre></td></tr></table></figure></p>
<p>在<code>fat_arch</code>结构体往下就是具体的Mach-O文件格式了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h2 id="0x2-Mach-O文件格式简介"><a href="#0x2-Mach-O文件格式简介" class="headerlink" title="0x2 Mach-O文件格式简介"></a>0x2 Mach-O文件格式简介</h2><p>Mach-O（Mach Object File Format）描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式，有助于了解苹果底层软件运行机制，更好的掌握<code>dyld</code>加载Mach-O的步骤，为自己动手开发Mach-O相关的加解密工具打下基础。</p>
<p>一个典型的Mach-O文件格式如图所示：<br><img src="/2017/01/13/macho/mach-o.png" alt="mach-o"><br>通过上图，可以看出Mach-O主要由以下三部分组成：</p>
<ul>
<li>Mach-O头部（mach header）。描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</li>
<li>加载命令（load command）。描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</li>
<li>Data。Data中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个Section，它们存放了具体的数据与代码。</li>
</ul>
<h2 id="0x3-Mach-O头部"><a href="#0x3-Mach-O头部" class="headerlink" title="0x3 Mach-O头部"></a>0x3 Mach-O头部</h2><p>与Mach-O文件格式有关的结构体，都可以直接或间接的在”mach-o/loader.h“文件中找到。<br>针对32位与64位架构的cpu，分别使用了<code>mach_header</code>与<code>mach_header_64</code>结构体来描述Mach-O头部。<br><code>mach_header</code>结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct mach_header &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样，表示Mach-O文件的魔数值，对于32位架构的程序来说，它的取值是<code>MH_MAGIC</code>，固定为0xfeedface。<br><code>cputype</code>与<code>cpusubtype</code>字段与<code>fat_header</code>结构体中的含义完全相同。<br><code>filetype</code>字段表示Mach-O的具体文件类型。它的取值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#define	MH_OBJECT	0x1		/* relocatable object file */</div><div class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */</div><div class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</div><div class="line">#define	MH_CORE		0x4		/* core file */</div><div class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</div><div class="line">#define	MH_DYLIB	0x6		/* dynamically bound shared library */</div><div class="line">#define	MH_DYLINKER	0x7		/* dynamic link editor */</div><div class="line">#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */</div><div class="line">#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */</div><div class="line">					/*  linking only, no section contents */</div><div class="line">#define	MH_DSYM		0xa		/* companion file with only debug sections */</div><div class="line">#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */</div></pre></td></tr></table></figure></p>
<p>这里主要关注<code>MH_EXECUTE</code>、<code>MH_DYLIB</code>与<code>MH_DYLIB</code>这3个文件格式。</p>
<p>接下来的<code>ncmds</code>指明了Mach-O文件中加载命令（load commands）的数量。</p>
<p><code>sizeofcmds</code>字段指明了Mach-O文件加载命令（load commands）所占的总字节大小。</p>
<p><code>flags</code>字段表示文件标志，它是一个含有一组位标志的整数，指明了Mach-O文件的一些标志信息。可用的值有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define	MH_NOUNDEFS	0x1</div><div class="line">#define	MH_INCRLINK	0x2</div><div class="line">#define MH_DYLDLINK	0x4</div><div class="line">#define MH_LAZY_INIT 0x40</div><div class="line">#define MH_TWOLEVEL	0x80</div><div class="line">#define MH_PIE 0x200000</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>针对64位Mach-O的<code>mach_header_64</code>结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct mach_header_64 &#123;</div><div class="line">	uint32_t	magic;		/* mach magic number identifier */</div><div class="line">	cpu_type_t	cputype;	/* cpu specifier */</div><div class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</div><div class="line">	uint32_t	filetype;	/* type of file */</div><div class="line">	uint32_t	ncmds;		/* number of load commands */</div><div class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">	uint32_t	reserved;	/* reserved */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>相比<code>mach_header</code>，它多出了一个<code>reserved</code>字段，目前它的取值系统保留。<code>mach_header_64</code>结构体中的字段与<code>mach_header</code>中的基本一致，除了<code>magic</code>字段的取值是<code>MH_MAGIC_64</code>，固定的值为0xfeedfacf。<br>学习Mach-o文件格式时，可以使用辅助工具查看具体的文件结构，这样效果更加直观。<br>下图是<code>MachOView</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/mach_header.png" alt="mach_header"><br>下图是<code>010 Editor</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/010_editor.png" alt="010_editor"><br>下图是<code>Synalyze It!</code>查看<code>optool</code>程序Mach64 Header的效果：<br><img src="/2017/01/13/macho/synalyze_it.png" alt="synalyze_it"><br>这三款工具对于学习Mach-O文件格式都是非常有帮助的，读者在实际分析时可以多多使用。</p>
<h2 id="0x4-加载命令"><a href="#0x4-加载命令" class="headerlink" title="0x4 加载命令"></a>0x4 加载命令</h2><p>在<code>mach_header</code>之后的是Load Command加载命令，这些加载命令在Mach-O文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">	uint32_t cmd;		/* type of load command */</div><div class="line">	uint32_t cmdsize;	/* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此结构对应的成员只有2个：<code>cmd</code>字段代表当前加载命令的类型。<code>cmdsize</code>字段代表当前加载命令的大小。<br>cmd的类型不同，所代表的加载命令的类型就不同，它的结构体也会有所不一样，对于不同类型的加载命令，它们都会在<code>load_command</code>结构体后面加上一个或多个字段来表示自己特定的结构体信息。</p>
<p>macOS系统在进化的过程中，加载命令算是比较频繁被更新的一个数据结构体，截止到macOS 10.12系统，加载命令的类型cmd的取值共有48种。它们的部分定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */</div><div class="line">#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */</div><div class="line">#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */</div><div class="line">#define	LC_THREAD	0x4	/* thread */</div><div class="line">#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */</div><div class="line">#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */</div><div class="line">#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */</div><div class="line">#define	LC_IDENT	0x8	/* object identification info (obsolete) */</div><div class="line">#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */</div><div class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</div><div class="line">#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */</div><div class="line">#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */</div><div class="line">......</div><div class="line">#define	LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</div><div class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</div><div class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</div><div class="line">#ifndef __OPEN_SOURCE__</div><div class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</div><div class="line">#endif /* __OPEN_SOURCE__ */</div><div class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</div></pre></td></tr></table></figure></p>
<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_SEGMENT</code>、<code>LC_LOAD_DYLINKER</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等。</p>
<p><code>LC_SEGMENT</code>：表示这是一个段加载命令，需要将它加载到对应的进程空间上去。段加载命令将在下一小节进行讨论。</p>
<p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用<code>dylib_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct dylib_command &#123;</div><div class="line">	uint32_t	cmd;		/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,LC_REEXPORT_DYLIB */</div><div class="line">	uint32_t	cmdsize;	/* includes pathname string */</div><div class="line">	struct dylib dylib;		/* the library identification */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当cmd类型时<code>LC_ID_DYLIB</code>、<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>与<code>LC_REEXPORT_DYLIB</code>时，统一使用<code>dylib_command</code>结构体表示。<br>它使用dylib结构体来存储要加载的动态库的具体信息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct dylib &#123;</div><div class="line">    union lc_str  name;			/* library&apos;s path name */</div><div class="line">    uint32_t timestamp;			/* library&apos;s build time stamp */</div><div class="line">    uint32_t current_version;		/* library&apos;s current version number */</div><div class="line">    uint32_t compatibility_version;	/* library&apos;s compatibility vers number*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>name</code>字段是动态库的完整路径，动态链接器在加载动态库时，通用此路径来进行加载它。<br><code>timestamp</code>字段描述了动态库构建时的时间戳。<code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号。</p>
<p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数<code>main()</code>的位置。它使用<code>entry_point_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct entry_point_command &#123;</div><div class="line">    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */</div><div class="line">    uint32_t  cmdsize;	/* 24 */</div><div class="line">    uint64_t  entryoff;	/* file (__TEXT) offset of main() */</div><div class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>entryoff</code>字段中就指定了<code>main()</code>函数的文件偏移。<code>stacksize</code>指定了初始的堆栈大小。</p>
<h2 id="0x5-LC-CODE-SIGNATURE与代码签名过程分析"><a href="#0x5-LC-CODE-SIGNATURE与代码签名过程分析" class="headerlink" title="0x5 LC_CODE_SIGNATURE与代码签名过程分析"></a>0x5 LC_CODE_SIGNATURE与代码签名过程分析</h2><p><code>LC_CODE_SIGNATURE</code>：代码签名加载命令。描述了Mach-O的代码签名信息，它属于链接信息，使用<code>linkedit_data_command</code>结构体表示。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct linkedit_data_command &#123;</div><div class="line">    uint32_t	cmd;		/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,</div><div class="line">                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,</div><div class="line">				   LC_DYLIB_CODE_SIGN_DRS or</div><div class="line">				   LC_LINKER_OPTIMIZATION_HINT. */</div><div class="line">    uint32_t	cmdsize;	/* sizeof(struct linkedit_data_command) */</div><div class="line">    uint32_t	dataoff;	/* file offset of data in __LINKEDIT segment */</div><div class="line">    uint32_t	datasize;	/* file size of data in __LINKEDIT segment  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>dataoff</code>字段指明了相对于<code>__LINKEDIT</code>段的文件偏移位置，<code>datasize</code>字段指明了数据的大小。<br>由于<code>dataoff</code>与<code>datasize</code>分别指明了代码签名的位置与大小，那么笔者在此提个问：如何删除Mach-O中包含的代码签名信息？</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的“bsd/sys/codesign.h”文件中找到。整个代码签名部分的头部使用一个<code>CS_SuperBlob</code>结构体定义，它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_SuperBlob &#123;</div><div class="line">	uint32_t magic;					/* magic number */</div><div class="line">	uint32_t length;				/* total length of SuperBlob */</div><div class="line">	uint32_t count;					/* number of index entries following */</div><div class="line">	CS_BlobIndex index[];			/* (count) entries */</div><div class="line">	/* followed by Blobs in no particular order as indicated by offsets in index */</div><div class="line">&#125; CS_SuperBlob;</div></pre></td></tr></table></figure></p>
<p><code>magic</code>字段指明了Blob的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">	CSMAGIC_REQUIREMENT = 0xfade0c00,		/* single Requirement blob */</div><div class="line">	CSMAGIC_REQUIREMENTS = 0xfade0c01,		/* Requirements vector (internal requirements) */</div><div class="line">	CSMAGIC_CODEDIRECTORY = 0xfade0c02,		/* CodeDirectory blob */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */</div><div class="line">	CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02,	/* XXX */</div><div class="line">	CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,	/* embedded entitlements */</div><div class="line">	CSMAGIC_DETACHED_SIGNATURE = 0xfade0cc1, /* multi-arch collection of embedded signatures */</div><div class="line">	CSMAGIC_BLOBWRAPPER = 0xfade0b01,	/* CMS Signature, among other things */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第一个Blob来说，它的值必定是<code>CSMAGIC_EMBEDDED_SIGNATURE</code>，表示代码签名采用的嵌入式的签名信息。<br><code>length</code>字段指明了整个SuperBlob的大小，其中包含马上的介绍的CodeDirectory、Requirement、Entitlement的大小。<br><code>count</code>字段指明了接下来会有多少个子条目。<br>从<code>index</code>开始，就是每一个字条目的索引了，它的结构是<code>CS_BlobIndex</code>，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct __BlobIndex &#123;</div><div class="line">	uint32_t type;					/* type of entry */</div><div class="line">	uint32_t offset;				/* offset of entry */</div><div class="line">&#125; CS_BlobIndex;</div></pre></td></tr></table></figure></p>
<p><code>type</code>指明了子条目的类型，可选值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CSSLOT_CODEDIRECTORY = 0,				/* slot index for CodeDirectory */</div><div class="line">CSSLOT_INFOSLOT = 1,</div><div class="line">CSSLOT_REQUIREMENTS = 2,</div><div class="line">CSSLOT_RESOURCEDIR = 3,</div><div class="line">CSSLOT_APPLICATION = 4,</div><div class="line">CSSLOT_ENTITLEMENTS = 5,</div><div class="line">CSSLOT_SIGNATURESLOT = 0x10000,			/* CMS Signature */</div></pre></td></tr></table></figure></p>
<p><code>offset</code>字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>通常，签名后的程序，签名数据的第一个子条目指向的是一个<code>type</code>为<code>CSSLOT_CODEDIRECTORY</code>的结构，它是一个<code>CS_CodeDirectory</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct __CodeDirectory &#123;</div><div class="line">	uint32_t magic;					/* magic number (CSMAGIC_CODEDIRECTORY) */</div><div class="line">	uint32_t length;				/* total length of CodeDirectory blob */</div><div class="line">	uint32_t version;				/* compatibility version */</div><div class="line">	uint32_t flags;					/* setup and mode flags */</div><div class="line">	uint32_t hashOffset;			/* offset of hash slot element at index zero */</div><div class="line">	uint32_t identOffset;			/* offset of identifier string */</div><div class="line">	uint32_t nSpecialSlots;			/* number of special hash slots */</div><div class="line">	uint32_t nCodeSlots;			/* number of ordinary (code) hash slots */</div><div class="line">	uint32_t codeLimit;				/* limit to main image signature range */</div><div class="line">	uint8_t hashSize;				/* size of each hash in bytes */</div><div class="line">	uint8_t hashType;				/* type of hash (cdHashType* constants) */</div><div class="line">	uint8_t platform;				/* platform identifier; zero if not platform binary */</div><div class="line">	uint8_t	pageSize;				/* log2(page size in bytes); 0 =&gt; infinite */</div><div class="line">	uint32_t spare2;				/* unused (must be zero) */</div><div class="line">	/* Version 0x20100 */</div><div class="line">	uint32_t scatterOffset;				/* offset of optional scatter vector */</div><div class="line">	/* Version 0x20200 */</div><div class="line">	uint32_t teamOffset;				/* offset of optional team identifier */</div><div class="line">	/* followed by dynamic content as located by offset fields above */</div><div class="line">&#125; CS_CodeDirectory;</div></pre></td></tr></table></figure></p>
<p>该结构体数据字段较多，此处只关注与签名相关的字段。<code>hashOffset</code>指明了Hash数据的文件相对偏移，注意是相对于当前结构体<code>CS_CodeDirectory</code>，<code>hashType</code>与<code>hashSize</code>指明了代码签名时使用的算法与每一项签名数据的长度，目前macOS使用的签名算法是SHA-1，长度为20字节。<br><code>nSpecialSlots</code>与<code>nCodeSlots</code>指定的代码签名数据条目的个数，前者是针对代码签名中所有的Blob，后者针对程序文件内容。<code>codesign</code>程序在对程序进行签名时，会对SuperBlob中每个子条目进行签名，即对Blob的内容调用SHA-1算法取Hash值，<code>nSpecialSlots</code>的值就是子条目Blob的个数；同时，<code>codesign</code>会以<code>pageSize</code>字段指定的页大小为单位（通常取值是0x1000），对程序数据进行签名，每一页签名后生成一条签名数据，<code>nCodeSlots</code>的值就是签名数据的页数，即程序数据大小除以<code>pageSize</code>字段后的值。</p>
<p>在<code>CS_CodeDirectory</code>之后，就是Requirements了，它是一个<code>CS_SuperBlob</code>结构体，指明了Requirement的个数与每一个的偏移。接下来就是每一个Requirement数据了，它是一个<code>CS_GenericBlob</code>结构体，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct __SC_GenericBlob &#123;</div><div class="line">	uint32_t magic;				/* magic number */</div><div class="line">	uint32_t length;			/* total length of blob */</div><div class="line">	char data[];</div><div class="line">&#125; CS_GenericBlob;</div></pre></td></tr></table></figure></p>
<p>可以看到，它的前两个字段与<code>CS_SuperBlob</code>是一样的，只是后面多出一个<code>data</code>字段，用来存放Blob的数据长度。<br>在Requirement数据下面，就是Entitlement了，它同样是<code>CS_GenericBlob</code>结构。拿本机Calculator计算器程序来说，它的Entitlement的数据内容是一个xml文件，提取出来内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class="line">&lt;plist version=&quot;1.0&quot;&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.network.client&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">	&lt;key&gt;com.apple.security.print&lt;/key&gt;</div><div class="line">	&lt;true/&gt;</div><div class="line">&lt;/dict&gt;</div><div class="line">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>
<p>最后一个Blob通常是签名使用的证书了，Certificates签名证书也是<code>CS_GenericBlob</code>结构，提取它的证书数据后保存为cer文件，使用macOS的文件预览证书内容，效果如图所示：<br><img src="/2017/01/13/macho/calc_cer.png" alt="calc_cer"></p>
<p>下面再来看看，系统是如何实施代码签名验证的！内核加载解析Mach-O加载命令的函数是<code>parse_machfile()</code>，位于内核代码”/bsd/kern/mach_loader.c“文件中，部分代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	uint32_t		ncmds;</div><div class="line">	struct load_command	*lcp;</div><div class="line">	struct dylinker_command	*dlp = 0;</div><div class="line">	integer_t		dlarchbits = 0;</div><div class="line">	void *			control;</div><div class="line">	load_return_t		ret = LOAD_SUCCESS;</div><div class="line">	caddr_t			addr;</div><div class="line">	void *			kl_addr;</div><div class="line">	vm_size_t		size,kl_size;</div><div class="line">	size_t			offset;</div><div class="line">	size_t			oldoffset;	/* for overflow check */</div><div class="line">	int			pass;</div><div class="line">	proc_t			p = current_proc();		/* XXXX */</div><div class="line">	int			error;</div><div class="line">	int resid=0;</div><div class="line">	size_t			mach_header_sz = sizeof(struct mach_header);</div><div class="line">	boolean_t		abi64;</div><div class="line">	boolean_t		got_code_signatures = FALSE;</div><div class="line">	int64_t			slide = 0;</div><div class="line"></div><div class="line">	if (header-&gt;magic == MH_MAGIC_64 ||</div><div class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</div><div class="line">	    	mach_header_sz = sizeof(struct mach_header_64);</div><div class="line">	&#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">	case LC_CODE_SIGNATURE:</div><div class="line">		/* CODE SIGNING */</div><div class="line">		if (pass != 1)</div><div class="line">			break;</div><div class="line">		/* pager -&gt; uip -&gt;</div><div class="line">			load signatures &amp; store in uip</div><div class="line">			set VM object &quot;signed_pages&quot;</div><div class="line">		*/</div><div class="line">		ret = load_code_signature(</div><div class="line">			(struct linkedit_data_command *) lcp,</div><div class="line">			vp,</div><div class="line">			file_offset,</div><div class="line">			macho_size,</div><div class="line">			header-&gt;cputype,</div><div class="line">			result);</div><div class="line">		if (ret != LOAD_SUCCESS) &#123;</div><div class="line">			printf(&quot;proc %d: load code signature error %d &quot;</div><div class="line">					&quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">			/*</div><div class="line">				* Allow injections to be ignored on devices w/o enforcement enabled</div><div class="line">				*/</div><div class="line">			if (!cs_enforcement(NULL))</div><div class="line">				ret = LOAD_SUCCESS; /* ignore error */</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			got_code_signatures = TRUE;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (got_code_signatures) &#123;</div><div class="line">			unsigned tainted = CS_VALIDATE_TAINTED;</div><div class="line">			boolean_t valid = FALSE;</div><div class="line">			struct cs_blob *blobs;</div><div class="line">			vm_size_t off = 0;</div><div class="line"></div><div class="line"></div><div class="line">			if (cs_debug &gt; 10)</div><div class="line">				printf(&quot;validating initial pages of %s\n&quot;, vp-&gt;v_name);</div><div class="line">			blobs = ubc_get_cs_blobs(vp);</div><div class="line"></div><div class="line">			while (off &lt; size &amp;&amp; ret == LOAD_SUCCESS) &#123;</div><div class="line">					tainted = CS_VALIDATE_TAINTED;</div><div class="line"></div><div class="line">					valid = cs_validate_page(blobs,</div><div class="line">								NULL,</div><div class="line">								file_offset + off,</div><div class="line">								addr + off,</div><div class="line">								&amp;tainted);</div><div class="line">					if (!valid || (tainted &amp; CS_VALIDATE_TAINTED)) &#123;</div><div class="line">						if (cs_debug)</div><div class="line">							printf(&quot;CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n&quot;,</div><div class="line">							vp-&gt;v_name, p-&gt;p_pid, (long long)(file_offset + off), valid, tainted, result-&gt;csflags);</div><div class="line">						if (cs_enforcement(NULL) ||</div><div class="line">						(result-&gt;csflags &amp; (CS_HARD|CS_KILL|CS_ENFORCEMENT))) &#123;</div><div class="line">							ret = LOAD_FAILURE;</div><div class="line">						&#125;</div><div class="line">						result-&gt;csflags &amp;= ~CS_VALID;</div><div class="line">					&#125;</div><div class="line">					off += PAGE_SIZE;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>整个代码签名的验证过程大致分为<code>load_code_signature()</code>与<code>cs_validate_page()</code>两步，前者负责加载代码签名，后者负责验证数据页面。<code>load_code_signature()</code>在加载代码签名时，通过调用<code>ubc_cs_blob_get()</code>来获取特定CPU的<code>cs_blob</code>指针，<code>ubc_cs_blob_get()</code>第一次调用时，返回的<code>cs_blob</code>指针为空，会调用<code>ubc_cs_blob_add()</code>来加载与验证文件中的Blob信息，以后再调用<code>ubc_cs_blob_get()</code>，就会返回内存中的<code>cs_blob</code>指针，当然不是直接返回，系统会再次判断内存中的<code>cs_blob</code>指针是否损坏或遭到篡改，具体方法是调用<code>ubc_cs_generation_check()</code>做初步的检查，之后调用<code>ubc_cs_blob_revalidate()</code>对blob做重验证。load_code_signature()`函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">static load_return_t</div><div class="line">load_code_signature(</div><div class="line">	struct linkedit_data_command	*lcp,</div><div class="line">	struct vnode			*vp,</div><div class="line">	off_t				macho_offset,</div><div class="line">	off_t				macho_size,</div><div class="line">	cpu_type_t			cputype,</div><div class="line">	load_result_t			*result)</div><div class="line">&#123;</div><div class="line">	int		ret;</div><div class="line">	kern_return_t	kr;</div><div class="line">	vm_offset_t	addr;</div><div class="line">	int		resid;</div><div class="line">	struct cs_blob	*blob;</div><div class="line">	int		error;</div><div class="line">	vm_size_t	blob_size;</div><div class="line"></div><div class="line">	addr = 0;</div><div class="line">	blob = NULL;</div><div class="line"></div><div class="line">	if (lcp-&gt;cmdsize != sizeof (struct linkedit_data_command) ||</div><div class="line">	    lcp-&gt;dataoff + lcp-&gt;datasize &gt; macho_size) &#123;</div><div class="line">		ret = LOAD_BADMACHO;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line">	if (blob != NULL) &#123;</div><div class="line">		/* we already have a blob for this vnode and cputype */</div><div class="line">		if (blob-&gt;csb_cpu_type == cputype &amp;&amp;</div><div class="line">		    blob-&gt;csb_base_offset == macho_offset &amp;&amp;</div><div class="line">		    blob-&gt;csb_mem_size == lcp-&gt;datasize) &#123;</div><div class="line">			/* it matches the blob we want here, lets verify the version */</div><div class="line">			if(0 != ubc_cs_generation_check(vp)) &#123;</div><div class="line">				if (0 != ubc_cs_blob_revalidate(vp, blob, 0)) &#123;</div><div class="line">					ret = LOAD_FAILURE; /* set error same as from ubc_cs_blob_add */</div><div class="line">					goto out;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			ret = LOAD_SUCCESS;</div><div class="line">		&#125; else &#123;</div><div class="line">			/* the blob has changed for this vnode: fail ! */</div><div class="line">			ret = LOAD_BADMACHO;</div><div class="line">		&#125;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	blob_size = lcp-&gt;datasize;</div><div class="line">	kr = ubc_cs_blob_allocate(&amp;addr, &amp;blob_size);</div><div class="line">	if (kr != KERN_SUCCESS) &#123;</div><div class="line">		ret = LOAD_NOSPACE;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	resid = 0;</div><div class="line">	error = vn_rdwr(UIO_READ,</div><div class="line">			vp,</div><div class="line">			(caddr_t) addr,</div><div class="line">			lcp-&gt;datasize,</div><div class="line">			macho_offset + lcp-&gt;dataoff,</div><div class="line">			UIO_SYSSPACE,</div><div class="line">			0,</div><div class="line">			kauth_cred_get(),</div><div class="line">			&amp;resid,</div><div class="line">			current_proc());</div><div class="line">	if (error || resid != 0) &#123;</div><div class="line">		ret = LOAD_IOERROR;</div><div class="line">		goto out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (ubc_cs_blob_add(vp,</div><div class="line">			    cputype,</div><div class="line">			    macho_offset,</div><div class="line">			    addr,</div><div class="line">			    lcp-&gt;datasize,</div><div class="line">			    0)) &#123;</div><div class="line">		ret = LOAD_FAILURE;</div><div class="line">		goto out;</div><div class="line">	&#125; else &#123;</div><div class="line">		/* ubc_cs_blob_add() has consumed &quot;addr&quot; */</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">#if CHECK_CS_VALIDATION_BITMAP</div><div class="line">	ubc_cs_validation_bitmap_allocate( vp );</div><div class="line">#endif</div><div class="line"></div><div class="line">	blob = ubc_cs_blob_get(vp, cputype, macho_offset);</div><div class="line"></div><div class="line">	ret = LOAD_SUCCESS;</div><div class="line">out:</div><div class="line">	if (ret == LOAD_SUCCESS) &#123;</div><div class="line">		result-&gt;csflags |= blob-&gt;csb_flags;</div><div class="line">		result-&gt;platform_binary = blob-&gt;csb_platform_binary;</div><div class="line">		result-&gt;cs_end_offset = blob-&gt;csb_end_offset;</div><div class="line">	&#125;</div><div class="line">	if (addr != 0) &#123;</div><div class="line">		ubc_cs_blob_deallocate(addr, blob_size);</div><div class="line">		addr = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，上面提到的<code>cs_blob</code>指针，其实就是代码签名数据中的<code>CS_SuperBlob</code>指针类型。<br><code>ubc_cs_blob_add()</code>的代码比较长，它主要做了三个工作：一是调用<code>cs_validate_csblob()</code>验证<code>cs_blob</code>指针的合法性，<code>cs_validate_csblob()</code>会对<code>CSMAGIC_EMBEDDED_SIGNATURE</code>与<code>CSMAGIC_CODEDIRECTORY</code>做相应的验证处理，包括调用<code>cs_validate_codedirectory()</code>验证<code>CS_CodeDirectory</code>结构体的合法性，以及调用<code>cs_validate_blob()</code>来验证<code>CS_SuperBlob</code>中每一个<code>CS_GenericBlob</code>是否合法有效；二是调用<code>mac_vnode_check_signature()</code>验证Blob块的代码签名，也就是比较Blob块的SHA1哈希值是否与计算的值相同；三是加载所有的代码签名Hash信息，填充<code>cs_blobs</code>字段，为下一步的内存页签名验证做准备。<br><code>ubc_cs_blob_revalidate()</code>做着与<code>ubc_cs_blob_add()</code>几乎相同的验证检查，但前者因为已经有了一些缓存信息，因此检查时会快一些。</p>
<p><code>load_code_signature()</code>完事以后，会调用<code>ubc_get_cs_blobs()</code>获取<code>cs_blobs</code>指针，最后调用<code>cs_validate_page()</code>以逐页的形式验证文件中每一页的数据的签名。<br>以上检查做完后，<code>LC_CODE_SIGNATURE</code>就处理完了，没有错误发生就表示代码签名验证通过了。</p>
<p>讲完了代码签名，再讲讲代码加密。Mach-O程序如果使用了代码加密技术，在加载命令列表中会有一个<code>LC_ENCRYPTION_INFO</code>加载命令。它存储了Mach-O的加密信息。关于此加载命令，对于搞过iOS程序逆向的读者应该不会感到陌生。iOS系统由于安全机制的原因，会对App Store中上架的应用默认开启数据加密。<br>被加密过的App文件，部分段的数据内容是经过加密的，而记录加密数据的关键就是<code>LC_ENCRYPTION_INFO</code>加载命令。分析人员要想对加密过的App进行逆向分析，必须先经过一次解密（俗称“砸壳”）操作。<br><code>LC_ENCRYPTION_INFO</code>使用<code>encryption_info_command</code>结构体表示。定义如下（<code>LC_ENCRYPTION_INFO_64</code>使用<code>encryption_info_command_64</code>表示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct encryption_info_command &#123;</div><div class="line">   uint32_t	cmd;		/* LC_ENCRYPTION_INFO */</div><div class="line">   uint32_t	cmdsize;	/* sizeof(struct encryption_info_command) */</div><div class="line">   uint32_t	cryptoff;	/* file offset of encrypted range */</div><div class="line">   uint32_t	cryptsize;	/* file size of encrypted range */</div><div class="line">   uint32_t	cryptid;	/* which enryption system, 0 means not-encrypted yet */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cryptoff</code>与<code>cryptsize</code>字段分别指明了加密数据的文件偏移与大小。<code>cryptid</code>指定了使用的加密系统。<br>聪明的安全研究人员，根据Mach-O在内存中被加载完后即解密完成的特点，开发了针对iOS平台App的代码解密工具<code>dumpdecrypted</code>，<br>下载地址是：<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">https://github.com/stefanesser/dumpdecrypted</a> 。通过将内存中解密后的数据写回原位置，并将<code>cryptid</code>置0来达到解密App的目的。</p>
<p>再来看看系统是如何处理<code>LC_ENCRYPTION_INFO</code>的，它的解析函数也是<code>parse_machfile()</code>，代码片断如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static load_return_t parse_machfile(</div><div class="line">	struct vnode 		*vp,       </div><div class="line">	vm_map_t		map,</div><div class="line">	thread_t		thread,</div><div class="line">	struct mach_header	*header,</div><div class="line">	off_t			file_offset,</div><div class="line">	off_t			macho_size,</div><div class="line">	int			depth,</div><div class="line">	int64_t			aslr_offset,</div><div class="line">	int64_t			dyld_aslr_offset,</div><div class="line">	load_result_t		*result</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line">			case LC_ENCRYPTION_INFO:</div><div class="line">			case LC_ENCRYPTION_INFO_64:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				ret = set_code_unprotect(</div><div class="line">					(struct encryption_info_command *) lcp,</div><div class="line">					addr, map, slide, vp,</div><div class="line">					header-&gt;cputype, header-&gt;cpusubtype);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: set_code_unprotect() error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					/*</div><div class="line">					 * Don&apos;t let the app run if it&apos;s</div><div class="line">					 * encrypted but we failed to set up the</div><div class="line">					 * decrypter. If the keys are missing it will</div><div class="line">					 * return LOAD_DECRYPTFAIL.</div><div class="line">					 */</div><div class="line">					 if (ret == LOAD_DECRYPTFAIL) &#123;</div><div class="line">						/* failed to load due to missing FP keys */</div><div class="line">						proc_lock(p);</div><div class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</div><div class="line">						proc_unlock(p);</div><div class="line">					&#125;</div><div class="line">					 psignal(p, SIGKILL);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#endif</div><div class="line">			default:</div><div class="line">				/* Other commands are ignored by the kernel */</div><div class="line">				ret = LOAD_SUCCESS;</div><div class="line">				break;</div><div class="line"></div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>当系统内核被配置为启用代码解密，即定义了<code>CONFIG_CODE_DECRYPTION</code>之后，<code>parse_machfile()</code>函数会解析<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令。<br>最终是调用了<code>set_code_unprotect()</code>函数来对代码进行解密。该函数通过<code>encryption_info_command</code>中的<code>cryptid</code>来确定使用的加密系统，然后对代码进行内存解密。它的代码片断如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line"></div><div class="line">static load_return_t</div><div class="line">set_code_unprotect(</div><div class="line">		   struct encryption_info_command *eip,</div><div class="line">		   caddr_t addr, 	</div><div class="line">		   vm_map_t map,</div><div class="line">		   int64_t slide,</div><div class="line">		   struct vnode	*vp,</div><div class="line">		   cpu_type_t cputype,</div><div class="line">		   cpu_subtype_t cpusubtype)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	if (eip-&gt;cmdsize &lt; sizeof(*eip)) return LOAD_BADMACHO;</div><div class="line"></div><div class="line">	switch(eip-&gt;cryptid) &#123;</div><div class="line">		case 0:</div><div class="line">			/* not encrypted, just an empty load command */</div><div class="line">			return LOAD_SUCCESS;</div><div class="line">		case 1:</div><div class="line">			cryptname=&quot;com.apple.unfree&quot;;</div><div class="line">			break;</div><div class="line">		case 0x10:</div><div class="line">			/* some random cryptid that you could manually put into</div><div class="line">			 * your binary if you want NULL */</div><div class="line">			cryptname=&quot;com.apple.null&quot;;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			return LOAD_BADMACHO;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (map == VM_MAP_NULL) return (LOAD_SUCCESS);</div><div class="line">	if (NULL == text_crypter_create) return LOAD_FAILURE;</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	/* set up decrypter first */</div><div class="line">	crypt_file_data_t crypt_data = &#123;</div><div class="line">		.filename = vpath,</div><div class="line">		.cputype = cputype,</div><div class="line">		.cpusubtype = cpusubtype&#125;;</div><div class="line">	kr=text_crypter_create(&amp;crypt_info, cryptname, (void*)&amp;crypt_data);</div><div class="line">	FREE_ZONE(vpath, MAXPATHLEN, M_NAMEI);</div><div class="line"></div><div class="line">	......</div><div class="line"></div><div class="line">	offset = mach_header_sz;</div><div class="line">	uint32_t ncmds = header-&gt;ncmds;</div><div class="line">	while (ncmds--) &#123;</div><div class="line">		/*</div><div class="line">		 *	Get a pointer to the command.</div><div class="line">		 */</div><div class="line">		struct load_command *lcp = (struct load_command *)(addr + offset);</div><div class="line">		offset += lcp-&gt;cmdsize;</div><div class="line"></div><div class="line">		switch(lcp-&gt;cmd) &#123;</div><div class="line">			case LC_SEGMENT_64:</div><div class="line">				seg64 = (struct segment_command_64 *)lcp;</div><div class="line">				if ((seg64-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg64-&gt;fileoff+seg64-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg64-&gt;vmaddr + eip-&gt;cryptoff - seg64-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">			case LC_SEGMENT:</div><div class="line">				seg32 = (struct segment_command *)lcp;</div><div class="line">				if ((seg32-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</div><div class="line">				    (seg32-&gt;fileoff+seg32-&gt;filesize &gt;=</div><div class="line">				     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</div><div class="line">					map_offset = seg32-&gt;vmaddr + eip-&gt;cryptoff - seg32-&gt;fileoff + slide;</div><div class="line">					map_size = eip-&gt;cryptsize;</div><div class="line">					goto remap_now;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* if we get here, did not find anything */</div><div class="line">	return LOAD_BADMACHO;</div><div class="line"></div><div class="line">remap_now:</div><div class="line">	/* now remap using the decrypter */</div><div class="line">	kr = vm_map_apple_protected(map, map_offset, map_offset+map_size, &amp;crypt_info);</div><div class="line">	if(kr) &#123;</div><div class="line">		printf(&quot;set_code_unprotect(): mapping failed with %x\n&quot;, kr);</div><div class="line">		crypt_info.crypt_end(crypt_info.crypt_ops);</div><div class="line">		return LOAD_PROTECT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return LOAD_SUCCESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p><code>text_crypter_create()</code>是一个全局的<code>text_crypter_create_hook_t</code>类型的指针，在内核代码“osfmk/kern/page_decrypt.c”文件中通过<code>text_crypter_create_hook_set()</code>进行设置。<br><code>text_crypter_create()</code>在填充完解密所需的信息<code>crypt_info</code>后，会再次计算需要重新解密映射到内存的地址与大小，调用<code>vm_map_apple_protected()</code>进行解密操作。</p>
<p>由于内核的代码可以直接审阅，数据加密在macOS系统上显得意义不大，在目前最新的macOS 10.12系统上，苹果没有启用代码解密功能，<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>加载命令也就没那么常见了。</p>
<p>最后，可以使用<code>otool</code>命令行工具来查看Mach-O文件的加载命令信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> otool -l /usr/bin/python</div><div class="line">/usr/bin/python:</div><div class="line">Load command 0</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 72</div><div class="line">  segname __PAGEZERO</div><div class="line">   vmaddr 0x0000000000000000</div><div class="line">   vmsize 0x0000000100000000</div><div class="line">  fileoff 0</div><div class="line"> filesize 0</div><div class="line">  maxprot 0x00000000</div><div class="line"> initprot 0x00000000</div><div class="line">   nsects 0</div><div class="line">    flags 0x0</div><div class="line">Load command 1</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">    ......</div><div class="line">Load command 15</div><div class="line">      cmd LC_DATA_IN_CODE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 17776</div><div class="line"> datasize 0</div><div class="line">Load command 16</div><div class="line">      cmd LC_CODE_SIGNATURE</div><div class="line">  cmdsize 16</div><div class="line">  dataoff 20528</div><div class="line"> datasize 9344</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>MachOView</code>查看，效果如图所示：<br><img src="/2017/01/13/macho/load_command.png" alt="load_command"></p>
<h2 id="0x6-LC-SEGMENT"><a href="#0x6-LC-SEGMENT" class="headerlink" title="0x6 LC_SEGMENT"></a>0x6 LC_SEGMENT</h2><p>段加载命令<code>LC_SEGMENT</code>，描述了32位Mach-O文件的段的信息，使用<code>segment_command</code>结构体来表示，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command &#123; /* for 32-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint32_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint32_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint32_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint32_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>segname</code>字段是一个16字节大小的空间，用来存储段的名称。<br><code>vmaddr</code>字段指明了段要加载的虚拟内存地址。<br><code>vmsize</code>字段指明了段所占的虚拟内存的大小。<br><code>fileoff</code>字段指明了段数据所在文件中偏移地址。<br><code>filesize</code>字段指明了段数据实际的大小。<br><code>maxprot</code>字段指明了页面所需要的最高内存保护。<br><code>initprot</code>字段指明了页面初始的内存保护。<br><code>nsects</code>字段指明了段所包含的节区（section）。<br><code>flags</code>字段指明了段的标志信息。</p>
<p>与<code>LC_SEGMENT</code>对应的是<code>LC_SEGMENT_64</code>，它使用<code>segment_command_64</code>结构体表示，描述了64位Mach-O文件的段的基本信息，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* includes sizeof section_64 structs */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* memory address of this segment */</div><div class="line">	uint64_t	vmsize;		/* memory size of this segment */</div><div class="line">	uint64_t	fileoff;	/* file offset of this segment */</div><div class="line">	uint64_t	filesize;	/* amount to map from the file */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* number of sections in segment */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所有的字段含义与32位基本一致。主要讨论一下它最后4个字段。</p>
<p>一个编译后可能执行的程序分成了多个段，不同的类型的数据放入了不同的段中。如程序的代码被称作代码段，<br>放入一个名为<code>__TEXT</code>的段中，代码段的<code>maxprot</code>字段在编译时被设置成<code>VM_PROT_READ</code>（可读）、<code>VM_PROT_WRITE</code>（可写）、<code>VM_PROT_EXECUTE</code>（可执行），<code>initprot</code>字段被设置成<br><code>VM_PROT_READ</code>（可读）与<code>VM_PROT_EXECUTE</code>（可执行），这样做是合理的，一个普通的应用程序，它的代码段部分通常是不可写的，特殊需求的程序，如果要求代码段可写，必须在编译时设置它的<br><code>initprot</code>字段为<code>VM_PROT_WRITE</code>（可写）。</p>
<p><code>nsects</code>字段指定了段加载命令包含几个节区（section），一个段可以包含0个或多个节区。如<code>__PAGEZERO</code>段就不包含任何节区，该段被称为空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。<br>当一个段包含多个节区时，节区信息会以数组形式紧随着存储在段加载命令后面。节区使用结构体<code>section</code>表示（64位使用<code>section_64</code>表示），定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">	char		sectname[16];	/* name of this section */</div><div class="line">	char		segname[16];	/* segment this section goes in */</div><div class="line">	uint32_t	addr;		/* memory address of this section */</div><div class="line">	uint32_t	size;		/* size in bytes of this section */</div><div class="line">	uint32_t	offset;		/* file offset of this section */</div><div class="line">	uint32_t	align;		/* section alignment (power of 2) */</div><div class="line">	uint32_t	reloff;		/* file offset of relocation entries */</div><div class="line">	uint32_t	nreloc;		/* number of relocation entries */</div><div class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</div><div class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</div><div class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>sectname</code>字段表示节区的名称，<code>segname</code>字段表示节区所在的段名，<code>addr</code>与<code>size</code>指明了节区所在的内存地址与大小，<code>offset</code>指明了区取所在的文件偏移，<br><code>align</code>表示节区的内存对齐边界，<code>reloff</code>指明了重定位信息的文件偏移，<code>nreloc</code>表示重定位条目的数目，<code>flags</code>则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段<code>flags</code>存储了段的一些标志属性，它的取值有如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define	SG_HIGHVM	0x1</div><div class="line">#define	SG_FVMLIB	0x2</div><div class="line">#define	SG_NORELOC	0x4</div><div class="line">#define SG_PROTECTED_VERSION_1	0x8</div></pre></td></tr></table></figure></p>
<p>值得关注的是<code>SG_PROTECTED_VERSION_1</code>，当段被设置了该标志位，表示段是经过加密的！在macOS版本10.6以前，系统使用AES算法进行段的加密与解密，10.6的时候，则使用的Blowfish加密算法，著名的iOS逆向工具<code>class-dump</code>（地址：<a href="https://github.com/nygard/class-dump）" target="_blank" rel="external">https://github.com/nygard/class-dump）</a> 提供了一个静态数据段解密工具<code>deprotect</code>，有兴趣的读者可以参看它的代码来了解段解密的部分。</p>
<p>最后，使用<code>MachOView</code>工具查看系统python程序的<code>__TEXT</code>段的信息如图所示：<br><img src="/2017/01/13/macho/python_seg.png" alt="python_seg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/13/macho/" data-id="cixww7lnd0005f3vj235ahar2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
  
</article>


  
    <article id="post-install-software" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/install-software/" class="article-date">
  <time datetime="2017-01-12T03:27:10.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/install-software/">macOS平台软件的下载与安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于一个操作系统来说，对其影响最大的莫过于运行在它上面的软件，正因为这些形形色色软件的存在，操作系统才得以广泛应用。与Linux、Windows等主流操作系统一样，运行在macOS上的软件也有着自己独有的特点。</p>
<p>macOS上的软件有着自己独特的UI界面与操作方式。macOS的设计师一直秉承着自己的设计理念，设计出的Aqua界面别具风格。银灰的金属色主题始终是分辨macOS系统最快捷的一种方式，与Windows界面将最小按钮与关闭按钮设置到窗口右上角不同，Aqua界面的程序，最小化与关闭按钮位于软件的左上角，并且使用全屏按钮替换了Windows上的最大化按钮。进入全屏模式下的软件会新开一个窗口并占据屏幕的全部空间，可以在触摸板上使用三根手指左右划动来切换不同的全屏窗口。</p>
<p>每个常规的Aqua界面的程序都有一个菜单，菜单显示在用户屏幕的顶端，菜单的最左边始终是一个苹果图标，点击它会弹出系统设置、<code>App Store</code>、关机、重启等多个选项。<br>macOS使用Dock栏来管理显示常用的软件，它位于用户屏幕的底部，展示效果与Windows的任务栏相似，正在运行的macOS界面程序，都可以在Dock上右键点击该程序，在弹出的菜单中选择Options-&gt;Keep in Dock，将程序在Dock上保留下来，以后就可以直接从Dock中单击图标启动程序。<br>在Windows系统中，用户可以使用开始菜单-&gt;所有程序来找到系统中安装的软件并启动它，macOS中则提供了一个<code>Launchpad</code>程序来管理安装在/Applications目录中的软件。<code>Launchpad</code>移植于iOS系统中的<code>SpringBoard</code>，展示的效果也与之类似，它以全屏网格形式的界面显示了所有可以运行的软件与系统工具，如果软件安装过多，会以多个页面来展示。点击Dock上的<code>Launchpad</code>图标可以启动它，如图所示：<br><img src="/2017/01/12/install-software/launchpad.png" alt="launchpad"><br>使用二根手指左右划动可以在不同的页面间切换。</p>
<h3 id="0x0-可执行文件"><a href="#0x0-可执行文件" class="headerlink" title="0x0 可执行文件"></a>0x0 可执行文件</h3><p>除了Aqua界面的程序，macOS上还可以运行很多其它种类的文件，这里将所有可以运行在macOS系统上文件的统称为macOS可执行文件。</p>
<p>首先是脚本，macOS提供了UNIX系统中的Shell环境来支持运行脚本与命令行程序，脚本实质是一个文本文件，在脚本文件中指定运行它解释器后，Shell在运行脚本时，会调用解释器来解释运行它，任何一个文件都可以通过执行”chmod +x”命令给它加上可执行权限，拥有可执行权限的文件并不一定能执行，它必须是能满足某种解释器的语法规则才算得上可执行文件。<br>除了主流的几种Shell脚本支持外，macOS还内置了目前比较流行的<code>Perl</code>、<code>Python</code>和<code>Ruby</code>等脚本的解释器，任何人都可以直接编写<code>Perl</code>、<code>Python</code>和<code>Ruby</code>脚本并调用它们的解释器来运行，而不需要安装额外的软件。</p>
<p>另外，苹果公司还开发了一种脚本：AppleScript（苹果脚本）。它的作用是用于运行在macOS的程序并实际自动化工作的。苹果提供了一个单独的脚本编辑器来开发与调试AppleScript。它位于/Applications/Ｕtilities/Script Editor。使用<code>Script Editor</code>编写好的脚本保存的格式为scpt。随着macOS系统的不断升级，<code>AppleScript</code>也在不停的发展，目前甚至可以使用<code>AppleScript</code>来开发macOS上的界面程序。具体的步骤是在XCode中选择File-&gt;New-&gt;Project，在打开的对话框中选择Other-&gt;Cocoa-AppleScript。有兴趣的读者可以参看苹果的官方文档来深入了解AppleScript，地址上：<a href="https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html</a> 。</p>
<p>除了脚本外，可执行文件还包括可以由用户主动执行的程序与被动执行的程序文件。<br>主动执行的程序包括：GUI界面程序、命令行程序、游戏等；被动执行的程序包括被系统调用的程序，如：<code>Quick Look</code>插件、屏幕保护程序、内核驱动与扩展等，以及被程序调用的框架、库、Bundle、XPC服务等。所有的这些可执行文件都使用苹果独有的可执行文件格式Mach-O。关于Mach-O文件的格式，将在后面的小节中进行详细讲解。</p>
<h3 id="0x1-下载与安装软件"><a href="#0x1-下载与安装软件" class="headerlink" title="0x1 下载与安装软件"></a>0x1 下载与安装软件</h3><p>苹果支持从自家的<code>App Store</code>应用商店直接安装软件，也支持从第三方渠道，如其它磁盘介质、网络下载来安装软件。从<code>App Store</code>下载软件是最方便快捷，也是最安全的一种方式，苹果公司一向以软件审查严格闻名，自家商店中的应用软件在界面、功能以及对系统资源的使用上，都是经常严格审查与限制的，对于普通用户来说，这种下载软件的方式最合适不过了，但对于专业用户来说，由于一些专业软件在用户授权协议、资源访问上或其它方面的原因未能在<code>App Store</code>上架，就只能从网络或第三方渠道来获取这类软件了。</p>
<h4 id="0x1-1-免费与付费软件"><a href="#0x1-1-免费与付费软件" class="headerlink" title="0x1.1 免费与付费软件"></a>0x1.1 免费与付费软件</h4><p><code>App Store</code>应用商店上提供了丰富的免费与付费的软件供用户下载使用。下载免费的软件不需要用户付出额外的成本，只需要到官网<a href="https://appleid.apple.com/" target="_blank" rel="external">https://appleid.apple.com/</a> 注册一个的帐号，使用帐号登录<code>App Store</code>就可以下载上面的免费软件了。<br>如果要下载<code>App Store</code>上面的收费软件，需要为帐号绑定一张银行卡，购买软件成功后会直接从银行卡中扣取费用。另外，<code>App Store</code>中的软件还支持另一种收费方式：<code>In-App Purchase</code>（应用内付费），简称IAP，这种收费方式在苹果自家的iOS系统中应用非常广泛，它允许开发人员为自己的软件某些特定功能设定为需要购买才能使用，目前，很多软件开发商以此平台作为主要的软件收入来源。</p>
<p><code>App Store</code>中的收费软件只有IAP与直接购买这两种方式，而网络下载的收费软件的付费形式则丰富很多。部分软件官网只提供软件基础功能的演示版本供用户下载，如果需要使用正式版本，则需要联系软件开发商购买完整版本。例如著名的反汇编软件<code>IDA Pro</code>，官网就只提供了Demo版本可供下载：<a href="https://www.hex-rays.com/products/ida/support/download_demo.shtml" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/download_demo.shtml</a> ，正式版本需要找软件开发商或代理商购买。也有些软件的官网会提供完整版本下载，但会有使用时间或功能限制，如果需要正常无限制使用软件，则需要购买软件授权，如反汇编软件<code>Hopper</code>（<a href="http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010" target="_blank" rel="external">http://hopperapp.com/）。还有部分软件与传统Window付费软件一样，使用用户名与注册码的形式来售卖软件，如`010</a> Editor`（<a href="http://www.sweetscape.com/010editor/）。" target="_blank" rel="external">http://www.sweetscape.com/010editor/）。</a></p>
<h4 id="0x1-2-安装软件"><a href="#0x1-2-安装软件" class="headerlink" title="0x1.2 安装软件"></a>0x1.2 安装软件</h4><p>普通的macOS软件只是一个以扩展名.app结尾的目录，这种目录有着特定的组织结构，macOS将它称之为Bundle，安装这类软件只需要将Bundle复制到系统的/Applications目录即可，复制完成后，<code>Launchpad</code>面板会自动更新安装好的软件图标，启动软件不需要到/Applications目录中去寻找它，只需要打开<code>Launchpad</code>，找到软件的图标并点击就可以运行该程序了。<br>从网络上下载的软件通常是经过打包后发布的，普通的软件多是zip或其它方式压缩后，以压缩包的形式提供下载，还有的使用磁盘工具将软件打包成一个dmg磁盘镜像文件，这类dmg文件内通常还会有一个Applications目录的软链接，安装的时候，只需要将dmg中的软件直接拖放到该软链接上就算完成安装了。如图所示，是<code>AppDelete</code>的安装镜像：<br><img src="/2017/01/12/install-software/install_app.png" alt="install_app"></p>
<p>macOS上的软件还有一种是以pkg或mpkg结尾的安装包，类似于Windows系统上的msi或exe安装程序，通过不停的点击下一步就可以完成安装，这类软件除了将主程序写入/Applications目录外，一般还会在系统上做一些只有管理员权限才能完成的动作，比如为特定的目录或文件创建软链接、安装与卸载内核扩展、复制命令行程序到用户可执行文件目录/usr/local/bin中等。因此，在安装的过程中，可能会提示输入管理员用户名与密码来执行需要Root权限的操作。</p>
<p>另一种是命令行工具，这类程序的安装使用第一章中介绍的<code>Homebrew</code>即可，此处不再赘述。</p>
<h3 id="0x3-Bundle"><a href="#0x3-Bundle" class="headerlink" title="0x3 Bundle"></a>0x3 Bundle</h3><p>Bundle是苹果系统独有的特色，在苹果系统上大量中使用了Bundle。</p>
<h4 id="0x3-1-Bundle目录结构"><a href="#0x3-1-Bundle目录结构" class="headerlink" title="0x3.1 Bundle目录结构"></a>0x3.1 Bundle目录结构</h4><p>安装到macOS系统上的软件有着自己特定的格式，它们是以.app扩展名结尾的Bundle目录结构。Bundle有着固定的组织格式，在Finder中查看Bundle的目录内容，可以在程序上点右键，在弹出的菜单中选择Show Package Contents，查看Bundle的目录结构。以/Applications目录下<code>App Store</code>为例，它的目录结构如图所示：<br><img src="/2017/01/12/install-software/bundle.png" alt="bundle"></p>
<p>在App Store.app目录下，只有一个Contents子目录，所有软件的内容都在此目录下。它们包括：</p>
<ul>
<li>CodeSignature目录。此目录下只有一个CodeResources文件，它是一个plist格式的文件，保存了软件包中所有文件的签名信息。</li>
<li>info.plist文件。此文件记录了软件的一些信息。如软件构建的机器的版本<code>BuildMachineOSBuild</code>、可执行文件名<code>CFBundleExecutable</code>、软件的标识<code>CFBundleIdentifier</code>、软件包名<code>CFBundleName</code>等。</li>
<li>MacOS目录。此目录存放了可执行文件。</li>
<li>Pkginfo文件。软件包的8字节的标识符。</li>
<li>Resources目录。软件运行所需要的资源，包括.iproj本地化资源、.nib资源、图片、字体、声音、文档以及其它文件。</li>
<li>Plugins目录。插件目录，存放了软件用到的插件，插件也是使用Bundle目录结构进行组织的一种程序。</li>
</ul>
<p>除了Plugins目录外，根据软件需求与实现的不同，Contents下可能还会有Frameworks与XPCServices目录，Frameworks里面存放了软件需要用到的框架，它是以.framework结尾的Bundle结构；XPCServices则存放了软件用到的XPC服务，它是以.xpc结尾的Bundle结构，还有一种以.bundle扩展名结尾的Bundle，它是“纯粹”的Bundle，目录结构与其它的Bundle无异，存放的内容可以是二进制代码，也可以是资源，也可以二者同时存放，如果存放二进制代码的话，可供程序在代码中使用<code>dlopen()</code>函数打开，这种Bundle通常用于制作软件的插件，存放在软件Bundle的Resources目录下。</p>
<h4 id="0x3-2-代码中访问Bundle"><a href="#0x3-2-代码中访问Bundle" class="headerlink" title="0x3.2 代码中访问Bundle"></a>0x3.2 代码中访问Bundle</h4><p>在程序中，开发人员可以使用<code>Cocoa</code>框架提供的<code>NSBundle</code>类来获取程序的Bundle信息。调用<code>NSBundle</code>的<code>mainBundle()</code>方法可以返回当前程序的主Bundle对象，调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSBundle *bundle = [NSBundle mainBundle]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>infoDictionary()</code>方法可以访问软件Bundle目录下info.plist文件中的信息，它返回的是一个字典对象，如下所示是获取程序标识符的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleIdentifier&quot;]]</div></pre></td></tr></table></figure></p>
<p>使用主Bundle对象的<code>pathForResource()</code>方法可以访问Bundle目录下任意资源文件。如下所示是访问Bundle根目录下的monkey.png文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *monkey = [[NSBundle mainBundle] pathForResource:@&quot;monkey&quot; ofType:@&quot;png&quot;];</div></pre></td></tr></table></figure></p>
<p>与主Bundle对应的是自定义Bundle，这一类Bundle的访问可以这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *resourceBundle = [[NSBundle mainBundle] pathForResource:@&quot;ResPack&quot; ofType:@&quot;bundle&quot;];</div><div class="line">NSLog(@&quot;resourceBundle: %@&quot;, resourceBundle);</div><div class="line">NSString *monkey = [[NSBundle bundleWithPath:resourceBundle] pathForResource:@&quot;monkey&quot;</div><div class="line">			ofType:@&quot;png&quot; inDirectory:@&quot;Images&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;monkey path: %@&quot;, monkey);</div></pre></td></tr></table></figure></p>
<p>上面这段代码访问了ResPack.bundle中Images目录下的monkey.png文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/12/install-software/" data-id="cixww7ln20001f3vjg27sb5eu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>

    </footer>
  </div>
  
  
</article>


  
    <article id="post-new-chapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/new-chapter/" class="article-date">
  <time datetime="2017-01-11T05:56:48.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/new-chapter/">新的篇章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>欢迎来到 <a href="https://feicong.github.io/">非虫的博客</a>! 自从12年放弃百度空间后，再没写过博客了。</p>
<p>新的一年，新的篇章，非虫的博客全新开启，以此记录生活点滴，同时作为自己技术分享的平台，希望你会喜欢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://feicong.github.io/2017/01/11/new-chapter/" data-id="cixww7ln90004f3vjr5a557o8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS软件安全/">macOS软件安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS软件安全/" style="font-size: 10px;">macOS软件安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/14/dylib/">dylib动态库加载过程分析</a>
          </li>
        
          <li>
            <a href="/2017/01/13/macho/">Mach-O文件格式</a>
          </li>
        
          <li>
            <a href="/2017/01/12/install-software/">macOS平台软件的下载与安装</a>
          </li>
        
          <li>
            <a href="/2017/01/12/macos-software/">［置顶］macOS软件安全系列-软件内幕篇</a>
          </li>
        
          <li>
            <a href="/2017/01/11/new-chapter/">新的篇章</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
      <div class="widget">
      	<ul>
        	
          	<li class='link'><a href='https://ydc1992.github.io'>Ken&#39;s Blog</a></li>
        	
      	</ul>
      </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>